<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Translation Group &mdash; Principia Materia  documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/copybutton.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/custom_style.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/clipboard.min.js"></script>
        <script src="../_static/copybutton.js"></script>
        <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Representation" href="representation.html" />
    <link rel="prev" title="Compute Phonon Linewidth and Thermal Conductivity" href="compute_thermal.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../contents.html" class="icon icon-home"> Principia Materia
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../index.html">Welcome</a></li>
<li class="toctree-l1"><a class="reference internal" href="../install.html">Installation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="contents.html">Documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="crystal_structure.html">Entering Crystal Structures</a></li>
<li class="toctree-l2"><a class="reference internal" href="compute_id.html">Compute Irreducible Derivatives</a></li>
<li class="toctree-l2"><a class="reference internal" href="compute_thermal.html">Compute Phonon Linewidth and Thermal Conductivity</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Translation Group</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#cluster-class">Cluster Class</a></li>
<li class="toctree-l3"><a class="reference internal" href="#lattice">Lattice</a></li>
<li class="toctree-l3"><a class="reference internal" href="#crystal-and-finite-translation-group">Crystal and Finite Translation Group</a></li>
<li class="toctree-l3"><a class="reference internal" href="#algorithm-to-find-translation-vectors-of-any-given-supercell">Algorithm to find translation vectors of any given supercell</a></li>
<li class="toctree-l3"><a class="reference internal" href="#algorithm-to-find-the-minimum-supercell-for-a-given-list-of-textbf-q-points">Algorithm to find the minimum supercell for a given list of <span class="math notranslate nohighlight">\(\textbf{q}\)</span>-points</a></li>
<li class="toctree-l3"><a class="reference internal" href="#q-points-at-a-given-order-and-ftg"><span class="math notranslate nohighlight">\(Q\)</span>-points at a given order and FTG</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="representation.html">Representation</a></li>
<li class="toctree-l2"><a class="reference internal" href="hamiltonian.html">Hamiltonian</a></li>
<li class="toctree-l2"><a class="reference internal" href="phonon_and_interactions.html">Phonons and their interactions</a></li>
<li class="toctree-l2"><a class="reference internal" href="configuration.html">Configuration</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../examples/contents.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ci.html">Continuous Integration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api_doc/modules.html">API Documentations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../report_issues.html">Reporting Issues</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../contents.html">Principia Materia</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../contents.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="contents.html">Documentation</a> &raquo;</li>
      <li>Translation Group</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/documentation/translation_group.rst.txt" rel="nofollow"> View page source</a>
          <a href="https://github.com/marianettigroup/principia-materia" style="padding-top: 0px; padding-bottom: 0px;">
            <img class="gh-icon" src='_static/github.svg' alt="Visit the project on GitHub"/>
          </a>
      </li>
<!--
-->

  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="translation-group">
<span id="id1"></span><h1>Translation Group<a class="headerlink" href="#translation-group" title="Permalink to this headline"></a></h1>
<p>In this section, the main usage of the classes in translation group module will be demonstrated with examples.
The module is developed in an object oriented manner, such that the Cluster and the Lattice classes serve as
the foundation of the module and the other classes (e.g. Kpoints, Crystal, CrystalFTG and QpointsN)
are derived from these two classes.</p>
<section id="cluster-class">
<span id="cluster"></span><h2>Cluster Class<a class="headerlink" href="#cluster-class" title="Permalink to this headline"></a></h2>
<p>We begin with the Cluster class, which is a collection of atoms that forms a system such as a molecule.
Here we can create a Cluster class object of a <span class="math notranslate nohighlight">\(\textrm{CO}_2\)</span> molecule with the molecular structure illustrated
in <a class="reference internal" href="#fig-diag-co2"><span class="std std-numref">Fig. 2</span></a>, and the following statements are used to construct the Cluster object for the molecule.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">atoms</span> <span class="o">=</span> <span class="p">{</span>
<span class="go">        &quot;C&quot;: np.array([</span>
<span class="go">            [0.0, 0.0, 0.0]</span>
<span class="go">        ]),</span>
<span class="go">        &quot;O&quot;: np.array([</span>
<span class="go">            [ 1.0, 0.0, 0.0],</span>
<span class="go">            [-1.0, 0.0, 0.0]</span>
<span class="go">        ])</span>
<span class="go">    }</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cluster</span> <span class="o">=</span> <span class="n">Cluster</span><span class="p">(</span><span class="n">atoms</span><span class="o">=</span><span class="n">atoms</span><span class="p">,</span> <span class="n">orbitals</span><span class="o">=</span><span class="s2">&quot;p_x,p_y&quot;</span><span class="p">)</span>
</pre></div>
</div>
<figure class="align-center" id="fig-diag-co2">
<a class="reference internal image-reference" href="../_images/co2.png"><img alt="../_images/co2.png" src="../_images/co2.png" style="width: 400px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 2 </span><span class="caption-text">Structure diagram of a <span class="math notranslate nohighlight">\(\textrm{CO}_2\)</span> molecule.</span><a class="headerlink" href="#fig-diag-co2" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>Since the 3 atoms of the molecule are positioned along a line,
the displacements can be categorized into an along-the-axis mode and a perpendicular-to-axis mode,
Thus we can set the orbitals of the Cluster to <span class="math notranslate nohighlight">\(p_x\)</span> and <span class="math notranslate nohighlight">\(p_y\)</span> to simplify the study of the atomic displacements.</p>
<p>This class serves as a foundation to analyzing the properties of molecules, and we can apply various operations
to the module, for example a <span class="math notranslate nohighlight">\(90^\circ\)</span> rotation:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rotation_90</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
<span class="go">        [0, 1, 0],</span>
<span class="go">        [1, 0, 0],</span>
<span class="go">        [0, 0, 1],</span>
<span class="go">    ], dtype=float)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">example_cluster</span> <span class="o">=</span> <span class="n">cluster</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">example_cluster</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">rotation_90</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">example_cluster</span><span class="o">.</span><span class="n">atoms</span>
<span class="go">OrderedDict([(&#39;C&#39;, array([[0., 0., 0.]])), (&#39;O&#39;, array([[ 0.,  1.,  0.],</span>
<span class="go">        [ 0., -1.,  0.]]))])</span>
</pre></div>
</div>
<p>Here, the center of the molecule is defined as the average positions of all atoms.
In the case of the above molecule, it’s at the origin of the coordinate system:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cluster</span><span class="o">.</span><span class="n">center</span>
<span class="go">array([0., 0., 0.])</span>
</pre></div>
</div>
<p>And we can also move the entire cluster to relocate the origin onto one of the O atoms:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">example_cluster</span> <span class="o">=</span> <span class="n">cluster</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">example_cluster</span><span class="o">.</span><span class="n">shift_atoms</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">example_cluster</span><span class="o">.</span><span class="n">center</span>
<span class="go">array([1., 0., 0.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">example_cluster</span><span class="o">.</span><span class="n">atoms</span>
<span class="go">OrderedDict([(&#39;C&#39;, array([[1., 0., 0.]])), (&#39;O&#39;, array([[2., 0., 0.],</span>
<span class="go">       [0., 0., 0.]]))])</span>
</pre></div>
</div>
</section>
<section id="lattice">
<h2>Lattice<a class="headerlink" href="#lattice" title="Permalink to this headline"></a></h2>
<p>Lattice is an infinite array of points generated by translation symmetry from the primitive translation vectors (a.k.a. lattice vectors),
serving as a basic building block of the translation group.</p>
<p>Here the lattice vectors of face center cubic is used as a demonstration:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">lattice_vectors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
<span class="go">        [0.0, 0.5, 0.5],</span>
<span class="go">        [0.5, 0.0, 0.5],</span>
<span class="go">        [0.5, 0.5, 0.0],</span>
<span class="go">    ])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lattice</span> <span class="o">=</span> <span class="n">Lattice</span><span class="p">(</span><span class="n">vec</span><span class="o">=</span><span class="n">lattice_vectors</span><span class="p">)</span>
</pre></div>
</div>
<p>With the above Lattice class object, we can compute various properties of the lattice.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;volume:&quot;</span><span class="p">,</span> <span class="n">lattice</span><span class="o">.</span><span class="n">vol</span><span class="p">)</span>
<span class="go">volume: 0.25</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;lengths of the lattice vectors:&quot;</span><span class="p">,</span> <span class="n">lattice</span><span class="o">.</span><span class="n">abc</span><span class="p">)</span>
<span class="go">lengths of the lattice vectors: [0.70710678 0.70710678 0.70710678]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;angles between the lattice vectors:&quot;</span><span class="p">,</span> <span class="n">lattice</span><span class="o">.</span><span class="n">abg</span><span class="p">)</span>
<span class="go">angles between the lattice vectors: [60. 60. 60.]</span>
</pre></div>
</div>
<p>Meanwhile, a real space lattice comes with a reciprocal lattice. We can also compute the properties of the reciprocal lattice.
(In the convention of our software, the reciprocal lattice vectors contain the <span class="math notranslate nohighlight">\(2\pi\)</span> factor in normalization.)</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;volume of reciprocal lattice:&quot;</span><span class="p">,</span> <span class="n">lattice</span><span class="o">.</span><span class="n">rvol</span><span class="p">)</span>
<span class="go">volume of reciprocal lattice: 992.200854</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;lengths of the reciprocal lattice vectors:&quot;</span><span class="p">,</span> <span class="n">lattice</span><span class="o">.</span><span class="n">rabc</span><span class="p">)</span>
<span class="go">lengths of the reciprocal lattice vectors: [10.88279619 10.88279619 10.88279619]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;angles between the reciprocal lattice vectors:&quot;</span><span class="p">,</span> <span class="n">lattice</span><span class="o">.</span><span class="n">rabg</span><span class="p">)</span>
<span class="go">angles between the reciprocal lattice vectors: [109.47122063 109.47122063 109.47122063]</span>
</pre></div>
</div>
<p>Additionally, the Lattice class allows us to perform various operation to a lattice, for example applying an axial strain:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">strain</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.02</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="c1"># axial strain along x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">example_lattice</span> <span class="o">=</span> <span class="n">lattice</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">example_lattice</span><span class="o">.</span><span class="n">axial_strain</span><span class="p">(</span><span class="n">strain</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">example_lattice</span><span class="o">.</span><span class="n">vec</span><span class="p">)</span>
<span class="go">[[0.   0.5  0.5 ]</span>
<span class="go"> [0.51 0.   0.5 ]</span>
<span class="go"> [0.51 0.5  0.  ]]</span>
</pre></div>
</div>
</section>
<section id="crystal-and-finite-translation-group">
<h2>Crystal and Finite Translation Group<a class="headerlink" href="#crystal-and-finite-translation-group" title="Permalink to this headline"></a></h2>
<p>A crystal consists of a lattice and a collection of basis atoms in the primitive unit cell.
Thus we created the Crystal class by deriving from both the Lattice and the Cluster classes simultaneously.
Here we construct a rock salt crystal with lattice parameter <span class="math notranslate nohighlight">\(a=1\)</span> for demonstration.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">lattice_vectors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
<span class="go">        [0.0, 0.5, 0.5],</span>
<span class="go">        [0.5, 0.0, 0.5],</span>
<span class="go">        [0.5, 0.5, 0.0],</span>
<span class="go">    ])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atoms</span> <span class="o">=</span> <span class="p">{</span>
<span class="go">        &quot;Na&quot;: np.array([[0.0, 0.0, 0.0]]),</span>
<span class="go">        &quot;Cl&quot;: np.array([[0.5, 0.5, 0.5]]),</span>
<span class="go">    }</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">crystal</span> <span class="o">=</span> <span class="n">Crystal</span><span class="p">(</span><span class="n">vec</span><span class="o">=</span><span class="n">lattice_vectors</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="n">atoms</span><span class="p">)</span>
</pre></div>
</div>
<p>The Crystal class inherits all the aforementioned functionalities of Lattice and Cluster classes,
although the method to rotate atoms is updated due to the Crystal using direct coordinates
instead of the Cartesian coordinates in Cluster class.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rotation_90</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
<span class="go">        [0, -1, 0],</span>
<span class="go">        [1,  0, 0],</span>
<span class="go">        [0,  0, 1],</span>
<span class="go">    ], dtype=float)</span>
<span class="go">&gt;&gt; example_crystal = crystal.copy()</span>
<span class="go">&gt;&gt; print(example_crystal.positions_cartesian)</span>
<span class="go">[[0.  0.  0. ]</span>
<span class="go"> [0.5 0.5 0.5]]</span>
<span class="go">&gt;&gt; print(example_crystal.rotate_atoms(rotation_90))</span>
<span class="go">[[ 0.   0.   0. ]</span>
<span class="go"> [ 1.5 -0.5 -0.5]]</span>
</pre></div>
</div>
<p>Due to limitations of the complexity and computing power, we are unable to work with the infinite lattice.
Thus we often turn to a finite translation group (see <a class="reference external" href="https://doi.org/10.1103/PhysRevB.100.014303">paper</a> for details) as an approximation.
A finite translation group is defined by a supercell with which there are a finite number of translation
vectors that translate the primitive cell of the crystal across the space.
Thus we can derive the CrystalFTG class from the Crystal class,
and construct a CrystalFTG class object from a Crystal class object with a supercell matrix.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">supa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">crystal</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">supa</span>
<span class="go">array([[2, 0, 0],</span>
<span class="go">       [0, 2, 0],</span>
<span class="go">       [0, 0, 2]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">crystal_ftg</span> <span class="o">=</span> <span class="n">CrystalFTG</span><span class="o">.</span><span class="n">from_primitive</span><span class="p">(</span><span class="n">crystal</span><span class="p">,</span> <span class="n">supa</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">crystal_ftg</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
<span class="go">OrderedDict([(&#39;vec&#39;,</span>
<span class="go">              array([[0. , 0.5, 0.5],</span>
<span class="go">                     [0.5, 0. , 0.5],</span>
<span class="go">                     [0.5, 0.5, 0. ]])),</span>
<span class="go">             (&#39;atoms&#39;,</span>
<span class="go">              OrderedDict([(&#39;Na&#39;, array([[0., 0., 0.]])),</span>
<span class="go">                           (&#39;Cl&#39;, array([[0.5, 0.5, 0.5]]))])),</span>
<span class="go">             (&#39;orbitals&#39;, None),</span>
<span class="go">             (&#39;supa&#39;,</span>
<span class="go">              array([[2, 0, 0],</span>
<span class="go">                     [0, 2, 0],</span>
<span class="go">                     [0, 0, 2]]))])</span>
</pre></div>
</div>
<p>The finite translation group, provides various properties of the crystal.</p>
<p>For example, we can construct the Wigner-Seitz cell of the supercell.
This is a crucial piece of information used in our Fourier interpolation scheme (see <a class="reference external" href="https://doi.org/10.1103/PhysRevB.100.014303">paper</a> for details).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ws_cell_translation</span><span class="p">,</span> <span class="n">ws_cell_atoms</span><span class="p">,</span> <span class="n">ws_cell_weights</span> <span class="o">=</span> \
<span class="go">        crystal_ftg.get_wigner_seitz_cell(center=[0, 0, 0])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ws_cell_weights</span>
<span class="go">array([1.        , 0.5       , 0.5       , 0.5       , 0.25      ,</span>
<span class="go">       0.5       , 0.5       , 0.5       , 0.5       , 0.5       ,</span>
<span class="go">       0.5       , 0.5       , 0.5       , 0.5       , 0.16666667,</span>
<span class="go">       0.16666667, 0.16666667, 0.16666667, 0.16666667, 0.16666667,</span>
<span class="go">       0.25      , 0.25      , 0.25      , 1.        , 1.        ,</span>
<span class="go">       1.        , 1.        , 1.        , 1.        , 0.25      ,</span>
<span class="go">       0.25      , 0.25      , 0.25      ])</span>
</pre></div>
</div>
<p>Additionally, we can construct the naive displacements basis vectors of a <span class="math notranslate nohighlight">\(\textbf{q}\)</span>-point.
This is used to construct the symmetrized basis in our LID approach,
where we displace atoms along either the real or imaginary part of
the reciprocal space displacements basis, in order to only activate specific
irreducible derivatives.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">qpoint</span> <span class="o">=</span> <span class="n">parse_array</span><span class="p">(</span><span class="s2">&quot;1/2 0 0&quot;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">Fraction</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qpoint</span>
<span class="go">[Fraction(1, 2), Fraction(0, 1), Fraction(0, 1)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">crystal_ftg</span><span class="o">.</span><span class="n">orbitals</span> <span class="o">=</span> <span class="s2">&quot;p&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">basis</span> <span class="o">=</span> <span class="n">crystal_ftg</span><span class="o">.</span><span class="n">get_basis_at_q</span><span class="p">(</span><span class="n">qpoint</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">basis</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;p_x&quot;</span><span class="p">)]</span><span class="o">.</span><span class="n">real</span>
<span class="go">array([[ 0.35355339,  0.        ,  0.        ],</span>
<span class="go">       [-0.35355339,  0.        ,  0.        ],</span>
<span class="go">       [ 0.35355339,  0.        ,  0.        ],</span>
<span class="go">       [-0.35355339,  0.        ,  0.        ],</span>
<span class="go">       [ 0.35355339,  0.        ,  0.        ],</span>
<span class="go">       [-0.35355339,  0.        ,  0.        ],</span>
<span class="go">       [ 0.35355339,  0.        ,  0.        ],</span>
<span class="go">       [-0.35355339,  0.        ,  0.        ],</span>
<span class="go">       [ 0.        ,  0.        ,  0.        ],</span>
<span class="go">       [ 0.        ,  0.        ,  0.        ],</span>
<span class="go">       [ 0.        ,  0.        ,  0.        ],</span>
<span class="go">       [ 0.        ,  0.        ,  0.        ],</span>
<span class="go">       [ 0.        ,  0.        ,  0.        ],</span>
<span class="go">       [ 0.        ,  0.        ,  0.        ],</span>
<span class="go">       [ 0.        ,  0.        ,  0.        ],</span>
<span class="go">       [ 0.        ,  0.        ,  0.        ]])</span>
</pre></div>
</div>
</section>
<section id="algorithm-to-find-translation-vectors-of-any-given-supercell">
<h2>Algorithm to find translation vectors of any given supercell<a class="headerlink" href="#algorithm-to-find-translation-vectors-of-any-given-supercell" title="Permalink to this headline"></a></h2>
<p>Although diagonal matrices are most commonly used as supercell matrices,
non-diagonal supercells are crucial in the lattice dynamic analysis of crystals.
Phonons and their interactions can be extracted in the smallest non-diagonal supercells
that accommodate the irreducible derivatives (see <a class="reference external" href="https://doi.org/10.1103/PhysRevB.100.014303">paper</a> for details).
Therefore, a robust algorithm is required to find the translation vectors of a given
supercell matrix, as well as indexing the vectors with the supercell.</p>
<p>The details of the algorithm to find translation vectors of any given supercell is explained in the Appendix of the <a class="reference external" href="https://doi.org/10.1103/PhysRevB.100.014303">paper</a>.
The same algorithm can be reversed to compute the indices of the lattice points at <span class="math notranslate nohighlight">\(\mathcal{O}(1)\)</span> time complexity
without searching through the list of all translation vectors.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">non_diagonal_supa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lattice_ftg</span> <span class="o">=</span> <span class="n">LatticeFTG</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">non_diagonal_supa</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lattice_ftg</span><span class="o">.</span><span class="n">lattice_points</span>
<span class="go">array([[0, 0, 0],</span>
<span class="go">       [0, 0, 1],</span>
<span class="go">       [0, 1, 0],</span>
<span class="go">       [1, 0, 0]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lattice_ftg</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="n">lattice_ftg</span><span class="o">.</span><span class="n">lattice_points</span><span class="p">)</span>
<span class="go">array([0, 1, 2, 3])</span>
</pre></div>
</div>
</section>
<section id="algorithm-to-find-the-minimum-supercell-for-a-given-list-of-textbf-q-points">
<h2>Algorithm to find the minimum supercell for a given list of <span class="math notranslate nohighlight">\(\textbf{q}\)</span>-points<a class="headerlink" href="#algorithm-to-find-the-minimum-supercell-for-a-given-list-of-textbf-q-points" title="Permalink to this headline"></a></h2>
<p>The minimum supercell multiplicity is derived in the <a class="reference external" href="https://doi.org/10.1103/PhysRevB.100.014303">paper</a>.
Here using the implemented function, we find that for the <span class="math notranslate nohighlight">\(\textbf{q}\)</span>-point
<span class="math notranslate nohighlight">\(\textbf{q}=\left(\frac{1}{4}, \frac{3}{4}, 0\right)\)</span> the supercell of the minimum multiplicity is:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\hat{S}_{\textbf{q}} = \begin{bmatrix}
1 &amp; 1 &amp; 0 \\
0 &amp; 4 &amp; 0 \\
0 &amp; 0 &amp; 1
\end{bmatrix}\end{split}\]</div>
<p>, and for the <span class="math notranslate nohighlight">\(Q\)</span>-point <span class="math notranslate nohighlight">\(Q=\left[\left(\frac{1}{4}, \frac{3}{4}, 0\right),
\left(\frac{1}{4}, \frac{1}{2}, 0\right), \left(\frac{3}{4}, \frac{1}{4}, \frac{1}{2}\right)\right]\)</span>
the supercell of the minimum multiplicity is:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\hat{S}_{Q} = \begin{bmatrix}
4 &amp; 0 &amp; 0 \\
0 &amp; 4 &amp; 0 \\
0 &amp; 0 &amp; 2
\end{bmatrix}\end{split}\]</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Qpoint</span> <span class="o">=</span> <span class="n">parse_array</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="go">        1/4 3/4 0</span>
<span class="go">    &quot;&quot;&quot;, dtype=Fraction)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Qpoint</span>
<span class="go">[Fraction(1, 4), Fraction(3, 4), Fraction(0, 1)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">get_minimum_supercell</span><span class="p">(</span><span class="n">Qpoint</span><span class="p">)</span>
<span class="go">array([[1, 1, 0],</span>
<span class="go">       [0, 4, 0],</span>
<span class="go">       [0, 0, 1]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Qpoint</span> <span class="o">=</span> <span class="n">parse_array</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="go">        1/4 3/4 0</span>
<span class="go">        1/4 1/2 0</span>
<span class="go">        3/4 1/4 1/2</span>
<span class="go">    &quot;&quot;&quot;, dtype=Fraction)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Qpoint</span>
<span class="go">[[Fraction(1, 4), Fraction(3, 4), Fraction(0, 1)],</span>
<span class="go"> [Fraction(1, 4), Fraction(1, 2), Fraction(0, 1)],</span>
<span class="go"> [Fraction(3, 4), Fraction(1, 4), Fraction(1, 2)]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">get_minimum_supercell</span><span class="p">(</span><span class="n">Qpoint</span><span class="p">)</span>
<span class="go">array([[4, 0, 0],</span>
<span class="go">       [0, 4, 0],</span>
<span class="go">       [0, 0, 2]])</span>
</pre></div>
</div>
</section>
<section id="q-points-at-a-given-order-and-ftg">
<h2><span class="math notranslate nohighlight">\(Q\)</span>-points at a given order and FTG<a class="headerlink" href="#q-points-at-a-given-order-and-ftg" title="Permalink to this headline"></a></h2>
<p>Phonon interactions are associated with <span class="math notranslate nohighlight">\(Q\)</span>-points at the order of the interaction.
We implemented an efficient algorithm to find symmetrically irreducible Q-points in a given FTG and order,
that considers both the point symmetry and the permutation symmetry of the interaction.</p>
<p>Here we continue with the NaCl example.
The first step is to find the irreducible <span class="math notranslate nohighlight">\(\textbf{q}\)</span>-points.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">lattice_vectors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
<span class="go">        [0.0, 0.5, 0.5],</span>
<span class="go">        [0.5, 0.0, 0.5],</span>
<span class="go">        [0.5, 0.5, 0.0],</span>
<span class="go">    ])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">supa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">crystal</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pg</span> <span class="o">=</span> <span class="s2">&quot;Oh&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qpoints</span> <span class="o">=</span> <span class="n">Kpoints</span><span class="p">(</span><span class="n">vec</span><span class="o">=</span><span class="n">lattice_vectors</span><span class="p">,</span> <span class="n">supa</span><span class="o">=</span><span class="n">supa</span><span class="p">,</span> <span class="n">pg</span><span class="o">=</span><span class="n">pg</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qpoints</span><span class="o">.</span><span class="n">find_irreducible_lattice_points</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qpoints</span><span class="o">.</span><span class="n">irreducible_kpoints</span>
<span class="go">array([[Fraction(0, 1), Fraction(0, 1), Fraction(0, 1)],</span>
<span class="go">       [Fraction(1, 4), Fraction(0, 1), Fraction(0, 1)],</span>
<span class="go">       [Fraction(1, 2), Fraction(0, 1), Fraction(0, 1)],</span>
<span class="go">       [Fraction(1, 4), Fraction(1, 4), Fraction(0, 1)],</span>
<span class="go">       [Fraction(1, 2), Fraction(1, 4), Fraction(0, 1)],</span>
<span class="go">       [Fraction(3, 4), Fraction(1, 4), Fraction(0, 1)],</span>
<span class="go">       [Fraction(1, 2), Fraction(1, 2), Fraction(0, 1)],</span>
<span class="go">       [Fraction(3, 4), Fraction(1, 2), Fraction(1, 4)]], dtype=object)</span>
</pre></div>
</div>
<p>At the same time we can construct
the list of point group operations that transform a k-point in FTG to its irreducible counterpart,
and the indices of irreducible k-point each k-point can be rotated into.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">qpoints</span><span class="o">.</span><span class="n">irreducible_kpoints_trans</span>
<span class="go">array([&#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;I&#39;, &#39;Ic2b&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;Ic2b&#39;, &#39;Ic2b&#39;, &#39;E&#39;,</span>
<span class="go">       &#39;Ic2z&#39;, &#39;Ic2z&#39;, &#39;I&#39;, &#39;I&#39;, &#39;I&#39;, &#39;Ic2d&#39;, &#39;Ic2f&#39;, &#39;Ic2f&#39;, &#39;Ic2f&#39;,</span>
<span class="go">       &#39;Ic2d&#39;, &#39;Ic2x&#39;, &#39;Ic3ga&#39;, &#39;Ic3ga&#39;, &#39;Ici4y&#39;, &#39;Ic2e&#39;, &#39;Ic2x&#39;, &#39;E&#39;,</span>
<span class="go">       &#39;Ic3be&#39;, &#39;Ici3al&#39;, &#39;Ic2b&#39;, &#39;Ic4z&#39;, &#39;Ic2d&#39;, &#39;Ic4x&#39;, &#39;Ic2e&#39;,</span>
<span class="go">       &#39;Ici3de&#39;, &#39;Ic2d&#39;, &#39;Ic2y&#39;, &#39;Ici3be&#39;, &#39;Ic2f&#39;, &#39;Ic2c&#39;, &#39;Ic3al&#39;,</span>
<span class="go">       &#39;Ic2e&#39;, &#39;Ic4y&#39;, &#39;Ic3be&#39;, &#39;Ic2e&#39;, &#39;Ic2e&#39;, &#39;Ic2x&#39;, &#39;Ic2y&#39;, &#39;Ic4x&#39;,</span>
<span class="go">       &#39;Ici3ga&#39;, &#39;Ic2e&#39;, &#39;Ic2d&#39;, &#39;Ic2y&#39;, &#39;Ic2a&#39;, &#39;Ici4x&#39;, &#39;Ic3de&#39;, &#39;I&#39;,</span>
<span class="go">       &#39;Ici4z&#39;, &#39;Ici3be&#39;, &#39;Ic2c&#39;, &#39;Ic2c&#39;, &#39;Ic2c&#39;, &#39;Ic2e&#39;], dtype=&#39;&lt;U7&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qpoints</span><span class="o">.</span><span class="n">irreducible_kpoints_map</span>
<span class="go">array([0, 1, 2, 1, 1, 3, 4, 5, 2, 4, 6, 4, 1, 5, 4, 3, 1, 3, 4, 5, 3, 1,</span>
<span class="go">       5, 4, 4, 5, 4, 7, 5, 4, 7, 4, 2, 4, 6, 4, 4, 5, 4, 7, 6, 4, 2, 4,</span>
<span class="go">       4, 7, 4, 5, 1, 5, 4, 3, 5, 4, 7, 4, 4, 7, 4, 5, 3, 4, 5, 1])</span>
</pre></div>
</div>
<p>Next, we can use the above information to find irreducible <span class="math notranslate nohighlight">\(Q\)</span>-points.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">qpointsn</span> <span class="o">=</span> <span class="n">QpointsN</span><span class="p">(</span><span class="n">vec</span><span class="o">=</span><span class="n">lattice_vectors</span><span class="p">,</span> <span class="n">supa</span><span class="o">=</span><span class="n">supa</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">pg</span><span class="o">=</span><span class="n">pg</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qpointsn</span><span class="o">.</span><span class="n">find_irreducible_Qpoints</span><span class="p">()</span>
<span class="go">array([[[Fraction(0, 1), Fraction(0, 1), Fraction(0, 1)],</span>
<span class="go">        [Fraction(0, 1), Fraction(0, 1), Fraction(0, 1)],</span>
<span class="go">        [Fraction(0, 1), Fraction(0, 1), Fraction(0, 1)]],</span>
<span class="go">        ...,</span>
<span class="go">       [[Fraction(3, 4), Fraction(1, 4), Fraction(1, 2)],</span>
<span class="go">        [Fraction(3, 4), Fraction(1, 4), Fraction(1, 2)],</span>
<span class="go">        [Fraction(1, 2), Fraction(1, 2), Fraction(0, 1)]]], dtype=object)</span>
</pre></div>
</div>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="compute_thermal.html" class="btn btn-neutral float-left" title="Compute Phonon Linewidth and Thermal Conductivity" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="representation.html" class="btn btn-neutral float-right" title="Representation" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, Marianetti Group.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>
[{"body":"All command line script for PM are stored in the cli module, end with the suffix _cli, and are contained within a function main(). Here we document how to add a new command line tool to PM, which requires two steps. First, the script must be added to the setup.cfg file. Consider the example of the script periodica_cli.py, we would add one entry to the console_scripts as\nconsole_scripts = pm-lid = principia_materia.cli.lid_cli:main ... pm-periodica = principia_materia.cli.periodica_cli:main Additionally, we would add the executable pm-periodica to pm-completion.sh as\nfor i in pm-lid ... pm-periodica ","categories":"","description":"Overview of command line scripts in PM for developers.\n","excerpt":"Overview of command line scripts in PM for developers.\n","ref":"/docs/functionality/scripts/","tags":"","title":"Command line scripts"},{"body":"For many different tasks performed in the PM suite, a crystal structure, or some component of a crystal structure, must be provided to the code. Most likely, this will be done using a yaml input file, and the two required key words are vec and atoms, which will contain the lattice vectors and the basis atoms, respectively. Considering the flourite structure, the most straightforward yaml file would be:\n# xtal.yml vec: [[0.000000,2.764309,2.764309], [2.764309,0.000000,2.764309], [2.764309,2.764309,0.000000]] atoms: - Ca: [[0,0,0]] - F: [[0.25,0.25,0.25], [0.75,0.75,0.75]] The code will infer that there is one basis atom labeled Ca and two basis atoms labeled F.\nWhen entering matrices, we will always run the input through our general array parser (see parse_array if interested in the details). Therefore, there are many different options for entering a matrix as a string. For example, consider the following two examples:\nxtal.yml scale: 2.764309 vec: | 0 1 1 1 0 1 1 1 0 atoms: - Ca: | 0 0 0 - F: | 1/4 1/4 1/4 3/4 3/4 3/4 xtal.yml scale: 2.764309 vec: 0 1 1 ; 1 0 1 ; 1 1 0 atoms: - Ca: 0 0 0 - F: 1/4 1/4 1/4 ; 3/4 3/4 3/4 where scale is a constant that multiplies all lattice vectors (a list of three constants could have been provided), and the vertical lines tells yaml to expect a text block. Our parser has a hierarchy of delimiters, ranging from space, comma, semicolon, newline. In the above example, we have two types of delimiters (i.e. spaces and newlines), which tells the code to form a matrix.\nWarning Potential Errors in yaml input In the case of syntax error in YAML file, a RuntimeError will be thrown indicating the an error has occurred during the YAML loading process. For example, with the following text as YAML input:\nscale: 2.764309 vec: | 0 1 1 ; 1 0 1 ; 1 1 0 atoms: - Ca: | 0 0 0 - F: | 1/4 1/4 1/4 ; 3/4 3/4 3/4 The following error message will appear:\nRuntimeError: Following error occured processing input YAML string: ScannerError: while scanning a simple key in \"\u003cunicode string\u003e\", line 6, column 5 could not find expected ':' in \"\u003cunicode string\u003e\", line 7, column 3 Prototype Crystal Structures There are a number of very common crystal structures that are adopted in numerous compounds, such as rock salt, flourite, etc. There is a simple command line script to output these crystal structures.\n$ pm-prototype-xtal --perovskite # Crystal vec: [[ 3.91300000, 0.00000000, 0.00000000], [ 0.00000000, 3.91300000, 0.00000000], [ 0.00000000, 0.00000000, 3.91300000]] atoms: - Sr: [[ 0.50000000, 0.50000000, 0.50000000]] - Ti: [[ 0.00000000, 0.00000000, 0.00000000]] - O: [[ 0.50000000, 0.00000000, 0.00000000], [ 0.00000000, 0.50000000, 0.00000000], [ 0.00000000, 0.00000000, 0.50000000]] ","categories":["Examples"],"description":"Most computations require a crystal structure, and PM has a standard yaml file for doing so.\n","excerpt":"Most computations require a crystal structure, and PM has a standard …","ref":"/docs/functionality/xtal-structure/","tags":["test","sample","docs"],"title":"Crystal Structure"},{"body":"When performing calculations, we need to use various properties of both the infinite translation group (Lattice) and the finite translation group (LatticeFTG). The infinite translation group contains the lattice vectors, and computes various information from them (e.g. vector lengths and angles, volume, reciprocal lattice, etc). The FTG is naturally characterized by a supercell \\(\\hat{S}_{BZ}\\), and LatticeFTG derives from Lattice. Finding all translation points within a given supercell is a key task. Similarly, another key task is finding all the k-points commensurate with a given FTG, but this is currently execute in the separate kpoints class.\nAdditionally, we will need to find the smallest supercell that will accomodate a given set of \\(\\bm q\\)-points.\nLattice Here introduce the basic functionality of the Lattice class using the face center cubic as a demonstration:\n\u003e\u003e\u003e import numpy as np \u003e\u003e\u003e from principia_materia.translation_group import Lattice \u003e\u003e\u003e fcc_vec = 0.5*(np.ones((3,3))-np.identity(3)) \u003e\u003e\u003e lattice = Lattice(vec=fcc_vec) \u003e\u003e\u003e lattice.vec array([[0. , 0.5, 0.5], [0.5, 0. , 0.5], [0.5, 0.5, 0. ]]) With the above Lattice class object, we can compute various properties of the lattice.\n\u003e\u003e\u003e print(\"volume:\", lattice.vol) volume: 0.25 \u003e\u003e\u003e print(\"lengths of the lattice vectors:\", lattice.abc) lengths of the lattice vectors: [0.70710678 0.70710678 0.70710678] \u003e\u003e\u003e print(\"angles between the lattice vectors:\", lattice.abg) angles between the lattice vectors: [60. 60. 60.] There is a reciprocal lattice associated with the lattice, which is also constructed in this class, and we follow the convention \\(\\bm a_i\\cdot \\bm b_j =2\\pi \\delta_{ij} \\), where \\(\\bm a_i\\) is a real space vector and \\(\\bm b_j\\) is a reciprocal space vector.\n\u003e\u003e\u003e print(lattice.rvec) [[-6.28318531 6.28318531 6.28318531] [ 6.28318531 -6.28318531 6.28318531] [ 6.28318531 6.28318531 -6.28318531]] \u003e\u003e\u003e print(\"volume of reciprocal lattice:\", lattice.rvol) volume of reciprocal lattice: 992.200854 \u003e\u003e\u003e print(\"lengths of the reciprocal lattice vectors:\", lattice.rabc) lengths of the reciprocal lattice vectors: [10.88279619 10.88279619 10.88279619] \u003e\u003e\u003e print(\"angles between the reciprocal lattice vectors:\", lattice.rabg) angles between the reciprocal lattice vectors: [109.47122063 109.47122063 109.47122063] Additionally, the Lattice class allows us to perform various operation to a lattice, for example applying an axial strain:\n\u003e\u003e\u003e strain = [0.02, 0, 0] # axial strain along x \u003e\u003e\u003e example_lattice = lattice.copy() \u003e\u003e\u003e example_lattice.axial_strain(strain) \u003e\u003e\u003e print(example_lattice.vec) [[0. 0.5 0.5 ] [0.51 0. 0.5 ] [0.51 0.5 0. ]] LatticeFTG LatticeFTG is the class which handles finite translation groups, and the key method of the class finds all tranlsation points (i.e. t-points) contained within the supercell. While this result can be obtained from a simple Cartesian product in the case of a diagonal supercell, non-diagonal supercells are more subtle. Non-diagonal supercells are important in the context of lattice dynamic, because it is always preferrable to work with the smallest number of irreducible derivatives which yield a smooth interpolation, and non-diagonal supercells yield multiplicities which cannot be obtained solely using diagonal supercells. Therefore, it is important to have a robust algorithm to find all lattice points within an arbitrary supercell, and our algorithm is detailed in Appendix D in PRB 100 014303. The same algorithm can be reversed to compute the indices of the lattice points at \\(\\mathcal{O}(1)\\) time complexity, removing the need to create a hash function.\nBelow is a simple example which is easily recognizable: a fcc lattice with a supercell that yields the conventional cubic cell.\n\u003e\u003e\u003e import numpy as np \u003e\u003e\u003e from principia_materia.translation_group import LatticeFTG \u003e\u003e\u003e fcc_vec = 0.5*(np.ones((3,3))-np.identity(3)) \u003e\u003e\u003e S_bz = np.ones((3, 3)) - 2 * np.identity(3) \u003e\u003e\u003e lattice_ftg = LatticeFTG(fcc_vec,S_bz) \u003e\u003e\u003e lattice_ftg.vec array([[0. , 0.5, 0.5], [0.5, 0. , 0.5], [0.5, 0.5, 0. ]]) \u003e\u003e\u003e lattice_ftg.supa array([[-1, 1, 1], [ 1, -1, 1], [ 1, 1, -1]]) \u003e\u003e\u003e lattice_ftg.tpoints array([[0, 0, 0], [0, 0, 1], [0, 1, 0], [1, 0, 0]]) \u003e\u003e\u003e lattice_ftg.get_index(lattice_ftg.tpoints) array([0, 1, 2, 3]) \u003e\u003e\u003e lattice_ftg.supa_vec array([[1., 0., 0.], [0., 1., 0.], [0., 0., 1.]]) \u003e\u003e\u003e lattice_ftg.supa_tpoints array([[ 0 , 0 , 0 ], [1/2, 1/2, 0 ], [1/2, 0 , 1/2], [ 0 , 1/2, 1/2]], dtype=object) KpointsFTG We have a dedicated class for construcint k-points, though this is basically just a trivial wrapper around LatticeFTG.\n\u003e\u003e\u003e import numpy as np \u003e\u003e\u003e from principia_materia.translation_group import KpointsFTG \u003e\u003e\u003e fcc_vec = 0.5*(np.ones((3,3))-np.identity(3)) \u003e\u003e\u003e S_bz = np.ones((3, 3)) - 2 * np.identity(3) \u003e\u003e\u003e qpts = KpointsFTG(vec=fcc_vec, supa=S_bz) \u003e\u003e\u003e qpts.ppoints array([[0, 0, 0], [0, 0, 1], [0, 1, 0], [1, 0, 0]]) \u003e\u003e\u003e qpts.kpoints array([[ 0 , 0 , 0 ], [1/2, 1/2, 0 ], [1/2, 0 , 1/2], [ 0 , 1/2, 1/2]], dtype=object) \u003e\u003e\u003e qpts.ppoints_to_kpoints( ... np.array([[0, 0, 1], ... [1, 0, 0]]) ) array([[1/2, 1/2, 0 ], [ 0 , 1/2, 1/2]], dtype=object) \u003e\u003e\u003e qpts.kpoints_to_ppoints( ... np.array([[0.5, 0.5, 0 ], ... [0 , 0.5, 0.5]]) ) array([[0, 0, 1], [1, 0, 0]]) KpointsFSG Similar to KpointsFTG, the class KpointsFSG is basically a trivial wrapper around LatticeFSG, which handles the point symmetry of the lattice. Given that the most common use cases of point symmetry are in reciprocal space, only KpointsFSG is outlined here. KpointsFSG derives from KpointsFTG, so it shares all the same attributes outlined above.\n\u003e\u003e\u003e import numpy as np \u003e\u003e\u003e from principia_materia.translation_group import KpointsFSG \u003e\u003e\u003e fcc_vec = 0.5*(np.ones((3,3))-np.identity(3)) \u003e\u003e\u003e S_bz = 2*np.identity(3) \u003e\u003e\u003e qpts = KpointsFSG(vec=fcc_vec, supa=S_bz, pg='Oh') \u003e\u003e\u003e qpts.kpoints array([[ 0 , 0 , 0 ], [1/2, 0 , 0 ], [ 0 , 1/2, 0 ], [1/2, 1/2, 0 ], [ 0 , 0 , 1/2], [1/2, 0 , 1/2], [ 0 , 1/2, 1/2], [1/2, 1/2, 1/2]], dtype=object) \u003e\u003e\u003e qpts.irr_kpoints array([[ 0 , 0 , 0 ], [1/2, 0 , 0 ], [1/2, 1/2, 0 ]], dtype=object) \u003e\u003e\u003e qpts.irr_ppoints array([[0, 0, 0], [1, 0, 0], [1, 1, 0]]) \u003e\u003e\u003e qpts.N_irr 3 \u003e\u003e\u003e qpts.irr_indexes array([0, 1, 3]) \u003e\u003e\u003e qpts.indexes_map_irr_index array([0, 1, 1, 3, 1, 3, 3, 1]) \u003e\u003e\u003e qpts.indexes_map_irr_order array([0, 1, 1, 2, 1, 2, 2, 1]) \u003e\u003e\u003e qpts.stars [[0], [1, 2, 4, 7], [3, 5, 6]] \u003e\u003e\u003e qpts.little_groups ['Oh', 'D3d', 'D4h'] \u003e\u003e\u003e qpts.kpoint_type ['real', 'real', 'real'] \u003e\u003e\u003e # operations that yield 4th point from irr counterpart \u003e\u003e\u003e qpts.indexes_map_irr_ops[4] ['c3be', 'ci3de', 'c2y', 'c4x', 'c4z', 'c2d', 'Ic3be', 'Ici3de', 'Ic2y', 'Ic4x', 'Ic4z', 'Ic2d'] QpointsN Next, we can use the above information to find irreducible \\(Q\\)-points.\n\u003e\u003e\u003e qpointsn = QpointsN(vec=lattice_vectors, supa=supa, order=3, pg=pg) \u003e\u003e\u003e qpointsn.find_irreducible_Qpoints() array([[[Fraction(0, 1), Fraction(0, 1), Fraction(0, 1)], [Fraction(0, 1), Fraction(0, 1), Fraction(0, 1)], [Fraction(0, 1), Fraction(0, 1), Fraction(0, 1)]], ..., [[Fraction(3, 4), Fraction(1, 4), Fraction(1, 2)], [Fraction(3, 4), Fraction(1, 4), Fraction(1, 2)], [Fraction(1, 2), Fraction(1, 2), Fraction(0, 1)]]], dtype=object) get_minimum_supercell Algorithm to find the minimum supercell for a given list of \\(\\textbf{q}\\)-points\nThe minimum supercell multiplicity is derived in the paper. Here using the implemented function, we find that for the \\(\\textbf{q}\\)-point \\(\\textbf{q}=\\left(\\frac{1}{4}, \\frac{3}{4}, 0\\right)\\) the supercell of the minimum multiplicity is:\n$$ \\hat{S}_{\\textbf{q}} = \\begin{bmatrix} 1 \u0026 1 \u0026 0 \\\\ 0 \u0026 4 \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \\end{bmatrix} $$\n, and for the \\(Q\\)-point \\(Q=\\left[\\left(\\frac{1}{4}, \\frac{3}{4}, 0\\right), \\left(\\frac{1}{4}, \\frac{1}{2}, 0\\right), \\left(\\frac{3}{4}, \\frac{1}{4}, \\frac{1}{2}\\right)\\right]\\) the supercell of the minimum multiplicity is:\n$$ \\hat{S}_{Q} = \\begin{bmatrix} 4 \u0026 0 \u0026 0 \\\\ 0 \u0026 4 \u0026 0 \\\\ 0 \u0026 0 \u0026 2 \\end{bmatrix} $$\n\u003e\u003e\u003e import numpy as np \u003e\u003e\u003e from principia_materia.translation_group import get_minimum_supercell \u003e\u003e\u003e from principia_materia.io_interface import parse_array \u003e\u003e\u003e from principia_materia.mathematics import Fraction \u003e\u003e\u003e Qpoint = parse_array(\"\"\"\\ ... 1/4 3/4 0 ... \"\"\", dtype=Fraction) \u003e\u003e\u003e Qpoint array([1/4, 3/4, 0 ], dtype=object) \u003e\u003e\u003e get_minimum_supercell(Qpoint) array([[1, 1, 0], [0, 4, 0], [0, 0, 1]]) \u003e\u003e\u003e Qpoint = parse_array(\"\"\"\\ ... 1/4 3/4 0 ... 1/4 1/2 0 ... 3/4 1/4 1/2 ... \"\"\", dtype=Fraction) \u003e\u003e\u003e Qpoint array([[1/4, 3/4, 0 ], [1/4, 1/2, 0 ], [3/4, 1/4, 1/2]], dtype=object) \u003e\u003e\u003e get_minimum_supercell(Qpoint) array([[4, 0, 0], [0, 4, 0], [0, 0, 2]]) ","categories":"","description":"The lattice is a central component of a crystal, and PM has a class for the infinite translation group (Lattice)  and the finite translation group (LatticeFTG).\n","excerpt":"The lattice is a central component of a crystal, and PM has a class …","ref":"/docs/modules/translation-group/","tags":"","title":"Translation Group"},{"body":"","categories":"","description":"PM uses DataWrapper for enforcing the type of input data and the convention for output data.\n","excerpt":"PM uses DataWrapper for enforcing the type of input data and the …","ref":"/docs/data_management/data-wrapper/","tags":"","title":"Data Wrapper"},{"body":"principia_materia.cli package Submodules principia_materia.cli.bid_cli module\nBIDCLI\nBIDCLI.set_defaults()\nBIDCLI.set_object()\nprincipia_materia.cli.cli_helper module\ncheck_input()\nget_job_handlers()\nparse_args()\nset_dynamic_tensors_wrapper()\nset_errortail_wrapper()\nset_finite_displacements_wrapper()\nset_fourier_interpolation_wrapper()\nset_irreducible_derivatives_wrapper()\nset_job_interface_wrapper()\nset_lattice_dynamic_wrapper()\nset_structure_arguments()\nset_structure_wrapper()\nwrapper_to_argparse()\nprincipia_materia.cli.hsbid_cli module\nHSBIDCLI\nHSBIDCLI.set_defaults()\nHSBIDCLI.set_object()\nprincipia_materia.cli.jobs_cli module\nmain()\nsetup_parsers()\nprincipia_materia.cli.lid_cli module\nget_lid()\nmain()\nsetup_parsers()\nprincipia_materia.cli.lid_mesh_cli module\nLIDMeshCLI\nLIDMeshCLI.set_defaults()\nLIDMeshCLI.set_object()\nprincipia_materia.cli.phonon_band_dos_cli module\nmain()\nsetup_parsers()\nModule contents ","categories":"","description":"Module principia_materia.cli\n","excerpt":"Module principia_materia.cli\n","ref":"/docs/references/principia_materia.cli.html","tags":"","title":"Module principia_materia.cli"},{"body":"principia_materia.cli.bid_cli module class principia_materia.cli.bid_cli.BIDCLI() Bases: BaseIDCLI\nset_defaults() set_object() ","categories":"","description":"Module principia_materia.cli.bid_cli\n","excerpt":"Module principia_materia.cli.bid_cli\n","ref":"/docs/references/principia_materia.cli.bid_cli.html","tags":"","title":"Module principia_materia.cli.bid_cli"},{"body":"principia_materia.cli.cli_helper module principia_materia.cli.cli_helper.check_input(data, required=[]) principia_materia.cli.cli_helper.get_job_handlers(data, structure, pg=None, create_db=False) principia_materia.cli.cli_helper.parse_args(parser, wrapper, args=None, defaults={}) principia_materia.cli.cli_helper.set_dynamic_tensors_wrapper(wrapper, include_load=False, include_save=True) principia_materia.cli.cli_helper.set_errortail_wrapper(wrapper) principia_materia.cli.cli_helper.set_finite_displacements_wrapper(wrapper, include_supa=False) principia_materia.cli.cli_helper.set_fourier_interpolation_wrapper(wrapper, include_load=False, include_save=True) principia_materia.cli.cli_helper.set_irreducible_derivatives_wrapper(wrapper, include_load=False, include_save=True) principia_materia.cli.cli_helper.set_job_interface_wrapper(wrapper) principia_materia.cli.cli_helper.set_lattice_dynamic_wrapper(wrapper, include_Qpoint=False, include_order=True, include_extra=True) principia_materia.cli.cli_helper.set_structure_arguments(parser) principia_materia.cli.cli_helper.set_structure_wrapper(wrapper) principia_materia.cli.cli_helper.wrapper_to_argparse(wrapper, parser, exclude=[], defaults={}) ","categories":"","description":"Module principia_materia.cli.cli_helper\n","excerpt":"Module principia_materia.cli.cli_helper\n","ref":"/docs/references/principia_materia.cli.cli_helper.html","tags":"","title":"Module principia_materia.cli.cli_helper"},{"body":"principia_materia.cli.hsbid_cli module class principia_materia.cli.hsbid_cli.HSBIDCLI() Bases: BaseIDCLI\nset_defaults() set_object() ","categories":"","description":"Module principia_materia.cli.hsbid_cli\n","excerpt":"Module principia_materia.cli.hsbid_cli\n","ref":"/docs/references/principia_materia.cli.hsbid_cli.html","tags":"","title":"Module principia_materia.cli.hsbid_cli"},{"body":"principia_materia.cli.jobs_cli module principia_materia.cli.jobs_cli.main(args=None) principia_materia.cli.jobs_cli.setup_parsers() ","categories":"","description":"Module principia_materia.cli.jobs_cli\n","excerpt":"Module principia_materia.cli.jobs_cli\n","ref":"/docs/references/principia_materia.cli.jobs_cli.html","tags":"","title":"Module principia_materia.cli.jobs_cli"},{"body":"principia_materia.cli.lid_cli module principia_materia.cli.lid_cli.get_lid(data, tol=1e-06) principia_materia.cli.lid_cli.main(args=None) principia_materia.cli.lid_cli.setup_parsers() ","categories":"","description":"Module principia_materia.cli.lid_cli\n","excerpt":"Module principia_materia.cli.lid_cli\n","ref":"/docs/references/principia_materia.cli.lid_cli.html","tags":"","title":"Module principia_materia.cli.lid_cli"},{"body":"principia_materia.cli.lid_mesh_cli module class principia_materia.cli.lid_mesh_cli.LIDMeshCLI() Bases: BaseIDCLI\nset_defaults() set_object() ","categories":"","description":"Module principia_materia.cli.lid_mesh_cli\n","excerpt":"Module principia_materia.cli.lid_mesh_cli\n","ref":"/docs/references/principia_materia.cli.lid_mesh_cli.html","tags":"","title":"Module principia_materia.cli.lid_mesh_cli"},{"body":"principia_materia.cli.phonon_band_dos_cli module principia_materia.cli.phonon_band_dos_cli.main(args=None) principia_materia.cli.phonon_band_dos_cli.setup_parsers() ","categories":"","description":"Module principia_materia.cli.phonon_band_dos_cli\n","excerpt":"Module principia_materia.cli.phonon_band_dos_cli\n","ref":"/docs/references/principia_materia.cli.phonon_band_dos_cli.html","tags":"","title":"Module principia_materia.cli.phonon_band_dos_cli"},{"body":"principia_materia.constants package Submodules principia_materia.constants.periodic_table module\nprincipia_materia.constants.physical_constant module\nPhysicalConstant\nPhysicalConstant.data_parse()\nPhysicalConstant.existing_units\nprincipia_materia.constants.point_group_notation_table module\nprincipia_materia.constants.unit_conversion module\nUnitConversion\nUnitConversion.data_parse()\nUnitConversion.find_path()\nModule contents ","categories":"","description":"Module principia_materia.constants\n","excerpt":"Module principia_materia.constants\n","ref":"/docs/references/principia_materia.constants.html","tags":"","title":"Module principia_materia.constants"},{"body":"principia_materia.constants.periodic_table module ","categories":"","description":"Module principia_materia.constants.periodic_table\n","excerpt":"Module principia_materia.constants.periodic_table\n","ref":"/docs/references/principia_materia.constants.periodic_table.html","tags":"","title":"Module principia_materia.constants.periodic_table"},{"body":"principia_materia.constants.physical_constant module class principia_materia.constants.physical_constant.PhysicalConstant(data, name=None, default_unit=None) Bases: object\nA physical constant in a given units\nThis class will construct a given physical constant in different units. with provided data at construction.\nParameters\ndata (str) – Table of constant values data. (See below for format eamples.)\nname (str, optional, default to None) – Name of the constant.\ndefault_unit (str, optional, default to None) – The default unit for the constant. If None, default to the first in the provided data.\nstatic data_parse(data) property existing_units() ","categories":"","description":"Module principia_materia.constants.physical_constant\n","excerpt":"Module principia_materia.constants.physical_constant\n","ref":"/docs/references/principia_materia.constants.physical_constant.html","tags":"","title":"Module principia_materia.constants.physical_constant"},{"body":"principia_materia.constants.point_group_notation_table module ","categories":"","description":"Module principia_materia.constants.point_group_notation_table\n","excerpt":"Module principia_materia.constants.point_group_notation_table\n","ref":"/docs/references/principia_materia.constants.point_group_notation_table.html","tags":"","title":"Module principia_materia.constants.point_group_notation_table"},{"body":"principia_materia.constants.unit_conversion module class principia_materia.constants.unit_conversion.UnitConversion(data) Bases: object\nFind unit conversion coefficients\nThis class construct a graph of different units and find a path within the graph the calculate unit conversion coefficients.\nParameters\ndata (str) – Table of unit conversion data. (See below for format eamples.)\nstatic data_parse(data) classmethod find_path(graph, start, end, path=[]) ","categories":"","description":"Module principia_materia.constants.unit_conversion\n","excerpt":"Module principia_materia.constants.unit_conversion\n","ref":"/docs/references/principia_materia.constants.unit_conversion.html","tags":"","title":"Module principia_materia.constants.unit_conversion"},{"body":"principia_materia.hamiltonian package Submodules principia_materia.hamiltonian.electron_hamiltonian module\nElectronHamiltonian\nElectronHamiltonian.diagonalize_hamiltonians()\nElectronHamiltonian.get_embeded_self_energy()\nElectronHamiltonian.get_fermi_energy()\nElectronHamiltonian.get_hamiltonian_matrices_at_kpoints()\nElectronHamiltonian.get_state()\nElectronHamiltonian.get_total_energy()\nElectronHamiltonian.hartree_fock()\nElectronHamiltonian.set_density_matrix()\nElectronHamiltonian.set_fermi_energy()\nElectronHamiltonian.set_hamiltonian()\nElectronHamiltonian._hamiltonian\nElectronHamiltonian.set_nd()\nElectronHamiltonian.set_self_energy()\nElectronHamiltonian.set_total_energy()\nprincipia_materia.hamiltonian.hamiltonian module\nHamiltonian\nHamiltonian.compute_DOS()\nHamiltonian._dos\nHamiltonian._cdos\nHamiltonian.compute_PDOS()\nHamiltonian._pdos\nHamiltonian._cpdos\nHamiltonian.decimal\nHamiltonian.diagonalize_hamiltonians()\nHamiltonian.get_hamiltonian_matrices_at_kpoints()\nHamiltonian.is_kpoints_from_mesh\nHamiltonian.nspin\nHamiltonian.set_charmblochrep()\nHamiltonian.set_eigenvalues()\nHamiltonian.set_hamiltonian()\nHamiltonian.set_hamiltonian_at_kpoints()\nHamiltonian.set_hamiltonian_from_mesh()\nHamiltonian.set_tetrahedra()\nHamiltonian.spin\nHamiltonian.units\nprincipia_materia.hamiltonian.model_hamiltonian module\nModelHamiltonian\nModelHamiltonian.from_dict()\nModelHamiltonian.get_hamiltonian_at_kpoint()\nModelHamiltonian.hamiltonian_matrices\nModelHamiltonian.nortbials\nModelHamiltonian.set_hamiltonian()\nModelHamiltonian.tpoints\nformat_hamiltonian_to_yaml()\nget_ModelHamiltonian_hdf5_wrapper()\nget_ModelHamiltonian_yaml_wrapper()\nget_modelhamiltonian_from_hdf5()\nget_modelhamiltonian_from_yaml()\nload_hamiltonian()\nsave_modelhamiltonian_to_hdf5()\nsave_modelhamiltonian_to_yaml()\nprincipia_materia.hamiltonian.phonon_hamiltonian module\nPhononHamiltonian\nPhononHamiltonian.diagonalize_hamiltonians()\nPhononHamiltonian.get_hamiltonian_matrices_at_kpoints()\nPhononHamiltonian.set_hamiltonian()\nPhononHamiltonian._hamiltonian\nModule contents ","categories":"","description":"Module principia_materia.hamiltonian\n","excerpt":"Module principia_materia.hamiltonian\n","ref":"/docs/references/principia_materia.hamiltonian.html","tags":"","title":"Module principia_materia.hamiltonian"},{"body":"principia_materia.hamiltonian.electron_hamiltonian module class principia_materia.hamiltonian.electron_hamiltonian.ElectronHamiltonian(structure, mesh=None, pg=‘C1’, nspin=1, nelect=None, fermi=None, ncor=0, U=0, units=‘eV’, verbosity=1, tol=1e-06) Bases: Hamiltonian\nParameters\nnelect (int, optional, default to None) – Number of valence electrons.\nfermi (float, optional, default to None) – Fermy energy, in unit of eV.\nncor (int, optional, default to None) – Number of correlated orbitals.\nU (int, optional, default to 0) – The Coulumb hamiltonian term U.\ndiagonalize_hamiltonians(hamiltonians_matrices, UPLO=‘L’) Diagonalize and compute the eigenvalues hamiltonians in reciprocal space.\nReturns\neigenvalues (array of float, shape(N, nspin, norbitals))\neigenvectors (array of float, shape(N, nspin, norbitals, norbitals))\nget_embeded_self_energy() Embed the self-energy minus the dc in a matrix the size of the Hamiltonian.\nget_fermi_energy() Get Fermi energy.\nReturns\nfermi – The Fermi energy.\nReturn type\nfloat\nget_hamiltonian_matrices_at_kpoints(kpoints) Get hamiltonian matrices at k-points\nParameters\nkpoints (array of float or Fraction, shape(dim, ) or shape(N, dim)) – k-points.\nReturns\nhamiltonians_matrices – Interaction matrices.\nReturn type\narray of complex, shape(norbitals, norbitals) or shape(N, norbitals, norbitals)\nget_state() Get insulator/metal state of the Hamiltonian.\nget_total_energy() Get the total energy of the Hamiltonian.\nhartree_fock(nd=0, nscf=40, tol=1e-05, mix=0.7, perturb=True, dc=False) Hartree Fock.\nset_density_matrix() Compute the density matrix of the Hamiltonian.\nset_fermi_energy(replace=False, maxiter=200, raise_exception=False) Compute Fermi energy with binary search and tetrahedron method.\nParameters\nreplace (bool, optional, default to False) – Re-compute Fermi energy when attribute _fermi is not None.\nmaxiter (int, optional, default to 200) – The maximum number of iterations to search for the Fermi energy.\nraise_exception (bool, optional, default to False) – Whether to raise an exception when the maximum iteration is reached before the error tolerence is reached.\nset_hamiltonian(hamiltonian) Set electron hamiltonian.\nParameters\nhamiltonian (ModelHamiltonian) – ModelHamiltonian object.\n_hamiltonian() ModelHamiltonian object.\nType\nModelHamiltonian\nset_nd(nd, max_loop=200, tol=0.0001) Adjust number d-electrons.\nAdjust the double-counting to get the desired number of d-electrons while maintaining the proper density. This algo creates a a scalar function which computes nd for a given dc while always adjusting the fermi energy to give the correct density. This function is then manually bounded and then sent to brentq in order to find the root.\nset_self_energy(self_energy, fermi=None, dc=None) set_total_energy() Compute the total energy of the Hamiltonian with tetrahedron method.\n","categories":"","description":"Module principia_materia.hamiltonian.electron_hamiltonian\n","excerpt":"Module principia_materia.hamiltonian.electron_hamiltonian\n","ref":"/docs/references/principia_materia.hamiltonian.electron_hamiltonian.html","tags":"","title":"Module principia_materia.hamiltonian.electron_hamiltonian"},{"body":"principia_materia.hamiltonian.hamiltonian module class principia_materia.hamiltonian.hamiltonian.Hamiltonian(structure, mesh=None, pg=‘C1’, nspin=1, units=‘eV’, verbosity=1, tol=1e-06) Bases: object\nThe Hamiltonian of a system.\ncompute_DOS(nbins, return_cdos=False) Compute density of states for energies between the minimum and maximum values of eigenvalues.\nParameters\nnbins (int) – The number of energies to evaluate between the minimum and maximum eigenvalues.\n_dos() Density of states.\nType\narray of float, shape(nbins, nspins)\n_cdos() Cumulative density of states.\nType\narray of float, shape(nbins, nspins)\ncompute_PDOS(nbins, return_cpdos=False) Compute partial density of states for energies between the minimum and maximum values of eigenvalues.\nParameters\nnbins (int) – The number of energies to evaluate between the minimum and maximum eigenvalues.\n_pdos() Partial density of states.\nType\narray of float, shape(nbins, nspins, norbitals)\n_cpdos() Cumulative partial density of states.\nType\narray of float, shape(nbins, nspins, norbitals)\nproperty decimal() abstract diagonalize_hamiltonians(hamiltonians_matrices) Diagonalize hamiltonians in reciprocal space.\nIn terms of electrons, it’s computing the eigenvalues of the hamiltonians. In terms of phonons, it’s compute the phonon frequencies of dynamic matrices.\nReturns\neigenvalues (array of float, shape(N, nspin, norbitals))\neigenvectors (array of float, shape(N, nspin, norbitals, norbitals))\nabstract get_hamiltonian_matrices_at_kpoints(kpoints) Get hamiltonian matrices at k-points\nParameters\nkpoints (array of float or Fraction, shape(dim, ) or shape(N, dim)) – k-points.\nReturns\nhamiltonians_matrices – Interaction matrices.\nReturn type\narray of complex, shape(norbitals, norbitals) or shape(N, norbitals, norbitals)\nproperty is_kpoints_from_mesh() Check if the k-points attribute matches the k-point mesh generated from self.mesh.\nReturns\nmatch – Whether the k-points attribute matches the k-point mesh.\nReturn type\nbool\nproperty nspin() set_charmblochrep() set_eigenvalues() abstract set_hamiltonian(hamiltonian) set_hamiltonian_at_kpoints(kpoints) set_hamiltonian_from_mesh() set_tetrahedra() property spin() property units() ","categories":"","description":"Module principia_materia.hamiltonian.hamiltonian\n","excerpt":"Module principia_materia.hamiltonian.hamiltonian\n","ref":"/docs/references/principia_materia.hamiltonian.hamiltonian.html","tags":"","title":"Module principia_materia.hamiltonian.hamiltonian"},{"body":"principia_materia.hamiltonian.model_hamiltonian module class principia_materia.hamiltonian.model_hamiltonian.ModelHamiltonian(dim=3, ftmode=0) Bases: object\nclassmethod from_dict(data, ftmode=0) get_hamiltonian_at_kpoint(kpoints) property hamiltonian_matrices() property nortbials() set_hamiltonian(tpoints, hamiltonian_matrices) property tpoints() principia_materia.hamiltonian.model_hamiltonian.format_hamiltonian_to_yaml(obj) principia_materia.hamiltonian.model_hamiltonian.get_ModelHamiltonian_hdf5_wrapper() principia_materia.hamiltonian.model_hamiltonian.get_ModelHamiltonian_yaml_wrapper() principia_materia.hamiltonian.model_hamiltonian.get_modelhamiltonian_from_hdf5(h5file) principia_materia.hamiltonian.model_hamiltonian.get_modelhamiltonian_from_yaml(filename) principia_materia.hamiltonian.model_hamiltonian.load_hamiltonian(data) principia_materia.hamiltonian.model_hamiltonian.save_modelhamiltonian_to_hdf5(obj, h5file=‘model_hamiltonian.hdf5’, overwrite=False) principia_materia.hamiltonian.model_hamiltonian.save_modelhamiltonian_to_yaml(obj, filename=‘model_hamiltonian.hdf5’, overwrite=False) ","categories":"","description":"Module principia_materia.hamiltonian.model_hamiltonian\n","excerpt":"Module principia_materia.hamiltonian.model_hamiltonian\n","ref":"/docs/references/principia_materia.hamiltonian.model_hamiltonian.html","tags":"","title":"Module principia_materia.hamiltonian.model_hamiltonian"},{"body":"principia_materia.hamiltonian.phonon_hamiltonian module class principia_materia.hamiltonian.phonon_hamiltonian.PhononHamiltonian(structure, mesh=None, pg=‘C1’, units=‘THz’, verbosity=1, tol=1e-06) Bases: Hamiltonian\ndiagonalize_hamiltonians(hamiltonians_matrices, UPLO=‘L’) Diagonalize and compute the phonon frequencies of dynamic matrices in reciprocal space.\nReturns\neigenvalues (array of float, shape(N, nspin, norbitals))\neigenvectors (array of float, shape(N, nspin, norbitals, norbitals))\nget_hamiltonian_matrices_at_kpoints(kpoints) Get hamiltonian matrices at k-points\nParameters\nkpoints (array of float or Fraction, shape(dim, ) or shape(N, dim)) – k-points.\nReturns\nhamiltonians_matrices – Interaction matrices.\nReturn type\narray of complex, shape(norbitals, norbitals) or shape(N, norbitals, norbitals)\nset_hamiltonian(hamiltonian) Set phonon hamiltonian.\nParameters\nhamiltonian (FourierInterpolation or ModelHamiltonian or str) – FourierInterpolation or ModelHamiltonian object or path to FourierInterpolation HDF5 data file.\n_hamiltonian() FourierInterpolation or ModelHamiltonian object.\nType\nFourierInterpolation or ModelHamiltonian\n","categories":"","description":"Module principia_materia.hamiltonian.phonon_hamiltonian\n","excerpt":"Module principia_materia.hamiltonian.phonon_hamiltonian\n","ref":"/docs/references/principia_materia.hamiltonian.phonon_hamiltonian.html","tags":"","title":"Module principia_materia.hamiltonian.phonon_hamiltonian"},{"body":"principia_materia.io_interface package Submodules principia_materia.io_interface.array_io module\nArrayFormatter\nArrayFormatter.firstline_line_begin()\nArrayFormatter.format_array()\nArrayFormatter.lastline_line_end()\nformat_array()\npad_array()\nparse_array()\nparse_expression()\nparse_number()\ntex_array_formatter()\nprincipia_materia.io_interface.base_data_wrapper module\nBaseDataWrapper\nBaseDataWrapper.add_item()\nBaseDataWrapper.copy()\nBaseDataWrapper.delete_item()\nBaseDataWrapper.dump()\nBaseDataWrapper.dumps()\nBaseDataWrapper.get_alias_map()\nBaseDataWrapper.get_all_names_aliases()\nBaseDataWrapper.load()\nBaseDataWrapper.loads()\nBaseDataWrapper.register_dtype()\nBaseDataWrapper.self_check()\nBaseDataWrapper.verify_data()\nprincipia_materia.io_interface.compute_job module\nComputeJob\nComputeJob.copy_files()\nComputeJob.create_job()\nComputeJob.get_born_effective_charges()\nComputeJob.get_cutoff()\nComputeJob.get_dielectric_tensor()\nComputeJob.get_energy()\nComputeJob.get_forces()\nComputeJob.get_kmesh()\nComputeJob.get_magnetic_moments()\nComputeJob.get_natoms()\nComputeJob.get_relaxation_displacement()\nComputeJob.get_stress()\nComputeJob.initialize_configuration()\nComputeJob.is_job_finished\nComputeJob.path\nComputeJob.rescale_kmesh()\nComputeJob.set_kmesh()\nComputeJob.set_output()\nComputeJob.structure\nprincipia_materia.io_interface.compute_job_series module\nComputeJobSeries\nComputeJobSeries.config_path\nComputeJobSeries.create_directory()\nComputeJobSeries.create_job()\nComputeJobSeries.create_jobs()\nComputeJobSeries.get_born_effective_charges_from_job()\nComputeJobSeries.get_compute_job()\nComputeJobSeries.get_dielectric_tensor_from_job()\nComputeJobSeries.get_energy_from_job()\nComputeJobSeries.get_forces_from_job()\nComputeJobSeries.get_metadata_path()\nComputeJobSeries.get_results_from_jobs()\nComputeJobSeries.get_stress_from_job()\nComputeJobSeries.save_metadata()\nComputeJobSeries.series_exists\nComputeJobSeries.set_static_files()\nComputeJobSeries.structure\nprincipia_materia.io_interface.data_wrapper module\nDataWrapper\nDataWrapper.dump()\nDataWrapper.dumps()\nDataWrapper.load()\nDataWrapper.load_dict()\nDataWrapper.load_generic()\nDataWrapper.loads()\nprincipia_materia.io_interface.hdf5_wrapper module\nHDF5Wrapper\nHDF5Wrapper.add_item()\nHDF5Wrapper.dump()\nHDF5Wrapper.dump_h5file()\nHDF5Wrapper.dumps()\nHDF5Wrapper.load()\nHDF5Wrapper.load_h5file()\nHDF5Wrapper.loads()\nprincipia_materia.io_interface.jobs_db module\nJobsDB\nJobsDB.add_filter()\nJobsDB.create_job()\nJobsDB.create_jobs()\nJobsDB.get_born_effective_charges_from_job()\nJobsDB.get_dielectric_tensor_from_job()\nJobsDB.get_energy_from_job()\nJobsDB.get_forces_from_job()\nJobsDB.get_metadata_path()\nJobsDB.get_results_from_jobs()\nJobsDB.get_stress_from_job()\nJobsDB.remove_filter()\nJobsDB.reset_filters()\nJobsDB.save_metadata()\nJobsDB.save_table_info()\nJobsDB.set_table()\nJobsDB.structure\nprincipia_materia.io_interface.qpoints_io module\narray_to_list()\narray_to_tuple()\nprincipia_materia.io_interface.vasp module\nparse_poscar()\nwrite_poscar()\nprincipia_materia.io_interface.yaml_dump module\nyaml_dumps() Module contents principia_materia.io_interface.format_tensor(tensor, prec=8, cell_length=None, flat=False, yaml_style=False, indices=True, index_width=5) Format a tensor into string\nFormat float arrays from 1 or more dimensions into string, with several settings to control the format.\nParameters\ntensor (array of floats) – The tensor to format.\nprec (int, optional, default to 8) – The decimal points to round the floating point numbers to.\ncell_length (int, optional, default to None) – The width to align numbers in.\nflat (bool, optional, default to False) – If True, print out every single tensor entry along side its index. If True, flat yaml_style, and indices are ignored. If False, if input tensor is a vector or matrix, print them out directly, if input tensor has rank greater than 2, loop over all the axes except the last 2, and print the last 2 axes out as a matrix.\nyaml_style (bool, optional, default to False) – If True, print out tensor in YAML nested list format.\nindices (bool, optional, default to True) – If True, print out the indices of the matrix when rank of tensor is greater than 2.\nindex_width (int, optional, default to 5) – The width to align indices numbers in.\nprincipia_materia.io_interface.get_compute_engine_map() Load First-Principle Interfaces.\nReturns\ncompute_engine_map – A dictionary containing the available first-principle interfaces in the form of subclasses of ComputeJob.\nReturn type\ndict\nprincipia_materia.io_interface.indent(text, prefix=’ ‘, initial_indent=None) Indent text\nCreate indentation for text, the function can also treat first line with special indentation.\nParameters\ntext (str) – Text to indent\nprefix (str or int, optional, default to \" “) – The indentation, if type is str, prepend the prefix to each line, if type is int, prepend the amount of spaces to each line.\ninitial_indent (str, optional, default to None) – If not None, prepend the input string to the first line of text.\nprincipia_materia.io_interface.jobs_series_to_jobs_db(jobs_db, jobs_series, search_conditions=[], update=True) Read Jobs in from ComputeJobSeries and store them into database with JobsDB.\nParameters\njobs_db (JobsDB) – The interface of the database for storing the jobs.\njobs_series (ComputeJobSeries) – The interface to the job series for reading the jobs.\nsearch_conditions (list, optional) – Additional search conditions for filtering the jobs.\nupdate (bool, optional) – If True, only read and store the jobs that haven’t been read in before. If False, overwrite the data already in the database.\nprincipia_materia.io_interface.tuple_to_str(tup, prec=8, strip=True) Format tuple into string.\nRecursively format tuples into string.\nParameters\ntup (tuple) – Input tuple.\nprec (int, optional, default to 8) – The decimal points to round the floating point numbers to.\nstrip (bool, optional, default to True) – Whether to strip whitespaces from formatted numbers.\n","categories":"","description":"Module principia_materia.io_interface\n","excerpt":"Module principia_materia.io_interface\n","ref":"/docs/references/principia_materia.io_interface.html","tags":"","title":"Module principia_materia.io_interface"},{"body":"principia_materia.io_interface.array_io module class principia_materia.io_interface.array_io.ArrayFormatter(prec=8, fmt=None, align=‘l’, cell_length=1, delimiter=’ ‘, pad=0, newline=’\\n’, header=’’, footer=’’, line_begin=’’, line_end=’’, indent=0) Bases: object\nFormat 2D array.\nObject oriented class for formatting arrays. The mechanism is to setup the desired style of the formatter, with which one can format arrays, just like any formatter function. Some default styles will be provided below, for convenience.\nThis class implements all the basic features of a formatter, so that any new styles can be achieved with minimum work by simply providing style specifications.\nParameters\nprec (int, optional, default to 8) – Decimal points to keep for floating points. Can be directly set in fmt.\nfmt (str, optional, default to None) – The string format for each array element. Default dynamically using prec, align, cell_length and the cell data type to determine the decimal points. Once the format is set to not None, it will be used for the cell format, align and cell_length will be ignored.\nalign (str, optional, default to “l”, choices(“l”, “r”, “c”)) – The alignment of the cell, can choose between left, right and centered.\ncell_length (int, optional, default to 0) – The length of the cell, this is used to align the cell, if the provided cell_length is too short, it will be ignored.\ndelimiter (str, optional, default to \" “) – The separator of each array element in the same row.\npad (int or str, optional, default to 0) – (Takes in int for number of spaces, or str for more customized padding) The amount of space between element, this will pad between array elements and line_begin/line_end, as well as after delimiter and the next array element. If padding in either place is needed, add the padding to delimeter or line_begin/line_end.\nnewline (str, optional, default to “\\n”) – The separator between each row.\nheader (str, optional, default empty) – String that will appear immediately in front of the array.\nfooter (str, optional, default empty) – String that will appear immediately after the array.\nline_begin (str, optional, default empty) – String that will appear immediately in front of each row of the array.\nline_end (str, optional, default empty) – String that will appear immediately after each row of the array.\nindent (int or str, optional, default to 0) – (Takes in int for number of spaces, or str for more customized indent) Overall indent of the array, does not affect header and footer. For indent on the entire string, use textwrap.indent.\nExamples \u003e\u003e\u003e format_array_nparray = ArrayFormatter( ... prec=8, ... delimiter=\", \", ... line_begin=ArrayFormatter.firstline_line_begin(line_begin=\" [\", first_line_begin=\"array([[\"), ... line_end=ArrayFormatter.lastline_line_end(line_end=\"],\", last_line_end=\"]])\"), ... ) \u003e\u003e\u003e print(format_array_nparray(np.identity(3))) array([[ 1.00000000, 0.00000000, 0.00000000], [ 0.00000000, 1.00000000, 0.00000000], [ 0.00000000, 0.00000000, 1.00000000]]) \u003e\u003e\u003e formatter = tex_array_formatter(texenv=\"bmatrix\") \u003e\u003e\u003e print(formatter(np.identity(3))) \\begin{bmatrix} 1.00000000 \u0026\u0026 0.00000000 \u0026\u0026 0.00000000 \\\\ 0.00000000 \u0026\u0026 1.00000000 \u0026\u0026 0.00000000 \\\\ 0.00000000 \u0026\u0026 0.00000000 \u0026\u0026 1.00000000 \\\\ \\end{bmatrix} static firstline_line_begin(line_begin, first_line_begin) format_array(arr, prec=None, cell_length=None, extent_dimention=False) static lastline_line_end(line_end, last_line_end) principia_materia.io_interface.array_io.format_array(data, prec=8, fmt=None, align=‘l’, cell_length=0, delimiter=’ ‘, pad=0, newline=’\\n’, header=’’, footer=’’, line_begin=’’, line_end=’’, indent=0, extent_dimention=False) A wrapper funtion for ArrayFormatter\nThe same feature but in a function call instead. This is suitable for one time use case.\nprincipia_materia.io_interface.array_io.pad_array(arr, shape, dtype=\u003cclass ‘float’\u003e, fillvalue=0, allow_truncate=False) Pad array to a given shape with given fillvalue.\nParameters\narr (nested list of Number.) – Array to be padded.\ndtype (any Number type, optional, default to float) – Type for the array element to be converted into.\nshape (tuple of integers, optional, default to None) – The shape of array to be padded into.\nfillvalue (any Number type, optional, default to 0) – Fill values for padding.\nallow_truncate (bool, optional, default to False) – Whether allow truncation of array when padding into given shape, if allowed, any array element outside the padding target shape will be discarded.\nReturns\narray – The padded array.\nReturn type\nnumpy.ndarray of dtype\nprincipia_materia.io_interface.array_io.parse_array(arr, dtype=\u003cclass ‘float’\u003e, max_denominator=None, pad_to_shape=None, fillvalue=0, allow_truncate=False, to_list=False) Parse array from a compatible format and pad to dimension with given fill value.\nParameters\narr (parser compatible format (described below)) – Array to be parsed.\ndtype (any Number type, optional, default to float) – Type for the array element to be converted into.\nmax_denominator (integer, optional, default to None) – If dtype is Fraction, the maximum denominator.\npad_to_shape (tuple of integers, optional, default to None) – The shape of array to be padded into.\nfillvalue (any Number type, optional, default to 0) – Fill values for padding.\nallow_truncate (bool, optional, default to False) – Whether allow truncation of array when padding into given shape, if allowed, any array element outside the padding target shape will be discarded.\nReturns\narray (nested list of dtype or numpy.ndarray of dtype) – (if pad_to_shape is not None) returns numpy.ndarray of dtype as the parsed and padded array.\n(if pad_to_shape is None)\nreturns nested list of of dtype as the parsed array.\nParser Compatible Format\n————————\nThis format can be a numpy array of Number (integer, float, Fraction, any format\nthat shares the abstract base class of Number), nested list of Number or a string\nwith numbers (string format of Number or Fraction) that are separated by any one\nor more of space, comma, semicolon or newline.\nExamples \u003e\u003e\u003e parse_array('0 0; 1 2', dtype=Fraction, max_denominator=100, pad_to_shape=(2, 3)) array([[Fraction(0, 1), Fraction(0, 1), Fraction(0, 1)], [Fraction(1, 1), Fraction(2, 1), Fraction(0, 1)]], dtype=object) principia_materia.io_interface.array_io.parse_expression(expression, dtype=\u003cclass ‘float’\u003e, max_denominator=None) Parse an arithmetic expression in string and calculation the resulting number.\nBasic arithmetic operations of +, -,\n* , / can be parsed and calculated in the correct order of precedence.\nParameters\nexpression (str) – Expression to be parsed.\ndtype (any Number type, optional, default to float) – Type for the number to be converted into.\nmax_denominator (integer, optional, default to None) – If dtype is Fraction, the maximum denominator.\nReturns\nnum – Parsed number in type of dtype.\nReturn type\ndtype\nExamples \u003e\u003e\u003e parse_number_from_string('-r4.0e+4/100', dtype=Fraction, max_denominator=100) Fraction(-2, 1) \u003e\u003e\u003e parse_expression('-2.1*r2E-5/r3E-4', dtype=float), -2.1*np.sqrt(2E-5)/np.sqrt(3E-4) (-0.5422176684690384, -0.5422176684690384) principia_materia.io_interface.array_io.parse_number(num, dtype=\u003cclass ‘float’\u003e, max_denominator=None) Parse number from compatible format.\nParameters\nnum (any type/format compatible with Number or Fraction) – Number to be parsed.\ndtype (any Number type, optional, default to float) – Type for the number to be converted into.\nmax_denominator (integer, optional, default to None) – If dtype is Fraction, the maximum denominator.\nReturns\nnum – Parsed number in type of dtype.\nReturn type\ndtype\nprincipia_materia.io_interface.array_io.tex_array_formatter(texenv=‘bmatrix’) Format array into a TeX matrix.\n","categories":"","description":"Module principia_materia.io_interface.array_io\n","excerpt":"Module principia_materia.io_interface.array_io\n","ref":"/docs/references/principia_materia.io_interface.array_io.html","tags":"","title":"Module principia_materia.io_interface.array_io"},{"body":"principia_materia.io_interface.base_data_wrapper module class principia_materia.io_interface.base_data_wrapper.BaseDataWrapper(title=None) Bases: ABC\nA container stores how to process the dumping/loading of a collection of data\nAn object oriented wrapper to load and dump data in a certain format.\nIt’s also designed multiple wrappers can be added up to form a wrapper that handles all the data contained in every one of the sub-wrappers.\nParameters\ntitle (str, default to None) – A comment description for the file.\nadd_item(key, choices=None, dtype=None, load_dtype=None, save_dtype=None, optional=False, help=None, alias=None, depends=None) Add an item of data to the container.\nParameters\nkey (str) – The name of the item to be save in the data file.\ndtype (str, default to None) – Data type of the item. The corresponding save/load functions will be used to save/load the item.\nload_dtype (str or callable, default to None) – The function to load the item.\nsave_dtype (str or callable, default to None) – The function to save the item.\noptional (bool, default to False) – Whether the item is optional.\nhelp (str, default to None) – The description of the item.\nalias (list of str, default to None) – A list aliases of the item keyword.\ndepends (list of str, default to None) – The keywords that are required when the item is present.\ncopy() delete_item(key, allow_missing=False) Delete an item of the data from the container.\nabstract dump(data, filename, allow_missing=False, overwrite=False) Dump the data into a data file\nParameters\ndata (dict) – The dictionary containing data to be saved.\nfilename (str) – The name of the file to save the data into,\nallow_missing (bool, optional, default to False) – Whether to allow a declared key not to exists in the data dictionary.\noverwrite (bool, optional, default to False) – When the file exists, whether to replace the content of the file with the content to be saved.\ndumps(data, allow_missing=False) Dump the data into string\nParameters\ndata (dict) – The dictionary containing data to be saved.\nallow_missing (bool, optional, default to False) – Whether to allow a declared key not to exists in the data dictionary.\nget_alias_map() get_all_names_aliases() abstract load(filename, allow_missing=False, allow_unknown=False, load_unknown=False) Load the data from a data file\nParameters\nfilename (str) – The name of the file to save the data into,\nallow_missing (bool, optional, default to False) – Whether to allow a declared key not to exists in the data dictionary.\nallow_unknown (bool, optional, default to False) – Whether to allow keys not declared in the container. Though even if allowed, those keys will not be loaded if load_unknown == False.\nload_unknown (bool, optional, default to False) – Whether to load keys not declared in the container to be loaded in raw.\nloads(text, allow_missing=False, allow_unknown=False, load_unknown=False) Load the data from a string\nParameters\ntext (str) – Data in text format,\nallow_missing (bool, optional, default to False) – Whether to allow a declared key not to exists in the data dictionary.\nallow_unknown (bool, optional, default to False) – Whether to allow keys not declared in the container. Though even if allowed, those keys will not be loaded if load_unknown == False.\nload_unknown (bool, optional, default to False) – Whether to load keys not declared in the container to be loaded in raw.\nregister_dtype(name, load_dtype, save_dtype) Add an load and save dtype to the container\nParameters\nname (str) – The name of the dtype.\nload_dtype (callable) – A callable to perform the load dtype. It’ll process the data and return its final form after loaded from data file.\nsave_dtype (callable) – A callable to perform the save dtype. It’ll process the data and return the value to be dumped to the data file.\nself_check(try_fix=True) verify_data(data) ","categories":"","description":"Module principia_materia.io_interface.base_data_wrapper\n","excerpt":"Module principia_materia.io_interface.base_data_wrapper\n","ref":"/docs/references/principia_materia.io_interface.base_data_wrapper.html","tags":"","title":"Module principia_materia.io_interface.base_data_wrapper"},{"body":"principia_materia.io_interface.compute_job module class principia_materia.io_interface.compute_job.ComputeJob(path, structure=None, jobinput=None, joboutput=None) Bases: object\nA computation job.\nAn abstract class that provides a framework to write interfaces to various compute engines to work with this package.\nThis class holds 1 compute job. It is capable of processing configurations, creating a compute job, parsing certain output of the compute job, and more. Due to the large size of common computation runs, the outputs of the compute job are parse only when they are needed.\ncopy_files(filenames, out=None) Copy static files from config directory to the job directory.\nParameters\nout (str, optional, default to None) – The directory to create the compute job in. If out is None, use self.path.\nfilenames (str) – The filenames or the patterns of the filenames of the files to copy.\ncreate_job(out=None, is_static=True, displacement=None, velocities=None) Create configuration files needed to run a compute job.\nParameters\nout (str, optional, default to None) – The directory to create the compute job in. If out is None, use self.path.\nis_static (bool, optional, default to True) – Whether the compute job is a static calculation.\ndisplacement (array of float, optional, default to None) – The displacement to the crystal.\nvelocities (array of float, optional, default to None) – The initial velocities of the atoms of the crystal.\nget_born_effective_charges() Get Born effective charges from compute result.\nabstract get_cutoff() get_dielectric_tensor() Get dielectric tensor from compute result.\nget_energy() Get energy from compute result.\nget_forces() Get forces from compute result.\nget_kmesh() get_magnetic_moments() Get magnetic moments from compute result.\nget_natoms() Get number of atoms from compute result.\nget_relaxation_displacement() Get relaxation displacement from compute result.\nget_stress() Get stress from compute result.\ninitialize_configuration(config_path=None) Initialize configurations of the compute jobs.\nConfigurations of a compute jobs includes cutoff energy, kpoint mesh, error tolorence, magnetic moments, etc.\nParameters\nconfig_path (str, path to directory) – The directory where configuration of compute job is stored.\nabstract property is_job_finished() property path() rescale_kmesh() Rescale kmesh according to supercell.\nset_kmesh(kmesh) abstract set_output(output) Set the path to the output file of a computation job.\nproperty structure() ","categories":"","description":"Module principia_materia.io_interface.compute_job\n","excerpt":"Module principia_materia.io_interface.compute_job\n","ref":"/docs/references/principia_materia.io_interface.compute_job.html","tags":"","title":"Module principia_materia.io_interface.compute_job"},{"body":"principia_materia.io_interface.compute_job_series module class principia_materia.io_interface.compute_job_series.ComputeJobSeries(structure, root_directory, compute_engine, config_path=None, jobinput=None, joboutput=None) Bases: object\nManage a series of jobs\nSince many part of this package (for example, phonon irreducible derivatives computaiton), usually needs to create and read a series of calculations.\nThe series of jobs are assumed to have a hierarchical directory structure, that every job is in its own directory with the job name as the directory name.\nParameters\nstructure (Crystal or CrystalFTG object) – The primitive crystal structure. Input input is a CrystalFTG object, the primitive cell will be used.\nroot_directory (str) – The root directory that hosts all the jobs of the series.\ncompute_engine (str, or a subclass of principia_materia.io_interface.compute_job.ComputeJob) – The compute engine, for example “vasp” or VASPJob is referring to VASP DFT engine.\nconfig_path (str, optional, default to None) – The path of the configuration file, it is used to create the series of jobs as a template.\nproperty config_path() create_directory(dirname, exists=False) Create directory inside root directory of the job series.\nParameters\ndirname (str) – Directory name to create.\ncreate_job(jobname, supa, prefix=None, displacement=None, strain=None, velocities=None, append=False, dry_run=False) Create a job at the given jobname (jobname will be the directory name).\nParameters\njobname (str) – The name of the job, as well as the directory name to create the job in.\nsupa (array of int, shape(dim, dim)) – The supercell matrix.\nprefix (str, optional, default to None) – The prefixing directory of the job relative to the root directory of the job series.\ndisplacement (array of float, optional, default to None) – The displacement to the crystal.\nstrain (array of float, shape(dim, dim), optional, default to None) – The strain matrix of the structure.\nvelocities (array of float, optional, default to None) – The initial velocities of the atoms of the crystal.\nappend (bool, optional, default to False) – If True, skip existing jobs. Otherwise, throw an error.\ndry_run (bool, optional, default to False) – If True, don’t actually create the job.\ncreate_jobs(jobnames, supa, prefix=None, displacements=None, strain=None, velocities=None, append=False, job_index_name=None, dry_run=False) Create a series of jobs.\nParameters\njobnames (list of str) – The names of the jobs, as well as the directory name to create the jobs in.\nsupa (array of int, shape(dim, dim)) – The supercell matrix.\nprefix (str, optional, default to None) – The prefixing directory of the jobs relative to the root directory of the job series.\ndisplacements (array of float, optional, default to None) – The displacements to the crystal for the jobs.\nstrain (array of float, shape(dim, dim), optional, default to None) – The strain matrix of the structure.\nvelocities (array of float, optional, default to None) – The initial velocities of the atoms of the crystal for the jobs.\nappend (bool, optional, default to False) – If True, skip existing jobs. Otherwise, throw an error.\ndry_run (bool, optional, default to False) – If True, don’t actually create the job.\nget_born_effective_charges_from_job(jobname, prefix=None) Parse Born effective charges from the job.\nParameters\njobname (str) – The name of the job, as well as the directory name to create the job in.\nget_compute_job(jobname, prefix=None) Get the job from the given jobname (jobname would be the directory name).\nParameters\njobname (str) – The name of the job, as well as the directory name to create the job in.\nget_dielectric_tensor_from_job(jobname, prefix=None) Parse the dielectric tensor from the job.\nParameters\njobname (str) – The name of the job, as well as the directory name to create the job in.\nget_energy_from_job(jobname, prefix=None) Parse the energy from the job.\nParameters\njobname (str) – The name of the job, as well as the directory name to create the job in.\nget_forces_from_job(jobname, prefix=None) Parse forces from the job.\nParameters\njobname (str) – The name of the job, as well as the directory name to create the job in.\nget_metadata_path(filename) Get the path to save the metadata file in.\nParameters\nfilename (str) – The base name of metadata file.\nget_results_from_jobs(jobnames, data_type, prefix=None) Get results from a series of jobs.\nParameters\njobnames (list of str) – The names of the jobs, as well as the directory name to create the jobs in.\ndata_type (str) – The type of results to retrieve, can be “forces”, “energy”, “stress”, “born_effective_charges” or “dielectric_tensor”.\nprefix (str, optional, default to None) – The prefixing directory of the jobs relative to the root directory of the job series.\nReturns\ndata – The retrieved results from jobs.\nReturn type\narray of float\nget_stress_from_job(jobname, prefix=None) Parse the stress from the job.\nParameters\njobname (str) – The name of the job, as well as the directory name to create the job in.\nsave_metadata(filename, metadata, dry_run=False) Save metadata into a file in the root directory of job series.\nParameters\nfilename (str) – The base name of metadata file.\nmetadata (str) – The metadata to save in plain text.\ndry_run (bool, optional, default to False) – If True, don’t actually create the metadata file.\nproperty series_exists() Whether if the root directory exists.\nset_static_files(filenames, abspath=False) Set a list of static files to copy into the job directory.\nParameters\nfilenames (str of list of str) – The path names of the files to copy.\nabspath (bool, optional, default to False) – Whether the input filenames are absolute path.\nproperty structure() ","categories":"","description":"Module principia_materia.io_interface.compute_job_series\n","excerpt":"Module principia_materia.io_interface.compute_job_series\n","ref":"/docs/references/principia_materia.io_interface.compute_job_series.html","tags":"","title":"Module principia_materia.io_interface.compute_job_series"},{"body":"principia_materia.io_interface.data_wrapper module class principia_materia.io_interface.data_wrapper.DataWrapper(title=None, prefix=None) Bases: BaseDataWrapper\nA container for the format of a collection of data.\nAn object oriented wrapper to enforce input text-based data format. It’s also designed so that multiple wrappers can be added up to form a wrapper that handles all the data contained in every one of the sub-wrappers.\nYAML is used as the format to read and write from file.\nParameters\ntitle (str, default to None) – A comment description for the file.\nprefix (str, default to None) – Prefix for the keywords when flattening the nested DataWrapper.\ndump(data, filename, allow_missing=False, overwrite=False) Format the data into a YAML file\nParameters\ndata (dict) – The dictionary containing data to be saved.\nfilename (str) – The name of the file to save the data into,\nallow_missing (bool, optional, default to False) – Whether to allow a declared key not to exists in the data dictionary.\noverwrite (bool, optional, default to False) – When the file exists, whether to replace the content of the file with the content to be saved.\ndumps(data, allow_missing=False) Format the data into YAML parsable string\nParameters\ndata (dict) – The dictionary containing data to be saved.\nallow_missing (bool, optional, default to False) – Whether to allow a declared key not to exists in the data dictionary.\nload(filename, allow_missing=False, allow_unknown=False, load_unknown=False) Load the data from a YAML file\nParameters\nfilename (str) – The name of the file to save the data into,\nallow_missing (bool, optional, default to False) – Whether to allow a declared key not to exists in the data dictionary.\nallow_unknown (bool, optional, default to False) – Whether to allow keys not declared in the container. Though even if allowed, those keys will not be loaded if load_unknown == False.\nload_unknown (bool, optional, default to False) – Whether to load keys not declared in the container to be loaded in raw.\nload_dict(data, allow_missing=False, allow_unknown=False, load_unknown=False) Load the data from a dict\nParameters\ntext (str) – A YAML string to load.\nallow_missing (bool, optional, default to False) – Whether to allow a declared key not to exists in the data dictionary.\nallow_unknown (bool, optional, default to False) – Whether to allow keys not declared in the container. Though even if allowed, those keys will not be loaded if load_unknown == False.\nload_unknown (bool, optional, default to False) – Whether to load keys not declared in the container to be loaded in raw.\nload_generic(data, allow_missing=False, allow_unknown=False, load_unknown=False) loads(text, allow_missing=False, allow_unknown=False, load_unknown=False) Load the data from a YAML string\nParameters\ntext (str) – A YAML string to load.\nallow_missing (bool, optional, default to False) – Whether to allow a declared key not to exists in the data dictionary.\nallow_unknown (bool, optional, default to False) – Whether to allow keys not declared in the container. Though even if allowed, those keys will not be loaded if load_unknown == False.\nload_unknown (bool, optional, default to False) – Whether to load keys not declared in the container to be loaded in raw.\n","categories":"","description":"Module principia_materia.io_interface.data_wrapper\n","excerpt":"Module principia_materia.io_interface.data_wrapper\n","ref":"/docs/references/principia_materia.io_interface.data_wrapper.html","tags":"","title":"Module principia_materia.io_interface.data_wrapper"},{"body":"principia_materia.io_interface.hdf5_wrapper module class principia_materia.io_interface.hdf5_wrapper.HDF5Wrapper(title=None) Bases: BaseDataWrapper\nSave/load data in/from HDF5 file.\nA object oriented wrapper to save and load data in and from HDF5 files. This allows us to easily save some custom defined data types into HDF5 supported types.\nParameters\ntitle (str, default to None) – A comment description for the file. The title is not used when saving/loading HDF5 files.\nadd_item(key, choices=None, dtype=None, load_dtype=None, save_dtype=None, optional=False) Add an item of data to the container.\nParameters\nkey (str) – The name of the item to be save in the data file.\ndtype (str, default to None) – Data type of the item. The corresponding save/load functions will be used to save/load the item.\nload_dtype (str or callable, default to None) – The function to load the item.\nsave_dtype (str or callable, default to None) – The function to save the item.\noptional (bool, default to False) – Whether the item is optional.\nhelp (str, default to None) – The description of the item.\nalias (list of str, default to None) – A list aliases of the item keyword.\ndepends (list of str, default to None) – The keywords that are required when the item is present.\ndump(data, filename, allow_missing=False, overwrite=False) Save data into HDF5 file.\nParameters\ndata (dict) – The dictionary containing data to be saved.\nfilename (str) – The name of the file to save the data into,\nallow_missing (bool, optional, default to False) – Whether to allow a declared key not to exists in the data dictionary.\noverwrite (bool, optional, default to False) – When the file exists, whether to replace the content of the file with the content to be saved.\ndump_h5file(data, h5file, allow_missing=False) Save data into HDF5 through a h5py.File/h5py.Group object.\nThis allows us to save data into a HDF5 group within a HDF5 file.\nParameters\ndata (dict) – The dictionary containing data to be saved.\nh5file (h5py.File/h5py.Group object) – The h5py.File/h5py.Group object to save the data into.\nallow_missing (bool, optional, default to False) – Whether to allow a declared key not to exists in the data dictionary.\ndumps(data, allow_missing=False) Dump the data into string\nParameters\ndata (dict) – The dictionary containing data to be saved.\nallow_missing (bool, optional, default to False) – Whether to allow a declared key not to exists in the data dictionary.\nload(filename, allow_missing=False) Load data from HDF5 file\nParameters\nfilename (str) – The name of the file to save the data into,\nallow_missing (bool, optional, default to False) – Whether to allow a declared key not to exists in the data dictionary.\nload_h5file(h5file, allow_missing=False) Load data from HDF5 through a h5py.File/h5py.Group object.\nThis allows us to load data from a HDF5 group within a HDF5 file.\nParameters\nh5file (h5py.File/h5py.Group object) – The h5py.File/h5py.Group object to save the data into.\nallow_missing (bool, optional, default to False) – Whether to allow a declared key not to exists in the data dictionary.\nloads(text, allow_missing=False, allow_unknown=False, load_unknown=False) Load the data from a string\nParameters\ntext (str) – Data in text format,\nallow_missing (bool, optional, default to False) – Whether to allow a declared key not to exists in the data dictionary.\nallow_unknown (bool, optional, default to False) – Whether to allow keys not declared in the container. Though even if allowed, those keys will not be loaded if load_unknown == False.\nload_unknown (bool, optional, default to False) – Whether to load keys not declared in the container to be loaded in raw.\n","categories":"","description":"Module principia_materia.io_interface.hdf5_wrapper\n","excerpt":"Module principia_materia.io_interface.hdf5_wrapper\n","ref":"/docs/references/principia_materia.io_interface.hdf5_wrapper.html","tags":"","title":"Module principia_materia.io_interface.hdf5_wrapper"},{"body":"principia_materia.io_interface.jobs_db module class principia_materia.io_interface.jobs_db.JobsDB(root_directory, db_path, db_type, structure, table=None) Bases: object\nInterface jobs with database.\nParameters\nroot_directory (str) – The root directory that hosts all the jobs of the series.\ndb_path (str) – Path to database.\ndb_type (str) – Type of the database, for example “sqlite”.\nstructure (Crystal or CrystalFTG object) – The primitive crystal structure. Input input is a CrystalFTG object, the primitive cell will be used.\nadd_filter(key, value) Add a filtering condition for database action (query/update/insert).\nParameters\nkey (str) – The name of the column.\nvalue (str/int/float/array) – The filtering value of that column.\ncreate_job(jobname, supa, prefix=None, displacement=None, strain=None, velocities=None, append=False, dry_run=False) Create a job with the given jobname in the database.\nParameters\njobname (str) – The name of the job, as well as the directory name to create the job in.\nsupa (array of int, shape(dim, dim)) – The supercell matrix.\nprefix (str, optional, default to None) – The prefixing directory of the job relative to the root directory of the job series.\ndisplacement (array of float, optional, default to None) – The displacement to the crystal.\nstrain (array of float, shape(dim, dim), optional, default to None) – The strain matrix of the structure.\nvelocities (array of float, optional, default to None) – The initial velocities of the atoms of the crystal.\nappend (bool, optional, default to False) – If True, skip existing jobs. Otherwise, throw an error.\ndry_run (bool, optional, default to False) – If True, don’t actually create the job.\ncreate_jobs(jobnames, supa, prefix=None, displacements=None, strain=None, velocities=None, append=False, job_index_name=None, additional_filters={}, dry_run=False) Create a series of jobs in database.\nParameters\njobnames (list of str) – The names of the jobs.\nsupa (array of int, shape(dim, dim)) – The supercell matrix.\nprefix (str, optional, default to None) – The prefixing directory of the jobs relative to the root directory of the job series.\ndisplacements (array of float, optional, default to None) – The displacements to the crystal for the jobs.\nstrain (array of float, shape(dim, dim), optional, default to None) – The strain matrix of the structure.\nvelocities (array of float, optional, default to None) – The initial velocities of the atoms of the crystal for the jobs.\nappend (bool, optional, default to False) – If True, skip existing jobs. Otherwise, throw an error.\ndry_run (bool, optional, default to False) – If True, don’t actually create the job.\nget_born_effective_charges_from_job(jobname=None, step_index=None) Get Born effective charges from the job.\nParameters\njobname (str) – The name of the job, as well as the directory name to create the job in.\nstep_index (int) – The step index of the job in an finite difference calculation.\nget_dielectric_tensor_from_job(jobname=None, step_index=None) Get the dielectric tensor from the job.\nParameters\njobname (str) – The name of the job, as well as the directory name to create the job in.\nstep_index (int) – The step index of the job in an finite difference calculation.\nget_energy_from_job(jobname=None, step_index=None) Get the energy from the job.\nParameters\njobname (str) – The name of the job, as well as the directory name to create the job in.\nstep_index (int) – The step index of the job in an finite difference calculation.\nget_forces_from_job(jobname=None, step_index=None) Get forces from the job.\nParameters\njobname (str) – The name of the job, as well as the directory name to create the job in.\nstep_index (int) – The step index of the job in an finite difference calculation.\nget_metadata_path(filename) get_results_from_jobs(jobnames, data_type, job_index_name=None) Get results of a series of jobs from database.\nParameters\njobnames (list of str) – The names of the jobs.\ndata_type (str) – The type of results to retrieve, can be “forces”, “energy”, “stress”, “born_effective_charges” or “dielectric_tensor”.\nprefix (str, optional, default to None) – The prefix of the jobs relative to the root directory of the job series.\nReturns\ndata – The retrieved results from jobs.\nReturn type\narray of float\nget_stress_from_job(jobname=None, step_index=None) Get the stress from the job.\nParameters\njobname (str) – The name of the job, as well as the directory name to create the job in.\nstep_index (int) – The step index of the job in an finite difference calculation.\nremove_filter(key) Remive a filtering condition from database action.\nParameters\nkey (str) – The name of the column.\nreset_filters() Reset the database filters.\nsave_metadata(filename, metadata, dry_run=False) save_table_info(info_table, data) Save some generic information of the table that the jobs are created in to an information table.\nParameters\ninfo_table (str) – The name of the information table.\ndata (dict) – The generic information to save in the information table.\nset_table(table) Set name of the table to access.\nParameters\ntable (str) – Table name.\nproperty structure() ","categories":"","description":"Module principia_materia.io_interface.jobs_db\n","excerpt":"Module principia_materia.io_interface.jobs_db\n","ref":"/docs/references/principia_materia.io_interface.jobs_db.html","tags":"","title":"Module principia_materia.io_interface.jobs_db"},{"body":"principia_materia.io_interface.qpoints_io module principia_materia.io_interface.qpoints_io.array_to_list(array) Convert array of nested lists.\nParameters\narray (array of numbers) – The array to convert from.\nprincipia_materia.io_interface.qpoints_io.array_to_tuple(array) Convert array of nested tuples.\nParameters\narray (array of numbers) – The array to convert from.\n","categories":"","description":"Module principia_materia.io_interface.qpoints_io\n","excerpt":"Module principia_materia.io_interface.qpoints_io\n","ref":"/docs/references/principia_materia.io_interface.qpoints_io.html","tags":"","title":"Module principia_materia.io_interface.qpoints_io"},{"body":"principia_materia.io_interface.vasp module principia_materia.io_interface.vasp.parse_poscar(poscar) Parse data from POSCAR, and package the data that can be read into our translation group classes.\nSee _parse_poscar for actual parsing of the POSCAR.\nParameters\nposcar (str) – A path to a POSCAR file or a string with the content of a POSCAR file. CONTCAR is accepted as well.\nReturns\nretval – A dictionary of all the information from POSCAR, with keywords vec, atoms and velocites in format that can be ready into tranlation group classes.\nReturn type\ndict\nprincipia_materia.io_interface.vasp.write_poscar(structure, displacement=None, title=None, selective_dynamics=None, velocities=None, is_velocities_direct=True, direct_coordinates=True, prec=8) Write structure file into POSCAR.\nParameters\nstructure (Crystal or CrystalFTG object) – The crystal structure.\ndisplacement (array of float, shape(natoms, 3), optional, default to None) – The displacement to the crystal.\ntitle (str, optional, default to None) – The title of the crystal.\nselective_dynamics (array of bool, shape(natoms, 3), optional, default to None) – The selective dynamics flags for POSCAR\nvelocities (array of float, shape(natoms, 3), optional, default to None) – The initial velocities of the atoms of the crystal.\nis_velocities_direct (bool, optional, default to True) – Whether to write the velocities are in direct coordinates.\ndirect_coordinates (bool, optional, default to True) – Whether to write the atoms positions in direct coordinates.\nprec (int, optional, default to 8) – The decimal points to round the floating point numbers to.\n","categories":"","description":"Module principia_materia.io_interface.vasp\n","excerpt":"Module principia_materia.io_interface.vasp\n","ref":"/docs/references/principia_materia.io_interface.vasp.html","tags":"","title":"Module principia_materia.io_interface.vasp"},{"body":"principia_materia.io_interface.yaml_dump module principia_materia.io_interface.yaml_dump.yaml_dumps(data, prec=8) Save data in a custom YAML format string.\nThe official yaml module cannot dump data in a consistent format, this function solves that problem by using a consistent format for various data types. Additionally, data types like numpy.ndarray can be safely saved into YAML nested list format without extra work, making saving YAML file much easier.\nParameters\ndata (dict) – The data to save.\nprec (int, optional, default to 8) – The decimal points to round the floating point numbers to.\n","categories":"","description":"Module principia_materia.io_interface.yaml_dump\n","excerpt":"Module principia_materia.io_interface.yaml_dump\n","ref":"/docs/references/principia_materia.io_interface.yaml_dump.html","tags":"","title":"Module principia_materia.io_interface.yaml_dump"},{"body":"principia_materia.mathematics package Submodules principia_materia.mathematics.array_utils module\narray_in_2darray()\nindex_array_in_array()\nprincipia_materia.mathematics.core_math module\ngaussian()\ngs_orthog()\nprincipia_materia.mathematics.errortail module\nfit_errortail()\ngenerate_picks()\nget_errortail()\nget_errortail_yaml_wrapper()\nleast_square()\npenalty_linear_mse()\npenalty_sqrt_mse()\npenalty_square_mse()\nprincipia_materia.mathematics.finite_difference module\nFiniteDifference\nFiniteDifference.order\nFiniteDifference.delta\nFiniteDifference.uniq_steps\nFiniteDifference.add_delta()\nFiniteDifference.compute_finite_difference()\nFiniteDifference.delta\nFiniteDifference.get_stencils_1d()\nFiniteDifference.set_delta()\nFiniteDifference.set_stencils()\nFiniteDifference.set_stencils_1d()\nFiniteDifference.set_steps()\nFiniteDifference.uniq_steps\nprincipia_materia.mathematics.fourier_transform module\nbackward_fourier_transform()\nforward_fourier_transform()\nprincipia_materia.mathematics.new_fraction module\nFraction\nFraction.limit_denominator() principia_materia.mathematics.smith_normal_form module\nDiagonalForm()\nHermiteNormalForm_AU()\nHermiteNormalForm_UA()\nSmithNormalForm()\nprincipia_materia.mathematics.tensor_utils module\nfind_linearly_independent_vectors()\nfind_most_linearly_independent_rows()\nrotate_tensor()\nModule contents principia_materia.mathematics.int_det(matrix) ","categories":"","description":"Module principia_materia.mathematics\n","excerpt":"Module principia_materia.mathematics\n","ref":"/docs/references/principia_materia.mathematics.html","tags":"","title":"Module principia_materia.mathematics"},{"body":"principia_materia.mathematics.array_utils module principia_materia.mathematics.array_utils.array_in_2darray(arr1, arr2, tol=None) Check if a 1D array is a sub-array of a 2D array.\nprincipia_materia.mathematics.array_utils.index_array_in_array(arr1, arr2, tol=None, complete=True, return_both=False) Find the indices for sub-arrays of arr1 in arr2.\nBoth arr1 and arr2 have same sub-arrays but in different order. This method finds the indices of these sub-arrays in arr2 to order them to the same ordering in arr1.\n","categories":"","description":"Module principia_materia.mathematics.array_utils\n","excerpt":"Module principia_materia.mathematics.array_utils\n","ref":"/docs/references/principia_materia.mathematics.array_utils.html","tags":"","title":"Module principia_materia.mathematics.array_utils"},{"body":"principia_materia.mathematics.core_math module principia_materia.mathematics.core_math.gaussian(w, sigma, w0=0.0) Gaussian\n..math\ng (w - w_0) = \\frac{1}{\\sqrt{2 \\pi} \\sigma} e^{- \\frac{(w - w_0)^2}{2 sigma^2}} principia_materia.mathematics.core_math.gs_orthog(arr, allowzero=False, tol=1e-06) Gram-Schmidt orthonormalize a set of vectors.\nParameters\narr (array of numbers, shape(n, m)) – The set of vectors to be orthonormalized, in row convention.\nallowzero (bool, optional, default to False) – If True, allow 0 vectors in orthogonalization.\ntol (float, optional, default to 1.0E-6) – Error tolerance.\nReturns\narr – The orthonormalized vectors.\nReturn type\narray of numbers, shape(n, m)\n","categories":"","description":"Module principia_materia.mathematics.core_math\n","excerpt":"Module principia_materia.mathematics.core_math\n","ref":"/docs/references/principia_materia.mathematics.core_math.html","tags":"","title":"Module principia_materia.mathematics.core_math"},{"body":"principia_materia.mathematics.errortail module principia_materia.mathematics.errortail.fit_errortail(delta, datapoints, power=2, pick_min=3, pick_max=None, consecutive_picks=False, penalty=, separate_complex=False) Fit error tail for finite difference calculations.\nEither pick n and pick N scheme can be used with various penalty function.\nParameters\ndelta (array of floats, shape(n, )) – The delta values of the finite difference.\ndatapoints (array of numbers (complex or float), shape(n, ) or shape(n, m)) – The target function values evaluated at each delta. If the input is 2-dimensional, each column is computed separately.\npower (int, optional, default to 2) – The power of the error tail. For forward and backward only FD, the error tail is linear. For central FD, the error tail is quadratic.\npick_min (int, optional, default to 3) – The minimum number of picks for delta selection.\npick_max (int, optional, default to None) – The maximum number of picks for delta selection. If None, the pick n scheme is used with n=pick_min. If not None, the pick N schcme is used with N=[pick_min, pick_max].\nconsecutive_picks (bool, optional, default to False) – Whether to pick consecutive deltas in the picking process.\npenalty (callable, optional, default to penalty_linear_mse) – The penalty function to determine the best fit.\nseparate_complex (bool, optional, default to False) – Whether to fit real and imaginary part of the complex data points separetely.\nReturns\nfit_result (array of numbers (complex or float, same of type of datapoints), shape(m, 2)) – The coefficients of the fitted error tail.\nfinal_pick (list of arrays of int or complex, length of m) – The indices of the picked points.\npenalty_value (array of numbers (complex or float, same of type of datapoints), shape(m, )) – The result of the penalty function.\nprincipia_materia.mathematics.errortail.generate_picks(total, pick, consecutive=False) Generator for indices to pick with specified pick scheme.\nParameters\ntotal (int) – The total number of points to pick from.\npick (int) – The number of points to pick.\nconsecutive (bool, optional, detault to False) – Whether the points need to be picked consecutively.\nprincipia_materia.mathematics.errortail.get_errortail(deltas, values, fdtype=‘c’, pick_min=3, pick_max=None, consecutive=False, penalty=, separate_complex=True, return_xcoef=False, return_pick=False, return_penalty=False) Compute error tail for finite difference results.\nIn this function, contrary to the fit_errortail function, the order of the errortail is determined by the type of the finite difference instead.\nParameters\ndelta (array of floats, shape(n, )) – The delta values of the finite difference.\nvalues (array of numbers (complex or float), shape(n, ) or shape(n, m, …)) – The target function values evaluated at each delta. If the input dimention is higher than 1, each entry from the second dimention and beyond is computed separately.\nfdtype (str, choice of [“c”, “b”, “f”], default to “c”) – The type of finite difference calculation, “c” for central, “b” for backward and “f” for forward. For forward and backward only FD, the error tail is linear. For central FD, the error tail is quadratic.\npick_min (int, optional, default to 3) – The minimum number of picks for delta selection.\npick_max (int, optional, default to None) – The maximum number of picks for delta selection. If None, the pick n scheme is used with n=pick_min. If not None, the pick N schcme is used with N=[pick_min, pick_max].\nconsecutive_picks (bool, optional, default to False) – Whether to pick consecutive deltas in the picking process.\npenalty (callable, optional, default to penalty_linear_mse) – The penalty function to determine the best fit.\nseparate_complex (bool, optional, default to False) – Whether to fit real and imaginary part of the complex data points separetely.\nreturn_xcoef (bool, optional, default to False) – Whether to return the coefficient of the x^order term.\nreturn_pick (bool, optional, default to False) – Whether to return the indices of the picked points.\nreturn_penalty (bool, optional, default to False) – Whether to return the result of the penalty function.\nReturns\nresult (array of numbers (complex or float, same of type of values), shape(m, …)) – The intercept of the error tail.\nxcoef (array of numbers (complex or float, same of type of values), shape(m, …)) – The coefficient of the x^order term, can be used to plot the fitted error tail.\npick (list of arrays of int or complex, length of m) – The indices of the picked points.\npenalty (array of numbers (complex or float, same of type of values), shape(m, …)) – The result of the penalty function.\nprincipia_materia.mathematics.errortail.get_errortail_yaml_wrapper(title=‘Errortail Dataset’, iscomplex=False) principia_materia.mathematics.errortail.least_square(A, b, return_R=False, return_mse=False, return_S=False, return_stdx=False) Compute least square of Ax=b\nThe function computes the least square solution for the equation $A \\cdot x=b$, as well as metrics to evaluate the quality of the solution when the input A is not square and full rank, and the solution is not exact.\nParameters\nA (array of numbers, shape(N, m)) – Matrix A.\nb (array of numbers, shape(N, ) or shape(N, l)) – Vector b, if b is 2 dimensional, least square is computed for each column of b.\nreturn_R (bool) – Whether to return residuals.\nreturn_mse (bool) – Whether to return mean square error.\nreturn_S (bool) – Whether to return covariance matrix.\nreturn_stdx (bool) – Whether to return standard error.\nReturns\nx (array of numbers, shape(l, m)) – Least square solution.\nR (array of numbers, shape(l, )) – Residuals of the least square.\nmse (array of numbers, shape(l, )) – Mean square error of the least square.\nS (array of numbers, shape(l, m, m)) – Covariance matrix of the least square.\nstdx (array of numbers, shape(l, m)) – Standard error of the least square.\nprincipia_materia.mathematics.errortail.penalty_linear_mse(n, R, mse, S, stdx) Compute linear penalty from mse\nParameters\nn (int) – Number of points to fit with\nR (float or complex) – Residule of least square\nmse (float or complex) – Mean squared error of least square\nS (float or complex) – Covariance of least square\nstdx (float or complex) – Standard error of least square\nReturns\npenalty – The penalty\nReturn type\nfloat or complex\nprincipia_materia.mathematics.errortail.penalty_sqrt_mse(n, R, mse, S, stdx) Compute square root penalty from mse\nParameters\nn (int) – Number of points to fit with\nR (float or complex) – Residule of least square\nmse (float or complex) – Mean squared error of least square\nS (float or complex) – Covariance of least square\nstdx (float or complex) – Standard error of least square\nReturns\npenalty – The penalty\nReturn type\nfloat or complex\nprincipia_materia.mathematics.errortail.penalty_square_mse(n, R, mse, S, stdx) Compute squared penalty from mse\nParameters\nn (int) – Number of points to fit with\nR (float or complex) – Residule of least square\nmse (float or complex) – Mean squared error of least square\nS (float or complex) – Covariance of least square\nstdx (float or complex) – Standard error of least square\nReturns\npenalty – The penalty\nReturn type\nfloat or complex\n","categories":"","description":"Module principia_materia.mathematics.errortail\n","excerpt":"Module principia_materia.mathematics.errortail\n","ref":"/docs/references/principia_materia.mathematics.errortail.html","tags":"","title":"Module principia_materia.mathematics.errortail"},{"body":"principia_materia.mathematics.finite_difference module class principia_materia.mathematics.finite_difference.FiniteDifference(order, fdtype=‘c’) Bases: object\nCompute finite difference\nParameters\norder (int, or tuple of int) – The order of the finite difference derivative. If input type int, compute FD of a single variable to given order. If input tuple of int, compute FD of len(order) variables, to respective order.\nfdtype (choice between “c”, “f” and “b”) – Type of finite difference:\n”c” for central, “f” for forward, “b” for backward.\norder() The order of derivative at each variable.\nType\narray of int, shape(nvar, )\ndelta() The delta(s) to evaluate at using the finite difference. The delta can be different at each variable.\nType\narray of float, shape(nvar, ndelta)\nuniq_steps() The unique steps needed to compute finite difference for the given order and delta configuration.\nType\narray of float, shape(n, nvar)\nadd_delta(new_delta, decimal=6) Add extra delta(s) and found the map from old steps to new steps.\ncompute_finite_difference(fvals) Compute finite difference\nParameters\nfvals (array of numbers, shape (len(uniq_steps), ) or (len(uniq_steps), N…)) – Values of the target function at each step, can process multiple values simultaneously.\nReturns\nfd_result – Result of the finite difference.\nReturn type\narray of numbers, shape fvals.shape[1:]\nproperty delta() get_stencils_1d(order) Compute the single variable FD stencil to given order.\nEquations for coefficients on each stencil can be found on Finite difference Wikipedia page\nParameters\norder (int) – The order of the derivative\nset_delta(delta, overwrite=False) Set delta for finite difference computation\nParameters\ndelta (float or array of float, shape of (N, ) or (len(order), N)) – ( N != len(order) ) The delta(s) of the derivative. If pass in a float, use the same delta for each order. If pass in array:\nIn the case of shape(N, ), use same delta for all variables, and compute N deltas at the same time. In the case of shape(len(order), N), use different delta for each variable, and compute N deltas at the same time. set_stencils() Set stencils for FD derivatives.\nFind the stencils needed to compute finite difference.\nset_stencils_1d() Find stencils for each FD variable.\nset_steps(decimal=6) Find unique steps needed to compute finite differece.\nWith the found stencils, find all the steps needed to evaluate for the target function, and find the unique steps as well as the inverse map to the full steps grid.\nParameters\ndecimal (int) – The precision to consider 2 steps equal.\nproperty uniq_steps() ","categories":"","description":"Module principia_materia.mathematics.finite_difference\n","excerpt":"Module principia_materia.mathematics.finite_difference\n","ref":"/docs/references/principia_materia.mathematics.finite_difference.html","tags":"","title":"Module principia_materia.mathematics.finite_difference"},{"body":"principia_materia.mathematics.fourier_transform module principia_materia.mathematics.fourier_transform.backward_fourier_transform(tensors, p, q) Backward Fourier Transform for arbitrary orders\nParameters\ntensors (array of complex/float of shape(N, n_1, …, n_n)) – Tensors to be Fourier Transformed.\np (array of numbers of shape(N, m_1, …, m_m)) – The corresponding T/Q points of the tensors.\nq (array of numbers of shape(M, m_1, …, m_m) or shape(m_1, …, m_m)) – The Q/T points for the tensors to be transformed into.\nReturns\nrestult – The result of Fourier Transform. (If input q has shape of (m_1, …, m_m), returns shape (n_1, …, n_n).)\nReturn type\nlength M array of complex/float of shape(M, n_1, …, n_n)\nprincipia_materia.mathematics.fourier_transform.forward_fourier_transform(tensors, p, q) Forward Fourier Transform for arbitrary orders\nParameters\ntensors (array of complex/float of shape(N, n_1, …, n_n)) – Tensors to be Fourier Transformed.\np (array of numbers of shape(N, m_1, …, m_m)) – The corresponding T/Q points of the tensors.\nq (array of numbers of shape(M, m_1, …, m_m) or shape(m_1, …, m_m)) – The Q/T points for the tensors to be transformed into.\nReturns\nrestult – The result of Fourier Transform. (If input q has shape of (m_1, …, m_m), returns shape (n_1, …, n_n).)\nReturn type\nlength M array of complex/float of shape(M, n_1, …, n_n)\n","categories":"","description":"Module principia_materia.mathematics.fourier_transform\n","excerpt":"Module principia_materia.mathematics.fourier_transform\n","ref":"/docs/references/principia_materia.mathematics.fourier_transform.html","tags":"","title":"Module principia_materia.mathematics.fourier_transform"},{"body":"principia_materia.mathematics.new_fraction module class principia_materia.mathematics.new_fraction.Fraction(numerator=0, denominator=None, *, _normalize=True) Bases: Fraction\nUpdated methods of built-in Fraction type to fix some deprecation errors.\nlimit_denominator(max_denominator=1000000) Closest Fraction to self with denominator at most max_denominator.\n\u003e\u003e\u003e Fraction('3.141592653589793').limit_denominator(10) Fraction(22, 7) \u003e\u003e\u003e Fraction('3.141592653589793').limit_denominator(100) Fraction(311, 99) \u003e\u003e\u003e Fraction(4321, 8765).limit_denominator(10000) Fraction(4321, 8765) ","categories":"","description":"Module principia_materia.mathematics.new_fraction\n","excerpt":"Module principia_materia.mathematics.new_fraction\n","ref":"/docs/references/principia_materia.mathematics.new_fraction.html","tags":"","title":"Module principia_materia.mathematics.new_fraction"},{"body":"principia_materia.mathematics.smith_normal_form module Smith Normal Form and Hermite Normal Form\nAn implementation of Smith Normal Form following the algorithm described in Smith Normal Form - Wikipedia.\nHermite Normal Form is implemented following the definition in Hermite Normal Form - Wikipedia.\nprincipia_materia.mathematics.smith_normal_form.DiagonalForm(M) Finds the diagonalized form of the integer matrix M.\nprincipia_materia.mathematics.smith_normal_form.HermiteNormalForm_AU(M) Hermite Normal Form of M, Column style\nH = ML\nprincipia_materia.mathematics.smith_normal_form.HermiteNormalForm_UA(M) Hermite Normal Form of M, Row style\nH = LM\nprincipia_materia.mathematics.smith_normal_form.SmithNormalForm(M) Finds the Smith Normal Form of the integer matrix M.\nThe 0 diagonal elements will appear at the end.\n","categories":"","description":"Module principia_materia.mathematics.smith_normal_form\n","excerpt":"Module principia_materia.mathematics.smith_normal_form\n","ref":"/docs/references/principia_materia.mathematics.smith_normal_form.html","tags":"","title":"Module principia_materia.mathematics.smith_normal_form"},{"body":"principia_materia.mathematics.tensor_utils module principia_materia.mathematics.tensor_utils.find_linearly_independent_vectors(vectors, tol=1e-06, return_vectors=False) Use Gram-Schmidt to find a set of linearly independent vectors.\nParameters\nvectors (array of numbers, shape(n, m)) – The set of vectors to be orthonormalized, in row convention.\ntol (float, optional, default to 1.0E-6) – Error tolerance.\nreturn_vectors (bool, optional, default to False) – Whether to return the orthonormalized vectors.\nReturns\nliv_indices (array of int, shape(rank(vectors), )) – The indicies of the linearly independent vectors.\nvectors (array of numbers, shape(n, m)) – (if return_vectors == True) The orthonormalized vectors.\nprincipia_materia.mathematics.tensor_utils.find_most_linearly_independent_rows(vectors, tol=1e-06, return_vectors=False) principia_materia.mathematics.tensor_utils.rotate_tensor(rotation_matricies, tensor, rank) Rotate a tensor.\n$$ T^{\\prime}_{i^{\\prime} j^{\\prime} k^{\\prime} l^{\\prime} \\cdots} = % \\sum_{i j k l} % a_{i i^{\\prime}} b_{j j^{\\prime}} c_{i k^{\\prime}} d_{i l^{\\prime}} % \\cdots T_{i j k l \\cdots} $$\nParameters\nrotation_matricies (list of arrays of float/complex, length of rank) – (Each array must be a square matrix of same shape of i-th index of tensor) Rotation matrices to rotate the tensor.\ntensor (array of float/complex, shape(n_1, …, n_{rank}) of shape(n_1, …, n_{rank + 1})) – The tensor to rotate.\nrank (int) – The rank of the tensor.\n","categories":"","description":"Module principia_materia.mathematics.tensor_utils\n","excerpt":"Module principia_materia.mathematics.tensor_utils\n","ref":"/docs/references/principia_materia.mathematics.tensor_utils.html","tags":"","title":"Module principia_materia.mathematics.tensor_utils"},{"body":"principia_materia.phonon_id package Submodules principia_materia.phonon_id.analytic_dynamic_tensor module\nAnalyticDynamicTensor\nAnalyticDynamicTensor.Qpoint\nAnalyticDynamicTensor.compute_tensor()\nAnalyticDynamicTensor.get_irreducible_basis_rowname()\nAnalyticDynamicTensor.get_irreps()\nAnalyticDynamicTensor.get_rotation_matrix()\nAnalyticDynamicTensor.irreducible_derivative_names\nAnalyticDynamicTensor.n_irreducible_derivatives\nAnalyticDynamicTensor.order\nAnalyticDynamicTensor.qpoint_displacement_rep\nAnalyticDynamicTensor.set_irreducible_derivative_names()\nAnalyticDynamicTensor.set_irreducible_derivatives()\nAnalyticDynamicTensor.set_qpoint_displacement_rep()\nAnalyticDynamicTensor.set_vectorized_tensor()\nAnalyticDynamicTensor.solve_irreducible_derivatives()\nAnalyticDynamicTensor.symmetrized_tensor_shape\nAnalyticDynamicTensor.symmetrized_vectorized_tensor\nAnalyticDynamicTensor.tensor_shape\nAnalyticDynamicTensor.unique_qpoints\nAnalyticDynamicTensor.vectorized_tensor\nget_AnalyticDynamicTensor_hdf5_wrapper()\nget_IrreducibleDerivatives_hdf5_wrapper()\nprincipia_materia.phonon_id.analytic_strain_tensor module\nAnalyticStrainTensor\nAnalyticStrainTensor.compute_tensor()\nAnalyticStrainTensor.get_irreducible_basis_rowname()\nAnalyticStrainTensor.get_irreps()\nAnalyticStrainTensor.get_rotation_matrix()\nAnalyticStrainTensor.identity_subspace\nAnalyticStrainTensor.irreducible_derivative_names\nAnalyticStrainTensor.irreducible_strains\nAnalyticStrainTensor.n_irreducible_derivatives\nAnalyticStrainTensor.set_irreducible_derivative_names()\nAnalyticStrainTensor.set_irreducible_derivatives()\nAnalyticStrainTensor.set_irreducible_strains()\nAnalyticStrainTensor.set_strain_rep()\nAnalyticStrainTensor.set_vectorized_tensor()\nAnalyticStrainTensor.solve_irreducible_derivatives()\nAnalyticStrainTensor.symmetrized_tensor_shape\nAnalyticStrainTensor.symmetrized_vectorized_tensor\nAnalyticStrainTensor.tensor_shape\nAnalyticStrainTensor.vectorized_tensor\nprincipia_materia.phonon_id.analytic_tensors module\nAnalyticTensors\nAnalyticTensors.compute_D_from_ID()\nAnalyticTensors.compute_ID_from_D()\nAnalyticTensors.copy()\nAnalyticTensors.irreducible_derivative_names\nAnalyticTensors.n_irreducible_derivatives\nAnalyticTensors.set_ADT()\nAnalyticTensors.set_D()\nAnalyticTensors.set_irreducible_D()\nget_AnalyticTensors_from_hdf5()\nget_AnalyticTensors_hdf5_wrapper()\nsave_AnalyticTensors_to_hdf5()\nprincipia_materia.phonon_id.anharmonic_interpolation module\nAnharmincInterpolation\nAnharmincInterpolation.analytic_derivative_dynamic_matrix()\nAnharmincInterpolation.existing_orders\nAnharmincInterpolation.fd_derivative_dynamic_matrix()\nAnharmincInterpolation.get_Dq2()\nAnharmincInterpolation.get_DqN()\nAnharmincInterpolation.get_Phi()\nAnharmincInterpolation.get_phonons()\nAnharmincInterpolation.group_velocity()\nAnharmincInterpolation.heat_capacity()\nAnharmincInterpolation.set_Phi()\nAnharmincInterpolation.set_dipole()\nAnharmincInterpolation.set_q_direction()\nmode_heat_capacuty()\nprincipia_materia.phonon_id.bid module\nBID\nBID.compute_irreducible_derivatives()\nBID.irreducible_derivatives\nBID.create_jobs()\nBID.derivative_order\nBID.find_measurements()\nBID.get_dynamic_tensors()\nBID.get_fourier_interpolation()\nBID.get_irreducible_derivative_names()\nBID.set_chainrule_derivatives()\nBID._chainrule\nBID.set_chainrule_matrix()\nBID.set_errortail_results()\nBID._fd_errortail\nBID.set_measurements()\nBID.set_results()\nBID._fd_results\nDisplacementGenerator\nDisplacementGenerator.astep()\nDisplacementGenerator.astep_one()\nDisplacementGenerator.n\nDisplacementGenerator.next()\nDisplacementGenerator.reset()\nRandomDisplacementGenerator\nRandomDisplacementGenerator.next()\nRandomDisplacementGenerator.reset()\nformat_measurement_label()\nget_BID_from_hdf5()\nget_BID_hdf5_wrapper()\nsave_BID_to_hdf5()\nsave_bid_errortails()\nprincipia_materia.phonon_id.chainrule_derivatives module\nChainruleDerivatives\nChainruleDerivatives.add_known_ID()\nChainruleDerivatives.basis_names\nChainruleDerivatives.basis_vectors\nChainruleDerivatives.compute_chainrule()\nChainruleDerivatives.decompose_displacements()\nChainruleDerivatives.displacement_shape\nChainruleDerivatives.get_chainrule_factors()\nChainruleDerivatives.known_ID\nChainruleDerivatives.nonzero_ID_index\nChainruleDerivatives.normalize_displacements()\nChainruleDerivatives.set_basis()\nChainruleDerivatives.set_naive_basis()\nChainruleDerivatives.set_symmetric_basis()\nChainruleDerivatives.unknown_ID\nget_ChainruleDerivatives_from_hdf5()\nget_ChainruleDerivatives_hdf5_wrapper()\nsave_ChainruleDerivatives_to_hdf5()\nprincipia_materia.phonon_id.conductivity module\nConductivity\nConductivity.gamma_tetra()\nConductivity.gamma_tetra_at_phonon()\nConductivity.gamma_tetra_grid()\nConductivity.has_Phi_order()\nConductivity.scattering_rate_boundary()\nConductivity.set_Phi()\nConductivity.set_dipole()\nConductivity.thermal_conductivity_LBTE()\nConductivity.thermal_conductivity_RTA()\nConductivity.two_phonon_dos()\nbedist()\nreciprocal()\nprincipia_materia.phonon_id.dipole_dipole module\nDipoleDipole\nDipoleDipole.Gvecs\nDipoleDipole.c_dd()\nDipoleDipole.c_dd_batch()\nDipoleDipole.c_dd_q0\nDipoleDipole.dc_dd_G_dK()\nDipoleDipole.dc_dd_dK()\nDipoleDipole.dc_dd_dK_batch()\nDipoleDipole.get_c_dd_q0()\nDipoleDipole.get_valid_slice()\nget_DipoleDipole_from_yaml()\nget_dipole_dataset_yaml_wrapper()\nsave_DipoleDipole_to_yaml()\nprincipia_materia.phonon_id.dynamic_tensors module\nDynamicTensors\nDynamicTensors.copy()\nDynamicTensors.get_D_at_Q()\nDynamicTensors.get_full_D()\nDynamicTensors.prepend_hiden_q()\nDynamicTensors.set_D()\nDynamicTensors.set_dipoledipole()\nDynamicTensors.set_dipoledipole_contribution()\nDynamicTensors.set_irreducible_D()\nget_DynamicTensors_from_hdf5()\nget_DynamicTensors_hdf5_wrapper()\nsave_DynamicTensors_to_hdf5()\nprincipia_materia.phonon_id.fd_series module\nFDSeries\nFDSeries.create_jobs()\nFDSeries.project_fd_results()\nFDSeries.set_deltas()\nFDSeries.set_errortail_results()\nFDSeries.set_jobname_prefix()\nFDSeries.set_measurement_alias()\nFDSeries.set_measurements()\nFDSeries.set_results()\nFDSeries._fd_results\nformat_delta_dirname()\nget_FDSeries_from_hdf5()\nget_FDSeries_hdf5_wrapper()\nget_FDSeries_results_hdf5_wrapper()\nsave_FDSeries_results_to_hdf5()\nsave_FDSeries_to_hdf5()\nprincipia_materia.phonon_id.finite_displacements module\nFiniteDisplacements\nFiniteDisplacements.add_delta()\nFiniteDisplacements.compute_finite_displacements()\nFiniteDisplacements.create_jobs()\nFiniteDisplacements.delta\nFiniteDisplacements.get_jobname\nFiniteDisplacements.set_delta()\nFiniteDisplacements.set_displacement_vectors()\nFiniteDisplacements.set_jobname_template()\nFiniteDisplacements.set_jobs()\nFiniteDisplacements.set_raw_results()\nFiniteDisplacements.uniq_displacements\nget_FD_from_configuration()\nget_fd_config_hdf5_wrapper()\nget_fd_config_yaml_wrapper()\nget_fd_results_hdf5_wrapper()\nget_fd_results_yaml_wrapper()\nsave_FD_config_to_hdf5()\nsave_FD_config_to_yaml()\nprincipia_materia.phonon_id.fourier_interpolation module\nFourierInterpolation\nFourierInterpolation.analytic_derivative_dynamic_tensor()\nFourierInterpolation.copy()\nFourierInterpolation.fourier_transform()\nFourierInterpolation.from_dynamic_tensors()\nFourierInterpolation.get_Phi()\nFourierInterpolation.get_Phi_WS_at_Tpoint()\nFourierInterpolation.get_Phi_WS_dict()\nFourierInterpolation.get_Tindex()\nFourierInterpolation.get_Tpoints()\nFourierInterpolation.interpolate_Qpoint()\nFourierInterpolation.prepend_hiden_t()\nFourierInterpolation.set_D()\nFourierInterpolation.set_Phi()\nFourierInterpolation.set_Wigner_Seitz_map()\nFourierInterpolation.set_dipoledipole_contribution()\nFourierInterpolation.set_irreducible_D()\nget_FourierInterpolation_from_hdf5()\nget_FourierInterpolation_hdf5_wrapper()\nsave_FourierInterpolation_to_hdf5()\nprincipia_materia.phonon_id.frozen_phonons module\nFrozenPhonons\nFrozenPhonons.check_supercell()\nFrozenPhonons.create_jobs()\nFrozenPhonons.derivative_order\nFrozenPhonons.get_dynamic_tensor()\nFrozenPhonons.order\nFrozenPhonons.set_displacements()\nFrozenPhonons.set_displacements_basis()\nFrozenPhonons.set_errortail_results()\nFrozenPhonons._fp_errortail\nFrozenPhonons.set_realspace_displacements()\nFrozenPhonons.realdisp_cs_index\nFrozenPhonons.realdisp_transformation_matrices\nFrozenPhonons.realdisp_associated_displacements\nFrozenPhonons.set_results()\nFrozenPhonons._fp_results\nLoneQ_FP\nLoneQ_FP.set_displacements()\nLoneQ_FP.set_displacements_basis()\nLoneQ_FP.set_dynamic_tensor()\nLoneQ_FP._dynamic_tensor\nLoneQ_FP.set_naive_displacements()\nLoneQ_FP.set_naive_displacements_basis()\nfind_realspace_displacements()\nfind_unique()\nformat_irrep_instances()\nformat_measurement_label()\nget_FrozenPhonons_hdf5_wrapper()\nget_LoneQ_from_hdf5()\nget_dynamic_tensor_wrapper()\nis_qpoint_real()\nload_fp_errortails()\nmake_displacement_identifier()\nsave_LoneQ_to_hdf5()\nsave_dynamic_tensor_to_hdf5()\nsave_fp_errortails()\nprincipia_materia.phonon_id.hsbid module\nHSBID\nHSBID.QpointsN\nHSBID.compute_irreducible_derivatives()\nHSBID.irreducible_derivatives\nHSBID.create_jobs()\nHSBID.derivative_order\nHSBID.find_measurements()\nHSBID.get_dynamic_tensors()\nHSBID.get_fourier_interpolation()\nHSBID.get_irreducible_derivative_names()\nHSBID.load_hsbid()\nHSBID.set_chainrule_derivatives()\nHSBID._chainrule\nHSBID.set_errortail_results()\nHSBID.set_hsbid()\nHSBID.set_results()\nfind_hierarchical_supercells()\nformat_supa_dirname()\nget_HSBID_from_hdf5()\nget_HSBID_hdf5_wrapper()\nsave_HSBID_to_hdf5()\nprincipia_materia.phonon_id.lid module\nLoneID_FP\nLoneID_FP.get_irreducible_derivative_names()\nLoneID_FP.get_irreducible_derivatives()\nLoneID_FP.irreducible_derivatives\nLoneID_FP.set_analytic_tensor()\nLoneID_FP._adt\nLoneID_FP.set_displacements()\nLoneID_FP.set_displacements_basis()\nLoneID_FP.set_dynamic_tensor()\nLoneID_FP._dynamic_tensor\nLoneID_FP.set_irreducible_derivatives()\nLoneID_FP.set_target_irrep_products()\nget_LoneID_from_hdf5()\nget_LoneID_hdf5_wrapper()\nsave_LoneID_to_hdf5()\nprincipia_materia.phonon_id.lid_mesh module\nLIDMesh\nLIDMesh.create_jobs()\nLIDMesh.get_dynamic_tensors()\nLIDMesh.get_fourier_interpolation()\nLIDMesh.get_irreducible_derivative_names()\nLIDMesh.get_irreducible_derivatives()\nLIDMesh.irreducible_derivatives\nLIDMesh.load_lid()\nLIDMesh.set_errortail_results()\nLIDMesh.set_lid()\nLIDMesh.set_results()\nget_LIDMesh_config_wrapper()\nget_LIDMesh_from_hdf5()\nget_LIDMesh_from_yaml()\nget_LIDMesh_hdf5_wrapper()\nsave_LIDMesh_to_hdf5()\nsave_LIDMesh_to_yaml()\nprincipia_materia.phonon_id.little_group_adt module\nLittleGroupADT\nLittleGroupADT.set_irreducible_derivatives()\nLittleGroupADT.set_qpoint_displacement_rep()\nget_LittleGroupADT_from_hdf5()\ninverse_qpoint()\nsave_LittleGroupADT_to_hdf5()\nprincipia_materia.phonon_id.phonon_db module\ncreate_BID_table()\ncreate_LID_table()\ncreate_metadata_table()\ncreate_strain_table()\nprincipia_materia.phonon_id.phonon_report_util module\nsummarize_bid()\nsummarize_hsbid()\nsummarize_lid()\nsummarize_lid_mesh()\nsummarize_structure()\nprincipia_materia.phonon_id.phonon_tools module\nadjust_eigenvectors_subspace()\ncompute_eigenvalues()\ncompute_phonon_frequencies_from_eigenvalues()\ncompute_phonons()\nfind_degenerate_frequencies()\nget_mass_matrix()\nmultiply_mass_matrix()\nprincipia_materia.phonon_id.strained_finite_displacements module\nStrainedFiniteDisplacements\nStrainedFiniteDisplacements.create_jobs()\nStrainedFiniteDisplacements.delta\nStrainedFiniteDisplacements.get_jobname\nStrainedFiniteDisplacements.order\nStrainedFiniteDisplacements.set_delta()\nStrainedFiniteDisplacements.set_displacement_vectors()\nStrainedFiniteDisplacements.set_finite_difference()\nStrainedFiniteDisplacements.set_jobname_template()\nStrainedFiniteDisplacements.set_jobs()\nStrainedFiniteDisplacements.set_strain()\nStrainedFiniteDisplacements.set_strain_delta()\nStrainedFiniteDisplacements.set_strain_internal_displacements()\nStrainedFiniteDisplacements.strain_delta\nStrainedFiniteDisplacements.uniq_strains\nget_StrainedFD_from_configuration()\nget_strain_fd_config_hdf5_wrapper()\nget_strain_fd_config_yaml_wrapper()\nsave_StrainedFD_config_to_hdf5()\nsave_StrainedFD_config_to_yaml()\nModule contents ","categories":"","description":"Module principia_materia.phonon_id\n","excerpt":"Module principia_materia.phonon_id\n","ref":"/docs/references/principia_materia.phonon_id.html","tags":"","title":"Module principia_materia.phonon_id"},{"body":"principia_materia.phonon_id.analytic_dynamic_tensor module class principia_materia.phonon_id.analytic_dynamic_tensor.AnalyticDynamicTensor(structure, pg, Qpoint, tol=1e-06) Bases: object\nAbstract class for analytic representation of dynamic tensor under group theory.\nExploits the group theory to find the irreducible derivatives, and construct the dynamic tensor analytically in both symmetrized basis and naive basis. The analytic form of the dynamic tensor is stored in a vectorized form to facilitate further computation.\nThe analytic tensor allows us to perform further analysis of the dynamics and thermodynamics of the crystal.\nParameters\nstructure (CrystalFTG object or a structure file of CrystalFTG) – The crystal structure.\npg (str or PointGroup object) – The point group.\nQpoint (array of Fraction or a parse_array supported Fraction array.) – The Q-point\ntol (float, optional, default to 1.0E-6) – Error tolerence.\nproperty Qpoint() compute_tensor(irreducible_derivatives, symmetrized_basis=False) Substute irreducible derivatives into vectorized tensor to compute dynamic tensor.\nParameters\nirreducible_derivatives (array of complex, shape(self.n_irreducible_derivatives, )) – The value of irreducible derivatives to substitute in.\nsymmetrized_basis (bool, optional, default to False) – Whether to return the tensor in symmetrized basis or in naive basis.\nReturns\ntensor – The resulting dynamic tensor after the substitution. If symmetrized_basis==True, shape equals self.symmetrized_tensor_shape, If symmetrized_basis==False, shape equals self.tensor_shape.\nReturn type\narray of complex\nget_irreducible_basis_rowname(qpoint) Get the list of names of the rows for the irreducible basis\nParameters\nqpoint (array of Fraction, shape(dim, )) – A q-point of the Q-point that is being studied.\nget_irreps(qpoint) Get the list of irreducible representations and it’s instance number of a q-point.\nParameters\nqpoint (array of Fraction, shape(dim, )) – A q-point of the Q-point that is being studied.\nget_rotation_matrix(qpoint) Get the rotation matrix from symmetrized basis to naive basis of a q-point within the Q-point.\nParameters\nqpoint (array of Fraction, shape(dim, )) – A q-point of the Q-point that is being studied.\nproperty irreducible_derivative_names() The list of names of of all irreducible derivatives in the tensor, also reference for the vectorized tensors.\nproperty n_irreducible_derivatives() Number of irreducible derivatives\nproperty order() The order of the irreducible derivatives.\nproperty qpoint_displacement_rep() set_irreducible_derivative_names(irreducible_derivative_names, allow_missing=False) Set the irreducible derivatives names.\nParameters\nirreducible_derivative_names (list of tuples) – The names of irreducible derivatives.\nabstract set_irreducible_derivatives() Constructs irreducible derivatives as well as the coefficients for them in the symmetrized basis.\nabstract set_qpoint_displacement_rep() Find all irreducible derivatives allowed in the given Qpoint and PointGroup.\nset_vectorized_tensor(allow_missing=False) Constructed vectorized tensor from computed irreducible derivatives.\nsolve_irreducible_derivatives(dynamic_tensor, symmetrized_basis=False, tol=None) Solve for irreducible derivatives from the numerical tensor.\nParameters\ndynamic_tensor (array of complex) – The numerical dynamic tensor to solve irreducible derivatives with. If symmetrized_basis==True, dynamic_tensor.shape == self.symmetrized_tensor_shape, If symmetrized_basis==False, dynamic_tensor.shape == self.tensor_shape.\nsymmetrized_basis (bool, optional, default to False) – If True, the input dynamic_tensor is in symmetrized basis, if False, the input is in naive basis.\ntol (float, optional, default to None) – Error tolerance, if None, use self.tol.\nReturns\nirreducible_derivatives (array of complex, shape(self.n_irreducible_derivatives, )) – The least square result of the irreducible derivatives.\nresidues (float) – The residues of the least square.\nrank (int) – The rank of the reshaped analytic tensor, which equals the number of irreducible derivatives.\ns (array of complex) – Singular values of the reshaped analytic tensor.\nproperty symmetrized_tensor_shape() The shape of the dynamic tensor in symmetrized basis.\nproperty symmetrized_vectorized_tensor() Vectorized analytic dynamic tensor in symmetrized basis.\nproperty tensor_shape() The shape of the dynamic tensor in naive basis.\nproperty unique_qpoints() Unique q-points in the Q-point.\nproperty vectorized_tensor() Vectorized analytic dynamic tensor in naive basis.\nprincipia_materia.phonon_id.analytic_dynamic_tensor.get_AnalyticDynamicTensor_hdf5_wrapper() HDF5 data wrapper for AnalyticDynamicTensor class.\nprincipia_materia.phonon_id.analytic_dynamic_tensor.get_IrreducibleDerivatives_hdf5_wrapper() HDF5 data wrapper for irreducible derivatives.\n","categories":"","description":"Module principia_materia.phonon_id.analytic_dynamic_tensor\n","excerpt":"Module principia_materia.phonon_id.analytic_dynamic_tensor\n","ref":"/docs/references/principia_materia.phonon_id.analytic_dynamic_tensor.html","tags":"","title":"Module principia_materia.phonon_id.analytic_dynamic_tensor"},{"body":"principia_materia.phonon_id.analytic_strain_tensor module class principia_materia.phonon_id.analytic_strain_tensor.AnalyticStrainTensor(order, pg, dim=3, tol=1e-06) Bases: object\ncompute_tensor(irreducible_derivatives, symmetrized_basis=False) Substute irreducible derivatives into vectorized tensor to compute strain tensor.\nParameters\nirreducible_derivatives (array of complex, shape(self.n_irreducible_derivatives, )) – The value of irreducible derivatives to substitute in.\nsymmetrized_basis (bool, optional, default to False) – Whether to return the tensor in symmetrized basis or in naive basis.\nReturns\ntensor – The resulting strain tensor after the substitution. If symmetrized_basis==True, shape equals self.symmetrized_tensor_shape, If symmetrized_basis==False, shape equals self.tensor_shape.\nReturn type\narray of complex\nget_irreducible_basis_rowname() Get the list of names of the rows for the irreducible basis\nget_irreps() Get the list of irreducible representations and it’s instance number of the strain rep.\nget_rotation_matrix() Get the rotation matrix from symmetrized basis to naive basis of strain rep.\nproperty identity_subspace() property irreducible_derivative_names() The list of names of of all irreducible derivatives in the tensor, also reference for the vectorized tensors.\nproperty irreducible_strains() property n_irreducible_derivatives() Number of irreducible derivatives\nset_irreducible_derivative_names(irreducible_derivative_names) Set the irreducible derivatives names.\nParameters\nirreducible_derivative_names (list of tuples) – The names of irreducible derivatives.\nset_irreducible_derivatives(use_int_irrvec=False) The irreducible derivatives is constructued as well as the coefficients for them in the symmetrized basis.\nset_irreducible_strains() set_strain_rep() set_vectorized_tensor() Constructed vectorized tensor from computed irreducible derivatives.\nsolve_irreducible_derivatives(strain_tensor, symmetrized_basis=False, tol=None) Solve for irreducible derivatives from the numerical tensor.\nParameters\nstrain_tensor (array of complex) – The numerical strain tensor to solve irreducible derivatives with. If symmetrized_basis==True, strain_tensor.shape == self.symmetrized_tensor_shape, If symmetrized_basis==False, strain_tensor.shape == self.tensor_shape.\nsymmetrized_basis (bool, optional, default to False) – If True, the input strain_tensor is in symmetrized basis, if False, the input is in naive basis.\ntol (float, optional, default to None) – Error tolerance, if None, use self.tol.\nReturns\nirreducible_derivatives (array of complex, shape(self.n_irreducible_derivatives, )) – The least square result of the irreducible derivatives.\nresidues (float) – The residues of the least square.\nrank (int) – The rank of the reshaped analytic tensor, which equals the number of irreducible derivatives.\ns (array of complex) – Singular values of the reshaped analytic tensor.\nproperty symmetrized_tensor_shape() The shape of the strain tensor in symmetrized basis.\nproperty symmetrized_vectorized_tensor() Vectorized analytic strain tensor in symmetrized basis.\nproperty tensor_shape() The shape of the strain tensor in naive basis.\nproperty vectorized_tensor() Vectorized analytic strain tensor in naive basis.\n","categories":"","description":"Module principia_materia.phonon_id.analytic_strain_tensor\n","excerpt":"Module principia_materia.phonon_id.analytic_strain_tensor\n","ref":"/docs/references/principia_materia.phonon_id.analytic_strain_tensor.html","tags":"","title":"Module principia_materia.phonon_id.analytic_strain_tensor"},{"body":"principia_materia.phonon_id.analytic_tensors module class principia_materia.phonon_id.analytic_tensors.AnalyticTensors(structure, supa, order, pg=‘C1’, tol=1e-06) Bases: DynamicTensors\nAnalytic dynamic tensor of a reciprocal mesh at a given order.\nParameters\nstructure (CrystalFTG object or a structure file of CrystalFTG) – The crystal structure.\nsupa (array of int, shape(dim, dim)) – The supercell matrix.\norder (int) – Order of the dynamic tensor.\npg (str or PointGroup object) – The point group.\ntol (float, optional, default to 1.0E-6) – Error tolerence.\ncompute_D_from_ID(irreducible_derivatives) Compute D by substituting in irreducible derivatives.\nParameters\nirreducible_derivatives (array of complex, shape(n_irreducible_derivatives, )) – The values of the irreducible derivatives.\ncompute_ID_from_D(dynamic_tensors) Compute irreducible derivatives from dynamic tensors.\nParameters\ndynamic_tensors (array of complex, shape(len(self._D), norbitals, …, norbitals)) – The dynamic tensors to compute irreducible derivatives from.\ncopy() Make a copy\nReturns\nnew – A copy of AnalyticTensors object.\nReturn type\nAnalyticTensors\nproperty irreducible_derivative_names() List of names of irreducible derivatives.\nproperty n_irreducible_derivatives() Number of irreducible derivatives.\nset_ADT(full_symmetry=False, conjugate=False, verbose=False) Construct analytic dynamic tensors of the irreducible Q-points.\nConstruct analytic dynamic tensor of the irreducible Q-points, collect all irreducible derivatives in a list, and vectorize all the analytic tensors in the irreducible zone with respect to the irreducible derivatives list.\nParameters\nfull_symmetry (bool, optional, default to False) – If True use full symmetry approach to find the irreducible derivatives; If False use little group approach instead.\nverbose (bool, optional, default to False) – Whether to print out steps verbally.\nset_D(Qpoints, D) Set vectorized dynamic tensors.\nset_irreducible_D(D) Set vectorized dynamic tensors for irreducible Q-points.\nprincipia_materia.phonon_id.analytic_tensors.get_AnalyticTensors_from_hdf5(h5file, tol=1e-06) Load AnalyticTensors from HDF5 file.\nprincipia_materia.phonon_id.analytic_tensors.get_AnalyticTensors_hdf5_wrapper() HDF5 data wrapper for AnalyticTensors class.\nprincipia_materia.phonon_id.analytic_tensors.save_AnalyticTensors_to_hdf5(obj, h5file=‘analytic_tensors.hdf5’, overwrite=False) Save AnalyticTensors data into HDF5 file.\nParameters\nobj (AnalyticTensors) – A AnalyticTensors object.\nh5file (str or h5py.File/h5py.Group obejct, optional, default to “dynamic_tensors.hdf5”) – Path to a HDF5 file or a h5py.File/h5py.Group object.\noverwrite (bool, optional, default to False) – When the file exists, whether to replace the content of the file with the content to be saved.\n","categories":"","description":"Module principia_materia.phonon_id.analytic_tensors\n","excerpt":"Module principia_materia.phonon_id.analytic_tensors\n","ref":"/docs/references/principia_materia.phonon_id.analytic_tensors.html","tags":"","title":"Module principia_materia.phonon_id.analytic_tensors"},{"body":"principia_materia.phonon_id.anharmonic_interpolation module class principia_materia.phonon_id.anharmonic_interpolation.AnharmincInterpolation(structure, tol=1e-06) Bases: object\nInterpolation of anharmonic phonon interaction coefficients.\nThis class will store PhiN of arbitrary order together and perform interpolation to arbitrary Q. And generate phonon interaction tensors in desired conventen \u0026 basis.\nanalytic_derivative_dynamic_matrix(Qpoints) Analytical derivatives of the dynamical matrices wrt Q-points.\nThe short range part is calculated as as following.\n$$ \\frac{\\partial\\hat D_{\\mathbf{K}}}{\\partial K_\\alpha} = \\sum_{\\mathbf{y}} \\imag T_\\alpha e^{\\imag \\mathbf{K} \\cdot \\mathbf{y}\\hat a} \\hat \\Phi_{\\mathbf{y}} $$\nproperty existing_orders() fd_derivative_dynamic_matrix(qpoints, amplitute=1e-05) Derivative dynamic matrix using central finite difference method.\nget_Dq2(qpoints) Get second order dynamic matrices of input q-points.\nParameters\nqpoints (array of float or Fraction, shape(dim, ) or (1, dim) or (N, 1, dim)) – q-points to to compute dynamic matrices. The hidden q-points will be prepended, and Fourier transform will be executed.\nget_DqN(Qpoints, order) Get the DqN tensor of a given q at a given order.\nget_Phi(order) Get the PhiN of a given order.\nget_phonons(qpoints, return_eigenvectors=True, units=‘THz’) group_velocity(qpoints, fd=False, amplitute=1e-05, tol=1e-05, units=‘THz’) Compute group velocity using either the analytic derivative or CFD.\nParameters\nqpoints (array of floats, shape(N, 3) or coordinate parse compatible format.) – Qpoints to evaluate group velocity at.\namplitute (float) – Displacement amplitute on qpoints.\ntol (float) – Tolerance.\nunits (str) – Unit of phonon frequencies.\nReturns\ngv – Group velocity.\nReturn type\narray of float, shape(len(qpoints), norbitals, 3)\nheat_capacity(qpoints, temperature, phonon_units=‘eV’, phonon_cutoff=None, tol=0.0001) Mode heat capacity at given q-points and temperature.\nParameters\nqpoints (array of float, shape(nqpoints, 3)) – q-points to evaulate the mode heat capacity\ntemperature (float or array of float, shape(ntemp)) – temperature to evaulate the mode heat capacity\nReturns\ncv – Mode heat capacity in units of eV/K.\nReturn type\narray of float, shape(nqpoints, ntemp, norbitals)\nset_Phi(Phi, order) Add a Phi of a given order.\nset_dipole(epsilon, q_direction=None) set_q_direction(q_direction=None) principia_materia.phonon_id.anharmonic_interpolation.mode_heat_capacuty(frequencies, temperature, phonon_units=‘THz’, phonon_cutoff=None, tol=0.0001) Compute mode heat capacity from phonon freuqencies.\nParameters\nfrequencies (array of float, shape(nqpoints, norbitals)) –\ntemperature (float or array of float, shape(ntemp)) –\nReturns\ncv\nReturn type\narray of float, shape(nqpoints, ntemp, norbitals)\n","categories":"","description":"Module principia_materia.phonon_id.anharmonic_interpolation\n","excerpt":"Module principia_materia.phonon_id.anharmonic_interpolation\n","ref":"/docs/references/principia_materia.phonon_id.anharmonic_interpolation.html","tags":"","title":"Module principia_materia.phonon_id.anharmonic_interpolation"},{"body":"principia_materia.phonon_id.bid module class principia_materia.phonon_id.bid.BID(structure, supa, order, pg=‘C1’, full_symmetry=False, hidden_order=1, fdtype=‘c’, tol=1e-06) Bases: object\nUse Bundled Irreducible Derivatives approach to compute phonons and their interactions.\nParameters\nstructure (CrystalFTG object or a structure file of CrystalFTG) – The crystal structure.\nsupa (array of int, shape(dim, dim)) – The supercell matrix.\norder (int) – Order of the phonon interaction.\npg (str or PointGroup object, optional, default to “C1”) – The point group.\nfull_symmetry (bool, optional, default to False) – If True, use full group analysis (not implemented yet). If False, use little group analysis.\nhidden_order (int, optional, default to 1) – The order of derivatives from first principles.\nfdtype (str, choice of [“c”, “f”, “b”]) – Type of finite displacement.\ntol (float, optional, default to 1.0E-6) – Error tolerence.\ncompute_irreducible_derivatives(known_ID=[]) Compute irreducible derivatives with finite displacements result and chainrule matrices/tensors.\nParameters\nknown_ID (array of complex, shape(len(self._chainrule._known_ID_index), )) – The values of the known irreducible derivatives.\nirreducible_derivatives() The values of all irreducible derivatives in the current system.\nType\narray of complex shape(n_irreducible_derivatives, )\ncreate_jobs(job_handler, deltas, prefix=None, delta_format=, measurement_label=, jobname_prefix=’’, config_file=‘finite_displacements.yml’, append=False, dry_run=False) Create compute jobs for the BID calculations.\nThe displacement amplitudes applied to the crystal follow the convention discussed in the paper Phys. Rev. B 100, 014303 (2019).\n$$ u_{\\textbf{t}}*{\\left(b, \\beta\\right)} = \\sum_{\\textbf{q} \\in \\hat{S}_{BZ}} u_{\\textbf{q}}*{\\left(b, \\beta\\right)} e^{2\\pi\\imag \\textbf{t} \\cdot \\textbf{q}} $$\nParameters\njob_handler (ComputeJobSeries or JobsDB) – Either a ComputeJobSeries or a JobsDB object as the interface to the jobs.\ndeltas (list of numbers, list of arrays, 1-d or 2-d array) – Displacement amplitude. Can take following types:\n1. a number, will be broadcast into a shape(n_measurements, 1) array. 2. an 1-d array of length N, will be broadcast into a shape(n_measurements, N) array. 3. a 2-d array of shape(n_measurements, N). prefix (str, optional, default to None) – Prefix to the jobnames.\ndelta_format (callable, optional, default to function: format_delta_dirname.) – A function that format a delta into a string for directory name. Must be in form of def function(delta, ...): ....\nmeasurement_label (callable, optional, default to format_measurement_label) – A function that format the measurement indices into certain string format. Must be in form of def function(measurement_index, …): …\njobname_prefix (str) – Prefix for jobnames.\nconfig_file (str, optional, default to “finite_displacements.yml”) – The name of the finite displacements configuration file.\ndry_run (bool, optional, default to False) – If True, don’t actually create the job.\nproperty derivative_order() The order of the finite displacements derivative.\nfind_measurements(extra_measurements=0, test_measurements=5, verbose=False, max_search=20) Find measurements that can solve the chainrule matrix.\nThe steps are as follows:\nFind the number of unknown irreducible derivatives. With test_measurements test measurements, find the maximum rank a single displacement can provide. Assume the initial number of measurement as ceil(n_unknowns/single_measurement_rank). If extra_measurements is none zero, multiply n_measurements by extra_measurements + 1. Start with trying out several sets of n_measurements measurements to see if the chainrule matrices/tensors can reach condition rank==n_unknowns. If above condition can’t be met after several (5) attemps, increase n_measurements by 1 and repeat step 5-6, until the condition is reached. However, after too many failed attempts (20), the code will quit and throw an error saying the measurements can’t be found. Parameters\nextra_measurements (int, optional, default to 0) – The amount of extra measurement, the new number of measurement is calculated with the equation: n_measurements \\*= extra_measurements + 1.\ntest_measurements (int, optional, default to 5) – The number of test measurements.\nverbose (bool, optional, default to False) – Verbosity.\nmax_search (int, optional, default to 20) – Number of attempts to search for the measurements.\nget_dynamic_tensors() Compute dynamic tensors of the irreducible Q-points from irreducible derivatives.\nReturns\ndynamic_tensors – (where N_IQ is the number of irreducible Q-points) The dynamic tensors of the irreducible Q-points.\nReturn type\narray of complex, shape(N_IQ, ) + (norbitals, ) * order\nget_fourier_interpolation() Construct the FourierInterpolation object from dynamic tensors of irreducible Q-points.\nReturns\nfourier_interpolation – A FourierInterpolation object.\nReturn type\nFourierInterpolation\nget_irreducible_derivative_names() set_chainrule_derivatives(verbose=False) Instantiate the ChainruleDerivatives class to compute chainrule matrices/tensors.\nParameters\nverbose (bool, optional, default to False) – Whether to print out the analysis steps in the construction of the ChainruleDerivatives object.\n_chainrule() The ChainruleDerivatives object for the system.\nType\nChainruleDerivatives\nset_chainrule_matrix() Compute chainrule matrices/tensors for the set measurements.\nset_errortail_results(pick_min=3, pick_max=None, consecutive=False, penalty=, separate_complex=True, output=None, overwrite=True) Compute error tail for the BID finite displacements result.\nParameters\npick_min (int, optional, default to 3) – The minimum number of picks for delta selection.\npick_max (int, optional, default to None) – The maximum number of picks for delta selection. If None, the pick n scheme is used with n=pick_min. If not None, the pick N schcme is used with N=[pick_min, pick_max].\nconsecutive (bool, optional, default to False) – Whether to pick consecutive deltas in the picking process.\npenalty (callable, optional, default to penalty_linear_mse) – The penalty function to determine the best fit.\nseparate_complex (bool, optional, default to False) – Whether to fit real and imaginary part of the complex data points separetely.\noutput (str, optional, default to None) – Path of the output file. If not None, save the output of errortail fit to the file.\n_fd_errortail() The errortail extrapolated finite displacements results of the BID finite displacements calculations.\nType\narray of complex\nset_measurements(measurements) Set measurements, normalize them and compute chainrule matrices/tensor for them.\nset_results(job_handler, data_type, prefix=None, config_file=‘finite_displacements.yml’) Get finite displacements results from calculations.\nParameters\njob_handler (ComputeJobSeries or JobsDB) – Either a ComputeJobSeries or a JobsDB object as the interface to the jobs.\ndata_type (str, choices of “forces” and “energy”) – Type of data to read from compute jobs.\nconfig_file (str, optional, default to “finite_displacements.yml”) – The name of the finite displacements configuration file.\n_fd_results() The result of the finite displacements calculations.\nType\nlist of arrays of complex, length of number of measurements\nclass principia_materia.phonon_id.bid.DisplacementGenerator(shape, decimals=8) Bases: object\nDisplacement vector generator.\nThe algorithm of this displacement generator is described in the paper.\nParameters\nshape (tuple of integers) – Shape of the displacement.\ndecimals (interger) – The decimal points to round up the displacement vector.\nastep() astep_one() property n() next() reset() class principia_materia.phonon_id.bid.RandomDisplacementGenerator(shape, decimals=8) Bases: object\nRandom number displacement vector generator.\nGenerate displacement vectors with purely random numbers.\nParameters\nshape (tuple of integers) – Shape of the displacement.\ndecimals (interger) – The decimal points to round up the displacement vector.\nnext() reset() principia_materia.phonon_id.bid.format_measurement_label(measurement_index, zero_padding=0) Format measurement indices into str labels.\nParameters\nmeasurement_index (int) – The index of the measurement.\nzero_padding (int, optional, default to 0) – The amount of zero padding on the left of the measurement indices.\nReturns\nlabel – The label for the measurement.\nReturn type\nstr\nprincipia_materia.phonon_id.bid.get_BID_from_hdf5(h5file, tol=1e-06) Read data from HDF5 file and construct a BID object.\nParameters\nh5file (str or h5py.File/h5py.Group obejct) – Path to a HDF5 file or a h5py.File/h5py.Group object.\ntol (float, optional, default to 1.0E-6) – Error tolerance.\nprincipia_materia.phonon_id.bid.get_BID_hdf5_wrapper() HDF5 data wrapper for BID class.\nprincipia_materia.phonon_id.bid.save_BID_to_hdf5(obj, h5file=‘bid.hdf5’, overwrite=False) Save data of a BID object into a HDF5 file.\nParameters\nobj (BID) – A BID object.\nh5file (str or h5py.File/h5py.Group obejct, optional, default to “bid.hdf5”) – Path to a HDF5 file or a h5py.File/h5py.Group object.\nprincipia_materia.phonon_id.bid.save_bid_errortails(output, fdtype, deltas, fd_values, result, xcoef, pick, penalty, overwrite=True) Save errortail data of frozen phonon runs into HDF5 file.\n","categories":"","description":"Module principia_materia.phonon_id.bid\n","excerpt":"Module principia_materia.phonon_id.bid\n","ref":"/docs/references/principia_materia.phonon_id.bid.html","tags":"","title":"Module principia_materia.phonon_id.bid"},{"body":"principia_materia.phonon_id.chainrule_derivatives module class principia_materia.phonon_id.chainrule_derivatives.ChainruleDerivatives(structure, supa, order, pg=‘C1’, use_symmetric_basis=False, tol=1e-06) Bases: AnalyticTensors\nCompute chainrule derivatives of a measurement for a given crystal system at given FTG and order.\nIn bundled irreducible derivatives (BID) method, for a given measurement basis, at a given order, structure and supercell, we can obtain a series of derivatives from finite displacement computations, referred to as $\\textbf{V}_{b}^{\\hat{S}_{BZ}}$, where $\\hat{S}_{BZ}$ is the supercell matrix.\nThese measurement basis derivatives are linear combinations of irreducible derivatives in this system,\n$$ \\textbf{V}_{b}^{\\hat{S}_{BZ}} = \\hat{C}_b^{\\hat{S}_{BZ}} \\textbf{d}_{ir}^{\\hat{S}_{BZ}} $$ , where $\\hat{C}_b^{\\hat{S}_{BZ}}$ is the chainrule matrix, and $\\textbf{d}_{ir}^{\\hat{S}_{BZ}}$ is the vector of irreducible derivatives. This chainrule matrix is what we are aiming to find in this class, such linear combinations $\\hat{C}_b^{\\hat{S}_{BZ}}$ can be calculated using chain rule derivatives. With the chainrule matrix and measurement basis derivatives, we can solve for irreducible derivatives.\nAdditionally, in hierarchical supercell BID method, at a given supercell, the irreducible derivatives that fit in smaller supercells are already computed. Thus we can split the chainrule matrix into 2 parts: a known part and an unknown part, where the task at hand is to solve the unknown part for the irreducible derivatives.\n$$ \\textbf{V}_{b}^{\\hat{S}_{BZ}} - \\hat{C}_{b,known}^{\\hat{S}_{BZ}} \\textbf{d}_{ir,known}^{\\hat{S}_{BZ}} = \\hat{C}_{b,unknown}^{\\hat{S}_{BZ}} \\textbf{d}_{ir,unknown}^{\\hat{S}_{BZ}} $$\nParameters\nstructure (CrystalFTG object or a structure file of CrystalFTG) – The crystal structure.\nsupa (array of int, shape(dim, dim)) – The supercell matrix.\norder (int) – Order of the dynamic tensor.\npg (str or PointGroup object) – The point group.\nuse_symmetric_basis (bool, optional, default to False) – Whether to use the symmetric basis or the naive basis for the hidden orders of the chainrule matrix.\ntol (float, optional, default to 1.0E-6) – Error tolerence.\nadd_known_ID(known_ID) Mark irreducible derivatives as know ID.\nParameters\nknown_ID (list of nested tuples) – Irreducible derivaties to be marked as known.\nproperty basis_names() property basis_vectors() compute_chainrule(displacements, hidden_order=1) Compute chainrule matrices/tensors that converts between irreducible derivatives and the measurement basis derivatives.\nFor a single measurement.\n$$ C_Q(u_1, \\cdots, u_{O_{h}}) = \\frac{1}{\\left(O-O_{h}\\right)!} \\sum_{u_{O_{h} + 1}, \\cdots, u_{O}} D_{Q}^{O}[u_{O_{h} + 1}, \\cdots, u_{O}] \\prod_{i=O_{h} + 1}^{O} \\frac{\\partial u_i}{\\partial v_i} $$ where $O$ is order, $O_{h}$ is the hidden order, $u$ is q-space displacement basis, $v$ is the measurement bases at otrder $O$, $V$ is the $u_0$ line of the chainrule matrix, and $D_Q^{O}$ is the tensor vector of $Q$.\nParameters\ndisplacements (array of floats, shape(N, order - hidden_order, natoms, dim) or (order - hidden_order, natoms, dim)) – Measurement basis displacements, can be 1 set of measurement or multiple measurements at the same time.\nhidden_order (int, optional, default to 1) – The order of derivatives from first principles calculation.\nReturns\nchainrule_tensor – The chainrule matrix in a tensor form. If the input displacements shape is (order - hidden_order, natoms, dim), return value will be in shape (n_QpointsN, norbitals) * hidden_order + (n_irreducible_derivatives, ).\nReturn type\narray of complex, shape(N, ) + (n_QpointsN, norbitals) * hidden_order + (n_irreducible_derivatives, )\ndecompose_displacements(displacements) Decompose the displacements in real space into reciprocal space.\nParameters\ndisplacements (array of float, shape (n, ) + self.displacement_shape) – A measurement, which consists of several displacements.\nproperty displacement_shape() Shape of a single displacement.\nA measurement basis usually consists of several displacements.\nget_chainrule_factors(measurement, hidden_order=1) Compute chainrule factor of a measurement.\nParameters\nmeasurement (array of float, shape(order - hidden_order, supercell.natoms, dim)) – A set of displacement to displace the system.\nhidden_order (int, optional, default to 1) – The order of derivatives from first principles.\nReturns\ndecomp_measurement – The chainrule factors.\nReturn type\narray of complex, shape(order - hidden_order, multiplicity, norbitals)\nproperty known_ID() Names of known irreducible derivatives.\nproperty nonzero_ID_index() normalize_displacements(displacements) Normalize a measurement in reciprocal space.\nThe normalization makes the reciprocal space decomposition of the displacements to 1.\nParameters\ndisplacements (array of float, shape (n, ) + self.displacement_shape) – A measurement, which consists of several displacements.\nset_basis() Compute all the reciprocal displacement basis that fit in the supercell.\nset_naive_basis() Compute all the naive reciprocal displacement basis that fit in the supercell.\nset_symmetric_basis() Compute all the symmetric reciprocal displacement basis that fit in the supercell.\nproperty unknown_ID() Names of unknown irreducible derivatives.\nprincipia_materia.phonon_id.chainrule_derivatives.get_ChainruleDerivatives_from_hdf5(h5file, tol=1e-06) Load ChainruleDerivatives from HDF5 file.\nprincipia_materia.phonon_id.chainrule_derivatives.get_ChainruleDerivatives_hdf5_wrapper() HDF5 data wrapper for ChainruleDerivatives class.\nprincipia_materia.phonon_id.chainrule_derivatives.save_ChainruleDerivatives_to_hdf5(obj, h5file=‘analytic_tensors.hdf5’, overwrite=False) Save ChainruleDerivatives data into HDF5 file.\nParameters\nobj (ChainruleDerivatives) – A ChainruleDerivatives object.\nh5file (str or h5py.File/h5py.Group obejct, optional, default to “dynamic_tensors.hdf5”) – Path to a HDF5 file or a h5py.File/h5py.Group object.\noverwrite (bool, optional, default to False) – When the file exists, whether to replace the content of the file with the content to be saved.\n","categories":"","description":"Module principia_materia.phonon_id.chainrule_derivatives\n","excerpt":"Module principia_materia.phonon_id.chainrule_derivatives\n","ref":"/docs/references/principia_materia.phonon_id.chainrule_derivatives.html","tags":"","title":"Module principia_materia.phonon_id.chainrule_derivatives"},{"body":"principia_materia.phonon_id.conductivity module class principia_materia.phonon_id.conductivity.Conductivity(structure, mesh, pg, tol=1e-06) Bases: object\nCalculate thermal conductivity\ngamma_tetra(qpoint, temperature, frequencies, phonon_units=‘THz’, units=‘THz’, phonon_cutoff=None, tol=1e-06, high_temp_limit=False) Use the tetrahedron method to calculate the imaginary self energy (ISE).\nThis version is mostly implemented in fortran.\nParameters\nqpoint (array of float or Fraction, shape(3, ); or coordinate_parse compatible format) – The Q-vector to calculate ISE.\ntemperature (float of array of float, shape(ntemp, )) – The temperature(s) to calculate ISE.\nfrequencies (array of float, shape(nbin, )) – The frequencies to evaluate ISE at.\nphonon_units (str, default “THz”, optional) – The unit of phonon frequencies.\nunits (str, default “THz”, optional) – The unit of ISE.\nphonon_cutoff (None or float, default None, optional) – The phonon cutoff frequencies, all frequencies below cutoff are replaced with the value of cutoff. If omitted, the value of tol is used.\ntol (float, default 1.0E-6, optional) – The error tolerence.\nReturns\ngammas – The ISE of given q at all given temperatures at each frequencies.\nReturn type\narray of float, shape(ntemp, nbin, self.structure.norbitals)\ngamma_tetra_at_phonon(qpoint, temperature, phonon_units=‘THz’, units=‘THz’, tol=1e-06, phonon_cutoff=None, high_temp_limit=False) Calculate imaginary self energy at the phonon frequencies at the given q.\nParameters\nqpoint (array of float or Fraction, shape(3, ); or coordinate_parse compatible format) – The Q-vector to calculate ISE.\ntemperature (float of array of float, shape(ntemp, )) – The temperature(s) to calculate ISE.\nphonon_units (str, default “THz”, optional) – The unit of phonon frequencies.\nunits (str, default “THz”, optional) – The unit of ISE.\nphonon_cutoff (None or float, default None, optional) – The phonon cutoff frequencies, all frequencies below cutoff are replaced with the value of cutoff. If omitted, the value of tol is used.\ntol (float, default 1.0E-6, optional) – The error tolerence.\nReturns\ngammas – The ISE of given q at all given temperatures.\nReturn type\narray of float, shape(ntemp, self.structure.norbitals)\ngamma_tetra_grid(temperature, frequencies=None, grid_qvecs=None, phonon_units=‘THz’, units=‘THz’, debug=False, phonon_cutoff=None, tol=1e-06, return_phonon=False, return_eigenvectors=False) Use the tetrahedron method to calculate the imaginary self energy.\nThis version is set to take advantage of the grid and calculate ISE of the grid.\nParameters\ntemperature (float of array of float, shape(ntemp, )) – The temperature(s) to calculate ISE.\nfrequencies (array of float, shape(nbin, )) – The frequencies to evaluate ISE at.\ngrid_qves (array of float or Fraction, shape(3, ) or shape(N, 3); or coordinate_parse compatible format) – A subset of Q-vectors on the grid the calculate ISE at.\nphonon_units (str, default “THz”, optional) – The unit of phonon frequencies.\nunits (str, default “THz”, optional) – The unit of ISE.\ndebug (bool, default False, optional) – A debug flag.\nphonon_cutoff (None or float, default None, optional) – The phonon cutoff frequencies, all frequencies below cutoff are replaced with the value of cutoff. If omitted, the value of tol is used.\ntol (float, default 1.0E-6, optional) – The error tolerence.\nreturn_phonon (bool, defult False, optional) – Whether to return phonon frequencies.\nreturn_eigenvectors (bool, default False, optional) – Whether to return phonon eigenvectors.\nReturns\ngammas (array of float) – (if frequencies is None: shape(N, ntemp, self.structure.norbitals)) The ISE of given q at all given temperatures.\n(if frequencies is not None: shape(N, ntemp, nbin, self.structure.norbitals))\nThe ISE of given q at all given temperatures at each frequencies.\nphonon_frequencies (array of float, shape(N, self.structure.norbitals)) – (if return_phonon == True) The phonon frequencies of Q_vectors on the grid. If grid_qvecs is not None, the phonon frequencies of the grid_qvecs will be returned.\neigenvectors (array of complex, shape(N, self.structure.norbitals, self.structure.norbitals)) – (if return_eigenvectors == True) The phonon eigenvectors of Q_vectors on the grid. If grid_qvecs is not None, the phonon eigenvectors of the grid_qvecs will be returned.\nhas_Phi_order(orders) scattering_rate_boundary(temperature, boundary, qpoints=None, phonon_cutoff=None, tol=0.0001) set_Phi(Phi, order, tol=1e-05) set_dipole(epsilon, q_direction=None) thermal_conductivity_LBTE(temperature, phonon_cutoff=None, debug=False, tol=1e-06) The implementation follows paper by Chaput, Phys. Rev. Lett. 110, 265506 (2013). It is basically identical to the paper by Fugallo, et al. Phys. Rev. B 88, 045430 (2013), apart from the latter opting to use an iterative approach instead of solving it directly.\nReturns\nkappa\nReturn type\narray of float, shape(len(qpoints), ntemp, norbitals, 3, 3)\nthermal_conductivity_RTA(temperature, qpoints=None, phonon_cutoff=None, tol=1e-06) Returns\nmode_kappa (array of float, shape(ntemp, len(qpoints), norbitals, 3, 3))\nkappa (array of float, shape(ntemp, 3, 3))\ntwo_phonon_dos(q, temperature, frequencies=None, include_phonons=False, units=‘THz’, phonon_cutoff=None, tol=1e-06) Two-phonon density of states.\nParameters\nq (array of float or Fraction, shape(3, ); or coordinate_parse compatible format) – The Q-vector to calculate ISE.\ntemperature (float of array of float, shape(ntemp, )) – The temperature(s).\nfrequencies (array of float, shape(nbin, )) – The frequencies to evaluate two-phonon DOS at.\ninclude_phonons (bool, optinoal, default to False) – Whether or not include the product of phonon frequencies in the coefficients.\nphonon_cutoff (None or float, default None, optional) – The phonon cutoff frequencies, all frequencies below cutoff are replaced with the value of cutoff. If omitted, the value of tol is used. This would also cutoff all imaginary phonons.\ntol (float, default 1.0E-6, optional) – The error tolerence.\nReturns\ntwo_phonon_dos – Two-phonon density of states of the phonon q, in 2 parts.\nReturn type\narray of float, shape(2, ntemp, len(frequencies))\nprincipia_materia.phonon_id.conductivity.bedist(freq, temperature, freq_units=‘THz’, tol=0.0001) Bose-Einstein distribution\nParameters\nfreq (float of array of float, shape(N, )) – The frequencies to evaluate Bose-Einstein distribution.\nfreq_units (str, default “THz”) – The unit of frequencies.\ntemperature (float or array of float, shape(ntemp, )) – Temperature(s) in unit of K.\ntol (float) – The tolerence for low temperature limit.\nReturns\nbedist – The Bose-Einstein distribution\nReturn type\nfloat or array of float, shape(ntemp, N)\nprincipia_materia.phonon_id.conductivity.reciprocal(arr, tol=1e-06, fill_zero=0.0) ","categories":"","description":"Module principia_materia.phonon_id.conductivity\n","excerpt":"Module principia_materia.phonon_id.conductivity\n","ref":"/docs/references/principia_materia.phonon_id.conductivity.html","tags":"","title":"Module principia_materia.phonon_id.conductivity"},{"body":"principia_materia.phonon_id.dipole_dipole module class principia_materia.phonon_id.dipole_dipole.DipoleDipole(structure, zeu=None, epsilon=None, dataset=None, G_ran=5, Lambda=0.2, factor=1.0, tol=1e-06) Bases: object\nMethod implemented is descrived in papers Phys. Rev. B 50, 13035(R) (1994) and Phys. Rev. B 55, 10355 (1997).\n$$ \\tilde{C}^{DD}_{\\kappa \\alpha \\kappa^{\\prime} \\beta} (\\textbf{q}) = \\hat{C}^{DD}_{\\kappa \\alpha \\kappa^{\\prime} \\beta} (\\textbf{q}) -\\delta_{\\kappa \\kappa^{\\prime}} \\sum_{\\kappa^{\\prime\\prime}} \\hat{C}^{DD}_{\\kappa \\alpha \\kappa^{\\prime\\prime} \\beta} (\\textbf{q}=\\bf{\\Gamma}) $$\n$$ \\hat{C}^{DD}_{\\kappa \\alpha \\kappa^{\\prime} \\beta} (\\textbf{q}) = \\sum_{\\alpha^{\\prime} \\beta^{\\prime}} Z^{\\ast}_{\\kappa, \\alpha\\alpha^{\\prime}} Z^{\\ast}_{\\kappa^{\\prime}, \\beta\\beta^{\\prime}} \\overline{C}^{DD}_{\\kappa \\alpha^{\\prime} \\kappa^{\\prime} \\beta^{\\prime}} (\\textbf{q}) $$\n$$ \\overline{C}^{DD}_{\\kappa \\alpha \\kappa^{\\prime} \\beta} (\\textbf{q}) = \\sum_{\\textbf{G} \\textrm{ with } \\textbf{K} = \\textbf{q} + \\textbf{G}} \\frac{4\\pi}{\\Omega} \\frac{K_{\\alpha}K_{\\beta}}{ \\sum_{\\gamma\\gamma^{\\prime}} K_{\\gamma}\\epsilon_{\\gamma\\gamma^{\\prime}}K_{\\gamma^{\\prime}} } e^{i \\textbf{K} \\cdot (\\tau_{\\kappa} - \\tau_{\\kappa^{\\prime}})} \\exp{\\left(-\\frac{ \\sum_{\\gamma\\gamma^{\\prime}} K_{\\gamma}\\epsilon_{\\gamma\\gamma^{\\prime}}K_{\\gamma^{\\prime}} }{4\\Lambda^2} \\right) } $$ Units:\nSince the dielectric tensor is unitless, the Born effective charges are in units of e (a.u.) and the unit of distances is in Angstroms in our convention, the unit of our dipole-dipole corrections is $\\frac{e}/{\\AA^3}$, to convert it to the unit of the force constants, we take note that $\\frac{e}{a\\_0^2}=\\frac{E\\_{hartree}}{a\\_0}$, which means $\\frac{e}{a\\_0^3}=\\frac{E\\_{hartree}}{a\\_0^2}$. Then we can convert from $\\frac{e}/{\\AA^3}$ to $\\frac{eV}{\\AA^2}$ with the factor of ~14.40. Parameters\nstructure (str or CrystalFTG instance) – Path to the CrystalFTG structure file or a CrystalFTG instance.\ndataset (str) – Path to a file that contains all the necessary data. (In the case when zeu and epsilon are absent, this dataset file is required, otherwise it is ignored. If any of optional parameters (i.e. G_ran, Lamda, factor and tol) is missing, the default value will be used.)\nzeu (array of float, shape(natoms, dim, dim)) – Born effective charge tensor.\nepsilon (array of float, shape(dim, dim)) – Dielectric constant tensor.\nG_ran (int, optional, default to 5) – Range of G vectors.\nLambda (float, optional, default to 0.20) – Lamda value in the equation.\nfactor (float, optional, default to 1.0) – Overall unit conversion factor for the output matrix.\ntol (float, optional, default to 1.0E-6) – Tolerence.\nproperty Gvecs() The reciprocal space vectors to sum over.\nc_dd(q, q_direction=None) The dipole dipole contribution term.\n$$ \\tilde{C}^{DD}_{\\kappa \\alpha \\kappa^{\\prime} \\beta} (\\textbf{q}) = \\hat{C}^{DD}_{\\kappa \\alpha \\kappa^{\\prime} \\beta} (\\textbf{q}) -\\delta_{\\kappa \\kappa^{\\prime}} \\sum_{\\kappa^{\\prime\\prime}} \\hat{C}^{DD}_{\\kappa \\alpha \\kappa^{\\prime\\prime} \\beta} (\\textbf{q}=\\bf{\\Gamma}) $$\nParameters\nq (array of Fraction or float) – The q-point.\nq_direction (array of Fraction or float, optional, default to None) – The direction of q-\u003e0 when q is the Gamma point.\nc_dd_batch(qs, q_direction=None) Compute the dipole dipole contribution term for multiple q-points at the same time in parallel.\nParameters\nqs (array of Fraction or float) – An array of q-points.\nq_direction (array of Fraction or float, optional, default to None) – The direction of q-\u003e0 when q is the Gamma point.\nproperty c_dd_q0() Compute the $C^DD(\\textbf{t}=0)$ term.\ndc_dd_G_dK(q, ideriv, use_q_direction=True) The core term of the derivative of dipole-dipole contribution with respect to the q-points in Cartesian coordinates.\nParameters\nq (array of Fraction or float) – The q-point.\nideriv (int, range(i, dim)) – The axis of the derivative.\nq_direction (array of Fraction or float, optional, default to None) – The direction of q-\u003e0 when q is the Gamma point.\ndc_dd_dK(q, ideriv, use_q_direction=None) The derivative of dipole-dipole contribution with respect to the q-points in Cartesian coordinates.\n$$ \\frac{\\partial \\tilde{C}^{DD}_{\\kappa \\alpha \\kappa^{\\prime} \\beta} (\\textbf{q})}{\\partial \\textbf{K}} $$ where $\\textbf{K}$ is the q-point $\\textbf{q}$ in Cartesian coordinates.\nParameters\nq (array of Fraction or float) – The q-point.\nideriv (int, range(i, dim)) – The axis of the derivative.\nuse_q_direction (bool, optional, default to True) – Whether to use q-direction the for derivative.\ndc_dd_dK_batch(qs, use_q_direction=True) Compute the derivative of dipole-dipole contribution with respect to the q-points in Cartesian coordinates for multiple q-points in parallel.\nParameters\nqs (array of Fraction or float) – An array of q-points.\nuse_q_direction (bool, optional, default to True) – Whether to use q-direction the for derivative.\nget_c_dd_q0() Compute the $C^DD(\\textbf{t}=0)$ term.\n$$ \\delta_{\\kappa \\kappa^{\\prime}} \\sum_{\\kappa^{\\prime\\prime}} \\hat{C}^{DD}_{\\kappa \\alpha \\kappa^{\\prime\\prime} \\beta} (\\textbf{q}=\\bf{\\Gamma}) $$\nget_valid_slice() Determined the indices to slice out base on the orbitals of the structure.\nprincipia_materia.phonon_id.dipole_dipole.get_DipoleDipole_from_yaml(inp, structure=None, tol=1e-06) principia_materia.phonon_id.dipole_dipole.get_dipole_dataset_yaml_wrapper(title=‘Dipole-dipole dataset’) principia_materia.phonon_id.dipole_dipole.save_DipoleDipole_to_yaml(obj, filename=‘epsilon.yml’, system=None, include_structure=False, overwrite=False) ","categories":"","description":"Module principia_materia.phonon_id.dipole_dipole\n","excerpt":"Module principia_materia.phonon_id.dipole_dipole\n","ref":"/docs/references/principia_materia.phonon_id.dipole_dipole.html","tags":"","title":"Module principia_materia.phonon_id.dipole_dipole"},{"body":"principia_materia.phonon_id.dynamic_tensors module class principia_materia.phonon_id.dynamic_tensors.DynamicTensors(structure, supa, order, pg=‘C1’, tol=1e-06) Bases: object\nDynamic tensors of a reciprocal mesh at arbitrary order.\nAs a fundation to many other tools, this class accommodatas dynamic tensors, can rotate them from irreducible Q-points to full BZ. For second order, it can also accounts for dipole-dipole interaction.\nInstead of a dictionary, the dynamic tensors of different Q-points are stored as an array of tensors in the same order of the Q-points designated by principia_materia.translation_group.QpointsN class. In a sense, we created a custom hash table.\nParameters\nstructure (CrystalFTG object or a structure file of CrystalFTG) – The crystal structure.\nsupa (array of int, shape(dim, dim)) – The supercell matrix.\norder (int) – Order of the dynamic tensor.\npg (str or PointGroup object) – The point group.\ntol (float, optional, default to 1.0E-6) – Error tolerence.\ncopy() Make a copy\nReturns\nnew – A copy of the object.\nReturn type\nDynamicTensors\nget_D_at_Q(Q) Get dynamic tensor at a given Q-point\nIf the stored dynamic tensors are from irreducible Q-points and Q is not in the irreducible Q-points, rotate the dynamic tensor from the corresponding irreducible Q-point to Q.\nParameters\nQ (array of Fraction, shape(order, dim)) – A Q-point.\nReturns\ndynamic_tensor – Dynamic tensor at Q-point.\nReturn type\narray of complex, shape(ndof, …, ndof) or shape(ndof, …, ndof, m)\nget_full_D() Get dynamic tensors of full BZ.\nReturns\ndynamic_tensors – Dynamic tensors of full BZ.\nReturn type\narray of complex, shape(N, ndof, …, ndof) or shape(N, ndof, …, ndof, m)\nprepend_hiden_q(Qpoints) Prepend the hidden q-point to Q-points\nFor Q-points that didn’t keep the hidden q-point, this method can prepend the q-point back. (Due to the conservation of momentum, all q-points in a Q-point need to add up equivalent to Gamma point, thus there are only order-1 linearly independent q-points in a given Q-point, and the dependent one can be omitted. The convention here is to omit the first q-point, and referred to as the hidden q-point.)\nParameters\nQpoints (array of Fraction, shape(N, order - 1, dim)) – Q-points without the hidden q-point.\nset_D(Qpoints, D) Set dynamic tensors.\nParameters\nQpoints (array of Fraction, shape(N, order - 1, dim) or shape(N, order, dim)) – Q-points either of the irreducible zone or the full BZ. Can be the full Q-points or the Q-points without the hidden q-point.\nD (array of complex, shape(N, ndof, …, ndof), shape(N, ndof, …, ndof, m)) – Dynamic tensors in the same order as the Qpoints. Can be dynamic tensors of irreducible Q-points, or of full BZ. Can be trivial dynamic tensors or vectorized tensors with the last axis being the vector axis.\nset_dipoledipole(zeu=None, epsilon=None, dataset=None, G_ran=5, Lambda=0.2, factor=1.0) For the case of second order, initialize dipole dipole contribution data.\nParameters\nzeu (array of float, shape(natoms, dim, dim)) – Born effective charge tensor.\nepsilon (array of float, shape(dim, dim)) – Dielectric constant tensor.\ndataset (str) – Path to a file that contains all the necessary data. (In the case when zeu and epsilon are absent, this dataset file is required, otherwise it is ignored. If any of optional parameters (i.e. G_ran, Lamda, factor and tol) is missing, the default value will be used.)\nG_ran (int, optional, default to 5) – Range of G vectors.\nLambda (float, optional, default to 0.20) – Lamda value in the equation.\nfactor (float, optional, default to 1.0) – Overall unit conversion factor for the output matrix.\nset_dipoledipole_contribution() For 2nd order, subtract the dipole-dipole contribution from the dynamic matrices.\nThis step is only supported when the stored dynamic matrices are of full BZ.\nset_irreducible_D(D) Set irreducible dynamic tensors.\nParameters\nD (array of complex, shape(N, ndof, …, ndof), shape(N, ndof, …, ndof, m)) – Dynamic tensors of irreducible Q-points. Can be trivial dynamic tensors or vectorized tensors with the last axis being the vector axis.\nprincipia_materia.phonon_id.dynamic_tensors.get_DynamicTensors_from_hdf5(h5file, tol=1e-06) Load DynamicTensors from HDF5 file.\nParameters\nh5file (str or h5py.File/h5py.Group obejct) – Path to a HDF5 file or a h5py.File/h5py.Group object.\ntol (float, optional, default to 1.0E-6) – Error tolerance to use when constructing the LittleGroupADT object.\nprincipia_materia.phonon_id.dynamic_tensors.get_DynamicTensors_hdf5_wrapper() HDF5 data wrapper for DynamicTensors class.\nprincipia_materia.phonon_id.dynamic_tensors.save_DynamicTensors_to_hdf5(obj, h5file=‘dynamic_tensors.hdf5’, overwrite=False) Save DynamicTensors data into HDF5 file.\nParameters\nobj (DynamicTensors) – A DynamicTensors object.\nh5file (str or h5py.File/h5py.Group obejct, optional, default to “dynamic_tensors.hdf5”) – Path to a HDF5 file or a h5py.File/h5py.Group object.\noverwrite (bool, optional, default to False) – When the file exists, whether to replace the content of the file with the content to be saved.\n","categories":"","description":"Module principia_materia.phonon_id.dynamic_tensors\n","excerpt":"Module principia_materia.phonon_id.dynamic_tensors\n","ref":"/docs/references/principia_materia.phonon_id.dynamic_tensors.html","tags":"","title":"Module principia_materia.phonon_id.dynamic_tensors"},{"body":"principia_materia.phonon_id.fd_series module class principia_materia.phonon_id.fd_series.FDSeries(structure, supa, order, fdtype=‘c’, tol=1e-06) Bases: object\nExecute a series of finite displacements calculations.\nIn calculations of phonons and their interactions, a seiries of finite displacements calculations from the same structure are usually needed for both BID and LID methods. This class manages a series of finite displacement calculations, and serves as a simple interface between our finite displacement engine and the phonon interaction analysis tools.\nParameters\nstructure (CrystalFTG object or a structure file of CrystalFTG) – The crystal structure.\nsupa (array of int, shape(dim, dim)) – Supercell matrix.\norder (int) – Order of the derivative.\nfdtype (str, choice of [“c”, “f”, “b”]) – Type of finite displacement.\ntol (float, optional, default to 1.0E-6) – Error tolerence.\ncreate_jobs(job_handler, prefix=None, delta_format=, jobname_prefix=’’, config_file=‘finite_displacements.yml’, append=False, skip_zero=False, dry_run=False) Create compute jobs for the finite displacements calculations.\nParameters\njob_handler (ComputeJobSeries or JobsDB) – Either a ComputeJobSeries or a JobsDB object as the interface to the jobs.\nprefix (str, optional, default to None) – Prefix to the jobnames.\ndelta_format (callable, optional, default to function: format_delta_dirname.) – A function that format a delta into a string for directory name. Must be in form of def function(delta, ...): ....\njobname_prefix (str) – Prefix for jobnames.\nconfig_file (str, optional, default to “finite_displacements.yml”) – The name of the finite displacements configuration file.\ndry_run (bool, optional, default to False) – If True, don’t actually create the job.\nproject_fd_results(basis) Project the finite displacement result onto a given bases.\nParameters\nbasis (array of float or complex, shape(N, supercell.natoms, ndim)) – An array of basis to project upon.\nReturns\nprojection – The result of finite displacements projected onto the input basis.\nReturn type\narray of float or complex, shape(n_delta, n_meas, N)\nset_deltas(deltas, append=False) Set displacement amplitudes.\nParameters\ndeltas (float or array of float) – The displacement amplitude.\nappend (bool, optional, default to False) – If True, add the input deltas to existing deltas.\nset_errortail_results(pick_min=3, pick_max=None, consecutive=False, penalty=, separate_complex=True, return_pick=False, return_penalty=False) Compute error tail for the finite displacements result.\nParameters\npick_min (int, optional, default to 3) – The minimum number of picks for delta selection.\npick_max (int, optional, default to None) – The maximum number of picks for delta selection. If None, the pick n scheme is used with n=pick_min. If not None, the pick N schcme is used with N=[pick_min, pick_max].\nconsecutive_picks (bool, optional, default to False) – Whether to pick consecutive deltas in the picking process.\npenalty (callable, optional, default to penalty_linear_mse) – The penalty function to determine the best fit.\nseparate_complex (bool, optional, default to False) – Whether to fit real and imaginary part of the complex data points separetely.\nreturn_pick (bool, optional, default to False) – Whether to return the indices of the picked points.\nreturn_penalty (bool, optional, default to False) – Whether to return the result of the penalty function.\nset_jobname_prefix(jobname_prefix=’’) set_measurement_alias(alias, alias_name) set_measurements(measurements, measurement_names=None) Set measurements vectors and their names.\nThe measurements vectors will be used to displace the structure and the names will be used as directory names that accommodates the compute jobs for the calculation.\nParameters\nmeasurements (array of numbers) – A series of measurements, each measurement consists of self.order number of displacement vectors.\nmeasurement_names (list of str) – Name of the measurement sets, used to naming the directories.\nset_results(job_handler, data_type, prefix=None, fill=0.0, skip_zero=False, config_file=‘finite_displacements.yml’) Collect computation results and compute finite displacements.\nParameters\njob_handler (ComputeJobSeries or JobsDB) – Either a ComputeJobSeries or a JobsDB object as the interface to the jobs.\ndata_type (str, choices of “forces” and “energy”) – Type of data to read from compute jobs.\nprefix (str, optional, default to None) – Prefix to the jobnames.\nconfig_file (str, optional, default to “finite_displacements.yml”) – The name of the finite displacements configuration file.\n_fd_results() The result of finite displacements calculations.\nType\narray of float, shape(n_delta, n_meas, supercell.natoms, ndim)\nprincipia_materia.phonon_id.fd_series.format_delta_dirname(delta, max_decimal=8, default_padding=4, prefix=‘delta_’, suffix=’’) Format directory name with delta\nParameters\ndelta (float) – Delta value\nmax_decimal (int, optional, default to 8) – Maximum allowed digits after decimal point, any digit after that will be rounded.\ndefault_padding (int, optional, default to 4) – Default 0 padding after the decimal point.\nprefix (str, optional, default to “delta_”) – Prefix of the name before formatted the delta value.\nsuffix (str, optional, default to “”) – Suffix of the name behind formatted the delta value,\nprincipia_materia.phonon_id.fd_series.get_FDSeries_from_hdf5(h5file, tol=1e-06) Read data from HDF5 file and construct a FDSeries object.\nParameters\nh5file (str or h5py.File/h5py.Group obejct) – Path to a HDF5 file or a h5py.File/h5py.Group object.\ntol (float, optional, default to 1.0E-6) – Error tolerance.\nprincipia_materia.phonon_id.fd_series.get_FDSeries_hdf5_wrapper() HDF5 data wrapper for FDSeries class.\nprincipia_materia.phonon_id.fd_series.get_FDSeries_results_hdf5_wrapper() HDF5 data wrapper for FDSeries class.\nprincipia_materia.phonon_id.fd_series.save_FDSeries_results_to_hdf5(obj, h5file=‘fdseries_results.hdf5’, overwrite=False) Save the results of a FDSeries object into a HDF5 file.\nParameters\nobj (FDSeries) – A FDSeries object.\nh5file (str or h5py.File/h5py.Group obejct, optional, default to “fdseries_results.hdf5”) – Path to a HDF5 file or a h5py.File/h5py.Group object.\noverwrite (bool, optional, default to False) – When the file exists, whether to replace the content of the file with the content to be saved.\nprincipia_materia.phonon_id.fd_series.save_FDSeries_to_hdf5(obj, h5file=‘fdseries.hdf5’, overwrite=False) Save data of a FDSeries object into a HDF5 file.\nParameters\nobj (FDSeries) – A FDSeries object.\nh5file (str or h5py.File/h5py.Group obejct, optional, default to “fdseries.hdf5”) – Path to a HDF5 file or a h5py.File/h5py.Group object.\noverwrite (bool, optional, default to False) – When the file exists, whether to replace the content of the file with the content to be saved.\n","categories":"","description":"Module principia_materia.phonon_id.fd_series\n","excerpt":"Module principia_materia.phonon_id.fd_series\n","ref":"/docs/references/principia_materia.phonon_id.fd_series.html","tags":"","title":"Module principia_materia.phonon_id.fd_series"},{"body":"principia_materia.phonon_id.finite_displacements module class principia_materia.phonon_id.finite_displacements.FiniteDisplacements(structure, supa, fdtype=‘c’, tol=1e-06) Bases: object\nFinite difference on atomic displacements.\nThis class serves as core finite displacement engine for the package.\nParameters\nstructure (CrystalFTG object or a structure file of CrystalFTG) – The crystal structure.\nsupa (array of int, shape(dim, dim)) – Supercell matrix.\nfdtype (str, choice of [“c”, “f”, “b”]) – Type of finite displacement.\ntol (float, optional, default to 1.0E-6) – Error tolerence.\nadd_delta(delta) compute_finite_displacements(fill=0.0) Compuzeroste fintie displacements derivatives.\nParameters\nfill (float, optional, default to 0.0) – The fill value for the steps having zero displacements.\ncreate_jobs(job_handler, prefix=None, config_file=‘finite_displacements.yml’, append=False, dry_run=False) Create compute jobs for the finite displacements calculations.\nParameters\njob_handler (ComputeJobSeries or JobsDB) – The interface to create and collect result from compute jobs or a database.\nprefix (str, optional, default to None) – Prefix to the jobnames.\nconfig_file (str, optional, default to “finite_displacements.yml”) – The name of the finite displacements configuration file.\ndry_run (bool, optional, default to False) – If True, don’t actually create the job.\nproperty delta() The displacement amplitutes.\nproperty get_jobname() Return a jobname template function.\nIf attribute “_jobname_template” is set, return the value in the attribute, otherwise, return the default template.\nset_delta(delta, overwrite=False) Set the deltas to compute for the finite displacements calculations.\nParameters\ndelta (float or array of float) – The displacement amplitute.\nset_displacement_vectors(dispvecs, displabels, order=None) Setup displacement vectors for the finite displacement calculation.\nParameters\ndispvecs (array of float, shape(N, natoms, dim)) – Displacement vectors.\ndisplabels (list, lenth of N) – The name of the displacements.\norder (tuple of int, length of N) – The order of derivatives.\nset_jobname_template(template) Set custom jobname template\nMust be def template(job_id, prefix, index_pad): …\nParameters\ntemplate (callable, with parameters (job_id, prefix, index_pad)) – The jobname template function.\nset_jobs(jobname_prefix=’’, skip_zero=False) Parameters\njobname_prefix (str) – Prefix for jobnames.\nset_raw_results(source, data_type=None, prefix=None) Parameters\nsource (ComputeJobSeries or JobsDB or Numpy array) – Either a ComputeJobSeries or a JobsDB object as the interface to the jobs. Or an Numpy array that is the output of the finite displacements jobs.\ndata_type (str) – The type of data to retrieve.\nprefix (str, optional, default to None) – Prefix to the jobnames.\nproperty uniq_displacements() The displacement amplitutes that are unique.\nprincipia_materia.phonon_id.finite_displacements.get_FD_from_configuration(config_file, file_type=‘yaml’, tol=1e-06) Read data from configuration file and construct a FiniteDisplacements object.\nParameters\nconfig_file (str) – Path to configuration file.\nfile_type (str, optional, default to “yaml”) – The type of the configuration file.\ntol (float, optional, default to 1.0E-6) – Error tolerance.\nprincipia_materia.phonon_id.finite_displacements.get_fd_config_hdf5_wrapper() HDF5 data wrapper for FiniteDifference class.\nprincipia_materia.phonon_id.finite_displacements.get_fd_config_yaml_wrapper(title=‘Finite Displacements Configuration’) YAML data wrapper for FiniteDisplacements class.\nprincipia_materia.phonon_id.finite_displacements.get_fd_results_hdf5_wrapper() HDF5 data wrapper for FiniteDifference class.\nprincipia_materia.phonon_id.finite_displacements.get_fd_results_yaml_wrapper(title=‘Finite Displacements Results’) principia_materia.phonon_id.finite_displacements.save_FD_config_to_hdf5(obj, directory, filename=‘finite_displacements.hdf5’, overwrite=False) Save finite displacements configuration in HDF5\nParameters\ndirectory (str) – The directory of the finite displacements dft jobs.\nfilename (str, optional, default to “finite_displacements.hdf5”) – The name of the configuration file.\noverwrite (bool, optional, default to False) – When the file exists, whether to replace the content of the file with the content to be saved.\nprincipia_materia.phonon_id.finite_displacements.save_FD_config_to_yaml(obj, directory, filename=‘finite_displacements.yml’, overwrite=False) Save finite displacements configuration in HDF5\nParameters\ndirectory (str) – The directory of the finite displacements dft jobs.\nfilename (str, optional, default to “finite_displacements.yml”) – The name of the configuration file.\noverwrite (bool, optional, default to False) – When the file exists, whether to replace the content of the file with the content to be saved.\n","categories":"","description":"Module principia_materia.phonon_id.finite_displacements\n","excerpt":"Module principia_materia.phonon_id.finite_displacements\n","ref":"/docs/references/principia_materia.phonon_id.finite_displacements.html","tags":"","title":"Module principia_materia.phonon_id.finite_displacements"},{"body":"principia_materia.phonon_id.fourier_interpolation module class principia_materia.phonon_id.fourier_interpolation.FourierInterpolation(structure, supa, order, pg=‘C1’, tol=1e-06) Bases: DynamicTensors\nGeneric Fourier interpolation of phonon interactions at arbitrary order.\nSupports either dynamic tensors or force constants tensors as input, if dynamic tensors are provided, Fourier transform to force constants tensors and then perform WS cell packing; if force constants tensors are provided, skip the Fourier tranformation step.\nParameters\nstructure (CrystalFTG object or a structure file of CrystalFTG) – The crystal structure.\nsupa (array of int, shape(dim, dim)) – The supercell matrix.\norder (int) – Order of the dynamic tensor.\npg (str or PointGroup object) – The point group.\ntol (float, optional, default to 1.0E-6) – Error tolerence.\nanalytic_derivative_dynamic_tensor(Qpoints) Computes analytic derivatives of dynamic tensors with respect to Q-point.\nThe short range part is calculated as as following.\n$$ \\frac{\\partial\\hat D_{\\mathbf{K}}}{\\partial K_\\alpha} = \\sum_{\\mathbf{y}} \\imag T_\\alpha e^{\\imag \\mathbf{K} \\cdot \\mathbf{y}\\hat a} \\hat \\Phi_{\\mathbf{y}} $$\ncopy() Make a copy\nReturns\nnew – A copy of the object.\nReturn type\nFourierInterpolation\nfourier_transform() Fourier transform dynamic tensors to real space force constants tensor.\nclassmethod from_dynamic_tensors(dynamic_tensors) get_Phi() Get force constants tensors of FTG.\nget_Phi_WS_at_Tpoint(Tpoint) Get the force constants tensor at T-point that is shifted within the WS cell.\nget_Phi_WS_dict() Get all the force constants tensors that are shifted within the WS cell of the FTG.\nReturns\nPhi_WS – The force constants tensors that are shifted within the WS cell of the FTG.\nReturn type\nOrderedDict with nested tuples of int as keys and array of complex as values\nget_Tindex(Tpoints) Similar to the indexing system of the Q-points, compute index of T-points\nAll T-points in a set FTG have consecutive indices from 0 to n_Tpoints - 1, thus we can create our own hash table for Phi.\nParameters\nTpoints (array of int, shape(N, order, dim)) – An array of T-points to compute indices for.\nget_Tpoints() Get T-points of the FTG.\ninterpolate_Qpoint(Qpoints, q_direction=None) Interpolate Phi to arbitrary Q-point(s) in reciprocal space.\nParameters\nQpoints (array of float or Fraction, shape(dim, ) or shape(N, dim)) – The Q-point(s) to interpolate into.\nq_direction (array of float or Fraction, shape(dim, ), optional, default to None) – The q-direction that’s used for dipole-dipole contribution for second order insulators.\nprepend_hiden_t(Tpoints) Prepend hidden t-point to T-points.\nFor a T-point at given order, the first t-point is always (0, 0, 0), this it can be omitted and referred to as the hidden t-point. This method prepend the hidden t-point back.\nParameters\nTpoints (array of int, shape(N, order - 1, dim)) – T-points without the hidden t-point.\nset_D(Qpoints, D) Set dynamic tensors.\nIf force constants tensors are set, dynamic tensors cannot be set.\nset_Phi(Tpoints, Phi) Set force constants tensor.\nIf dynamic tensors are set, force constants tensors can only obtained by Fourier transform.\nParameters\nTpoints (array of int, shape(N, order - 1, dim) or shape(N, order, dim)) – T-points of FTG. Can be the full T-points or the T-points without the hidden t-point.\nPhi (array of real or complex, shape(N, ndof, …, ndof), shape(N, ndof, …, ndof, m)) – Force constants tensors in the same order as the Tpoints. Can be trivial force constants tensors or vectorized tensors with the last axis being the vector axis.\nset_Wigner_Seitz_map() Computes the WS map.\nset_dipoledipole_contribution() Set Dipole-Dipole contribution for Fourier Interpolation.\nAt second order, the dipole-dipole contribution for fourier interpolation is treated separately, the code computes the dipole-dipole terms on the FTG then transform to real space into a dummy Phi. It will be subtracted out of the regular fource constants when constructing Phi_WS.\nset_irreducible_D(D) Set dynamic tensors of the irreducible Q-points.\nprincipia_materia.phonon_id.fourier_interpolation.get_FourierInterpolation_from_hdf5(filename, tol=1e-06) Load FourierInterpolation from HDF5 file.\nprincipia_materia.phonon_id.fourier_interpolation.get_FourierInterpolation_hdf5_wrapper() HDF5 data wrapper for FourierInterpolation.\nprincipia_materia.phonon_id.fourier_interpolation.save_FourierInterpolation_to_hdf5(obj, h5file=‘fourier_interpolation.hdf5’, overwrite=False) Save FourierInterpolation data into HDF5 file.\nParameters\nobj (FourierInterpolation) – A FourierInterpolation object.\nh5file (str or h5py.File/h5py.Group obejct, optional, default to “fourier_interpolation.hdf5”) – Path to a HDF5 file or a h5py.File/h5py.Group object.\noverwrite (bool, optional, default to False) – When the file exists, whether to replace the content of the file with the content to be saved.\n","categories":"","description":"Module principia_materia.phonon_id.fourier_interpolation\n","excerpt":"Module principia_materia.phonon_id.fourier_interpolation\n","ref":"/docs/references/principia_materia.phonon_id.fourier_interpolation.html","tags":"","title":"Module principia_materia.phonon_id.fourier_interpolation"},{"body":"principia_materia.phonon_id.frozen_phonons module class principia_materia.phonon_id.frozen_phonons.FrozenPhonons(structure, Qpoint, supa=None, hidden_order=1, fdtype=‘c’, tol=1e-06) Bases: object\nCompute coefficients of phonons and their interactions.\nThe abstract class with the core functionalities to compute phonons and their interactions. For now the symmetry is not considered, it will be in the LID variation, since lone-Q approach can be used to compute the interaction coefficients without symmetry.\nParameters\nstructure (CrystalFTG object or a structure file of CrystalFTG) – The crystal structure.\nQpoint (array of Fraction or a parse_array supported Fraction array.) – The Q-point\nsupa (array of int, shape(dim, dim)) – The supercell matrix.\nhidden_order (int, optional, default to 1) – The order of derivatives from first principles.\nfdtype (str, choice of [“c”, “f”, “b”]) – Type of finite displacement.\ntol (float, optional, default to 1.0E-6) – Error tolerence.\ncheck_supercell() Check if supercell can accommodates the Q-point.\ncreate_jobs(job_handler, deltas, prefix=None, delta_format=, measurement_label=, jobname_prefix=’’, config_file=‘finite_displacements.yml’, fdseries_filename=‘fdseries.hdf5’, append=False, dry_run=False) Create compute jobs for the frozen phonon calculations.\nEach measurement has its own FDSeries class to allow flexibility for different measurements to have different deltas, and each measurement can be managed independently to create extra calculations for better quality.\nParameters\njob_handler (ComputeJobSeries or JobsDB) – Either a ComputeJobSeries or a JobsDB object as the interface to the jobs.\ndeltas (list of numbers, list of arrays, 1-d or 2-d array) – Displacement amplitude. Can take following types:\n1. a number, will be broadcast into a shape(n_measurements, 1) array. 2. an 1-d array of length N, will be broadcast into a shape(n_measurements, N) array. 3. a 2-d array of shape(n_measurements, N). prefix (str, optional, default to None) – Prefix to the jobnames.\ndelta_format (callable, optional, default to function: format_delta_dirname.) – A function that format a delta into a string for directory name. Must be in form of def function(delta, ...): ....\njobname_prefix (str) – Prefix for jobnames.\nconfig_file (str, optional, default to “finite_displacements.yml”) – The name of the finite displacements configuration file.\nfdseries_filename (str, optional, default to “fdseries.hdf5”) – The name of the FDSeries data file to store finite displacement information.\ndry_run (bool, optional, default to False) – If True, don’t actually create the job.\nproperty derivative_order() The order of the finite displacements derivative.\nget_dynamic_tensor() property order() The order of the phonon interaction.\nset_displacements() Abstract method to construct displacements vectors for finite displacements.\nset_displacements_basis() Abstract method to construct the displacements basis vectors.\nset_errortail_results(pick_min=3, pick_max=None, consecutive=False, penalty=, separate_complex=True, output=None, overwrite=True) Compute error tail for the FrozenPhonons result.\nParameters\npick_min (int, optional, default to 3) – The minimum number of picks for delta selection.\npick_max (int, optional, default to None) – The maximum number of picks for delta selection. If None, the pick n scheme is used with n=pick_min. If not None, the pick N schcme is used with N=[pick_min, pick_max].\nconsecutive (bool, optional, default to False) – Whether to pick consecutive deltas in the picking process.\npenalty (callable, optional, default to penalty_linear_mse) – The penalty function to determine the best fit.\nseparate_complex (bool, optional, default to False) – Whether to fit real and imaginary part of the complex data points separetely.\noutput (str, optional, default to None) – Path of the output file. If not None, save the output of errortail fit to the file.\n_fp_errortail() The errortail extrapolated finite displacements results of the FrozenPhonons calculations.\nType\narray of complex\nset_realspace_displacements(allreal=False) Find real space displacements from the complex reciprocal space displacements.\nrealdisp_cs_index() The list of cos/sin pairs (real/imag pairs) that are required to compute the complex displacements of the measurement.\nType\nlist of arrays of int\nrealdisp_transformation_matrices() The transformation matrices from the complex displacement derivatives to the real space displacement derivatives.\nType\nlist of arrays of complex\nrealdisp_associated_displacements() The lists of complex displacements that can be simultaneously computed from this set of real space displacement.\nType\nlist of tuples\nset_results(job_handler, data_type, prefix=None, fill=0.0, config_file=‘finite_displacements.yml’) Get finite displacements results from calculations.\nParameters\njob_handler (ComputeJobSeries or JobsDB) – Either a ComputeJobSeries or a JobsDB object as the interface to the jobs.\ndata_type (str, choices of “forces” and “energy”) – Type of data to read from compute jobs.\nprefix (str, optional, default to None) – Prefix to the jobnames.\nconfig_file (str, optional, default to “finite_displacements.yml”) – The name of the finite displacements configuration file.\n_fp_results() The result of FrozenPhonons calculations.\nType\nlist of arrays of complex, length of number of measurements\nclass principia_materia.phonon_id.frozen_phonons.LoneQ_FP(structure, Qpoint, supa=None, hidden_order=1, fdtype=‘c’, tol=1e-06) Bases: FrozenPhonons\nLoneQ approach to comphe phonon and their interactions.\nThis approach does not consider symmetry, and simply find combinations of the reciprocal naive displacements basis and compute the phonon interactions for each unique dynamic tensor elements..\nset_displacements() Abstract method to construct displacements vectors for finite displacements.\nset_displacements_basis() Abstract method to construct the displacements basis vectors.\nset_dynamic_tensor() Construct the dynamic tensor after finite displacements result is computed.\n_dynamic_tensor() The dynamic tensor at the Q-point.\nType\narray of complex, shape(norbitals, ) * order\nset_naive_displacements() Find the unique naive displacements to compute phonon interactions.\nset_naive_displacements_basis() Construct the naive reciprocal space displacement basis.\nThe displacement amplitudes follow the convention discussed in the paper Phys. Rev. B 100, 014303 (2019).\n$$ u_{\\textbf{t}}*{\\left(b, \\beta\\right)} = \\sum_{\\textbf{q} \\in \\hat{S}_{BZ}} u_{\\textbf{q}}*{\\left(b, \\beta\\right)} e^{2\\pi\\imag \\textbf{t} \\cdot \\textbf{q}} $$\nprincipia_materia.phonon_id.frozen_phonons.find_realspace_displacements(Qpoint, displabels, allreal=False, tol=1e-06) Find realspace displacements from complex displacements basis.\nIn Lone-Q and Lone-ID finite displacements approaches, we find displacements in the reciprocal space first, these displacements are often complex numbers. However, we are only able to displacement atoms in real space. Thus, we need to find minumum the real/imag pairs of these displacements to be able to compute the derivatives.\nParameters\nQpoint (array of Fraction, shape (order-hidden_order, dim)) – The Q-point.\ndisplabels (tuple of tuples) – The reciprocal space displacement basis labels for a measurement.\nallreal (bool, optional, default to False) – Whether the displacements are wll real or not.\ntol (float) – Error tolerence.\nReturns\ncs_pairs (array of int) – The cos/sin pairs (real/imag pairs) that are required to compute the complex displacements of the measurement. The array is in row convention, every row is a real space displacement denoted with a cos/sin pair. There are 2 possible integers in the array: 0 for cos(real) and 1 for sin(imag).\ntransformation_matrix (array of complex) – The transformation matrix from the complex displacement derivatives to the real space displacement derivatives. Each row of the matrix is the coefficients of the linear combination of the complex displacements that make the real space displacement.\nassociated_displacements (list of tuples) – A list of complex displacements that can be simultaneously computed from this set of real space displacement.\nprincipia_materia.phonon_id.frozen_phonons.find_unique(input_list, return_index=False) Find unique elements in a list.\nParameters\ninput_list (list) – An input list.\nreturn_index (bool, optional, default False) – Whether to return the indices of the unique elements.\nprincipia_materia.phonon_id.frozen_phonons.format_irrep_instances(irrep_instances) principia_materia.phonon_id.frozen_phonons.format_measurement_label(measurement_index, cs_indicies=None, zero_padding=0) Format measurement indices into str labels.\nParameters\nmeasurement_index (int) – The index of the measurement.\ncs_indicies (array of int, optional, default to None) – Array denoting the cos/sin pairs of the measurement.\nzero_padding (int, optional, default to 0) – The amount of zero padding on the left of the measurement indices.\nReturns\nlabel – The label for the measurement.\nReturn type\nstr\nprincipia_materia.phonon_id.frozen_phonons.get_FrozenPhonons_hdf5_wrapper() HDF5 data wrapper for FrozenPhonons class.\nprincipia_materia.phonon_id.frozen_phonons.get_LoneQ_from_hdf5(h5file, root_directory=None, fdseries_filename=‘fdseries.hdf5’, tol=1e-06) Read data from HDF5 file and construct a LoneQ_FP object.\nParameters\nh5file (str or h5py.File/h5py.Group obejct) – Path to a HDF5 file or a h5py.File/h5py.Group object.\ntol (float, optional, default to 1.0E-6) – Error tolerance.\nprincipia_materia.phonon_id.frozen_phonons.get_dynamic_tensor_wrapper() HDF5 data wrapper for dynamic tensor of a q-point.\nprincipia_materia.phonon_id.frozen_phonons.is_qpoint_real(qpoint) principia_materia.phonon_id.frozen_phonons.load_fp_errortails(filename) Load errortail data of frozen phonon runs from HDF5 file.\nParameters\nfilename (str) – Path to HDF5 file.\nprincipia_materia.phonon_id.frozen_phonons.make_displacement_identifier(Qpoint, displabels, cs=None, sort=True) Make the nested tuple displacement identifier for a measurement.\nParameters\nQpoint (array of Fractions) – A Q-point, an array of q-points.\ndisplabels (list of tuples or str) – The labels for the displacement.\ncs (list of str or int, optional, default to None) – The cos/sin labels for the displaement.\nsort (bool, optional, default to True) – Whether to sort the q-point \u0026 displacement label tuple, when making the identifier.\nReturns\ndisplacement_identifier – The identifier for the displacement.\nReturn type\nnested tuple\nprincipia_materia.phonon_id.frozen_phonons.save_LoneQ_to_hdf5(obj, h5file=‘loneq_fp.hdf5’, include_fdseires=False) Save data of a LoneQ_FP object into a HDF5 file.\nParameters\nobj (LoneQ_FP) – A LoneQ_FP object.\nh5file (str or h5py.File/h5py.Group obejct, optional, default to “loneq_fp.hdf5”) – Path to a HDF5 file or a h5py.File/h5py.Group object.\nprincipia_materia.phonon_id.frozen_phonons.save_dynamic_tensor_to_hdf5(obj, h5file=‘dynamic_tensor.hdf5’) Save data of a dynamic tensor of a q-poin into a HDF5 file.\nParameters\nobj (FrozenPhonons) – A FrozenPhonons object.\nh5file (str or h5py.File/h5py.Group obejct, optional, default to “dynamic_tensor.hdf5”) – Path to a HDF5 file or a h5py.File/h5py.Group object.\nprincipia_materia.phonon_id.frozen_phonons.save_fp_errortails(output, fdtype, deltas, fd_values, result, xcoef, pick, penalty, overwrite=True) Save errortail data of frozen phonon runs into HDF5 file.\n","categories":"","description":"Module principia_materia.phonon_id.frozen_phonons\n","excerpt":"Module principia_materia.phonon_id.frozen_phonons\n","ref":"/docs/references/principia_materia.phonon_id.frozen_phonons.html","tags":"","title":"Module principia_materia.phonon_id.frozen_phonons"},{"body":"principia_materia.phonon_id.hsbid module class principia_materia.phonon_id.hsbid.HSBID(structure, supa, order, pg=‘C1’, full_symmetry=False, hidden_order=1, fdtype=‘c’, tol=1e-06) Bases: object\nUse Hierarchical Supercell Bundled Irreducible Derivatives approach to compute phonons and their interactions\nParameters\nstructure (CrystalFTG object or a structure file of CrystalFTG) – The crystal structure.\nsupa (array of int, shape(dim, dim)) – The supercell matrix.\norder (int) – Order of the phonon interaction.\npg (str or PointGroup object, optional, default to “C1”) – The point group.\nfull_symmetry (bool, optional, default to False) – If True, use full group analysis (not implemented yet). If False, use little group analysis.\nhidden_order (int, optional, default to 1) – The order of derivatives from first principles.\nfdtype (str, choice of [“c”, “f”, “b”]) – Type of finite displacement.\ntol (float, optional, default to 1.0E-6) – Error tolerence.\nproperty QpointsN() compute_irreducible_derivatives() Compute irreducible derivatives with finite displacements result and chainrule matrices/tensors.\nirreducible_derivatives() The values of all irreducible derivatives in the current system.\nType\narray of complex shape(n_irreducible_derivatives, )\ncreate_jobs(job_handler, deltas, supa_format=, delta_format=, measurement_label=, jobname_prefix=’’, config_file=‘finite_displacements.yml’, bid_filename=‘bid.hdf5’, append=False, dry_run=False) Create compute jobs for the BID calculations.\nParameters\njob_handler (ComputeJobSeries or JobsDB) – Either a ComputeJobSeries or a JobsDB object as the interface to the jobs.\ndeltas (list of numbers, list of arrays, 1-d or 2-d array) – Displacement amplitude. Can take following types:\n1. a number, will be broadcast into a shape(n_measurements, 1) array. 2. an 1-d array of length N, will be broadcast into a shape(n_measurements, N) array. 3. a 2-d array of shape(n_measurements, N). prefix (str, optional, default to None) – Prefix to the jobnames.\nsupa_format (callable, optional default to function: format_supa_dirname) – A function that format the supercell into a string for directory name.\ndelta_format (callable, optional, default to function: format_delta_dirname) – A function that format a delta into a string for directory name. Must be in form of def function(delta, ...): ....\nmeasurement_label (callable, optional, default to format_measurement_label) – A function that format the measurement indices into certain string format. Must be in form of def function(measurement_index, …): …\njobname_prefix (str) – Prefix for jobnames.\nconfig_file (str, optional, default to “finite_displacements.yml”) – The name of the finite displacements configuration file.\nbid_filename (str, optional, default to “bid.hdf5”) – The name of HDF5 file to save BID data into.\ndry_run (bool, optional, default to False) – If True, don’t actually create the job.\nproperty derivative_order() The order of the finite displacements derivative.\nfind_measurements(extra_measurements=0, test_measurements=5, verbose=False) Find measurements in each hierchical supercell that can solve the chainrule matrix.\nParameters\nextra_measurements (int, optional, default to 0) – The amount of extra measurement, the new number of measurement is calculated with the equation: n_measurements \\*= extra_measurements + 1.\ntest_measurements (int, optional, default to 5) – The number of test measurements.\nverbose (bool, optional, default to False) –\nget_dynamic_tensors() Compute dynamic tensors of the irreducible Q-points from irreducible derivatives.\nReturns\ndynamic_tensors – (where N_IQ is the number of irreducible Q-points) The dynamic tensors of the irreducible Q-points.\nReturn type\narray of complex, shape(N_IQ, ) + (norbitals, ) * order\nget_fourier_interpolation() Construct the FourierInterpolation object from dynamic tensors of irreducible Q-points.\nReturns\nfourier_interpolation – A FourierInterpolation object.\nReturn type\nFourierInterpolation\nget_irreducible_derivative_names() load_hsbid(root_directory, bid_filename=‘bid.hdf5’) Load BID objects from HDF5 files.\nParameters\nroot_directory (str) – The root directory of the HSBID jobs.\nbid_filename (str, optional, default to “bid.hdf5”) – The name of HDF5 file to save BID data into.\nset_chainrule_derivatives(verbose=False) Instantiate the ChainruleDerivatives class to compute chainrule matrices/tensors.\nParameters\nverbose (bool, optional, default to False) – Whether to print out the analysis steps in the construction of the ChainruleDerivatives object.\n_chainrule() The ChainruleDerivatives object for the system.\nType\nChainruleDerivatives\nset_errortail_results(pick_min=3, pick_max=None, consecutive=False, penalty=, separate_complex=True, output=None, overwrite=True) Compute error tail for the finite displacements result.\nParameters\npick_min (int, optional, default to 3) – The minimum number of picks for delta selection.\npick_max (int, optional, default to None) – The maximum number of picks for delta selection. If None, the pick n scheme is used with n=pick_min. If not None, the pick N schcme is used with N=[pick_min, pick_max].\nconsecutive (bool, optional, default to False) – Whether to pick consecutive deltas in the picking process.\npenalty (callable, optional, default to penalty_linear_mse) – The penalty function to determine the best fit.\nseparate_complex (bool, optional, default to False) – Whether to fit real and imaginary part of the complex data points separetely.\noutput (str, optional, default to None) – Path of the output file. If not None, save the output of errortail fit to the file.\nset_hsbid() Construct hierchical supercells and their BID objects.\nset_results(job_handler, data_type, config_file=‘finite_displacements.yml’) Get finite displacements results from calculations.\nParameters\njob_handler (ComputeJobSeries or JobsDB) – Either a ComputeJobSeries or a JobsDB object as the interface to the jobs.\ndata_type (str, choices of “forces” and “energy”) – Type of data to read from compute jobs.\nconfig_file (str, optional, default to “finite_displacements.yml”) – The name of the finite displacements configuration file.\nprincipia_materia.phonon_id.hsbid.find_hierarchical_supercells(Qpoints, Qpoints_orbits) Find Hierchical supercells that accommondates the input Q-points.\nFind the minimum amount of supercells that for each of the input Q-point, there is a supercell that is the smallest supercell that can accommondate the Q-point according to group theory.\nA greedy search is implemented instead of a brute-force search for efficiency.\nParameters\nQpoints (array of float, shape(N, order, dim)) – All the Q-points from a FTG.\nQpoints_orbits (list of arrays of int) – List of arrays each represents an orbit of Q-points that are associated by space group symmetry.\nReturns\nsupercells – The set of hierarchical supercells.\nReturn type\nlist of shape(dim, dim) arrays of int\nprincipia_materia.phonon_id.hsbid.format_supa_dirname(supa) principia_materia.phonon_id.hsbid.get_HSBID_from_hdf5(h5file, tol=1e-06) Read data from HDF5 file and construct a HSBID object.\nParameters\nh5file (str or h5py.File/h5py.Group obejct) – Path to a HDF5 file or a h5py.File/h5py.Group object.\ntol (float, optional, default to 1.0E-6) – Error tolerance.\nprincipia_materia.phonon_id.hsbid.get_HSBID_hdf5_wrapper() HDF5 data wrapper for LIDMesh configurations.\nprincipia_materia.phonon_id.hsbid.save_HSBID_to_hdf5(obj, h5file=‘hsbid.hdf5’, include_bid=True, overwrite=False) Save data of a HSBID object into a HDF5 file.\nParameters\nobj (BID) – A HSBID object.\nh5file (str or h5py.File/h5py.Group obejct, optional, default to “hsbid.hdf5”) – Path to a HDF5 file or a h5py.File/h5py.Group object.\n","categories":"","description":"Module principia_materia.phonon_id.hsbid\n","excerpt":"Module principia_materia.phonon_id.hsbid\n","ref":"/docs/references/principia_materia.phonon_id.hsbid.html","tags":"","title":"Module principia_materia.phonon_id.hsbid"},{"body":"principia_materia.phonon_id.lid module class principia_materia.phonon_id.lid.LoneID_FP(structure, Qpoint, supa=None, pg=‘C1’, full_symmetry=False, hidden_order=1, fdtype=‘c’, tol=1e-06) Bases: FrozenPhonons\nUse Lone Irreducible Derivatives (LID) apporach to compute phonons and their interactions.\nParameters\nstructure (CrystalFTG object or a structure file of CrystalFTG) – The crystal structure.\nQpoint (array of Fraction or a parse_array supported Fraction array.) – The Q-point\nsupa (array of int, shape(dim, dim)) – The supercell matrix.\npg (str or PointGroup object, optional, default to “C1”) – The point group.\nfull_symmetry (bool, optional, default to False) – If True, use full group analysis (not implemented yet). If False, use little group analysis.\nhidden_order (int, optional, default to 1) – The order of derivatives from first principles.\nfdtype (str, choice of [“c”, “f”, “b”]) – Type of finite displacement.\ntol (float, optional, default to 1.0E-6) – Error tolerence.\nget_irreducible_derivative_names() get_irreducible_derivatives() property irreducible_derivatives() set_analytic_tensor(stars=None) Construct analytic dynamic tensor for the Q-point.\n_adt() An AnalyticDynamicTensor subclass object for the system and Q-point.\nType\na subclass of AnalyticDynamicTensor\nset_displacements() Find displacements that can probe each irreducible derivatives separately.\nset_displacements_basis() Construct the symmetrized reciprocal displacement basis.\nThe displacement amplitudes follow the convention discussed in the paper Phys. Rev. B 100, 014303 (2019).\n$$ u_{\\textbf{t}}*{\\left(b, \\beta\\right)} = \\sum_{\\textbf{q} \\in \\hat{S}_{BZ}} u_{\\textbf{q}}*{\\left(b, \\beta\\right)} e^{2\\pi\\imag \\textbf{t} \\cdot \\textbf{q}} $$\nset_dynamic_tensor() Construct the dynamic tensor after finite displacements result is computed.\n_dynamic_tensor() The dynamic tensor at the Q-point.\nType\narray of complex, shape(norbitals, ) * order\nset_irreducible_derivatives() Compute irreducible derivatives.\nset_target_irrep_products(irrep_products) principia_materia.phonon_id.lid.get_LoneID_from_hdf5(h5file, root_directory=None, fdseries_filename=‘fdseries.hdf5’, tol=1e-06) Read data from HDF5 file and construct a LoneID_FP object.\nParameters\nh5file (str or h5py.File/h5py.Group obejct) – Path to a HDF5 file or a h5py.File/h5py.Group object.\ntol (float, optional, default to 1.0E-6) – Error tolerance.\nprincipia_materia.phonon_id.lid.get_LoneID_hdf5_wrapper() HDF5 data wrapper for LoneID class.\nprincipia_materia.phonon_id.lid.save_LoneID_to_hdf5(obj, h5file=‘loneqID_fp.hdf5’, include_fdseires=False) Save data of a LoneID_FP object into a HDF5 file.\nParameters\nobj (LoneID_FP) – A LoneID_FP object.\nh5file (str or h5py.File/h5py.Group obejct, optional, default to “loneqID_fp.hdf5”) – Path to a HDF5 file or a h5py.File/h5py.Group object.\n","categories":"","description":"Module principia_materia.phonon_id.lid\n","excerpt":"Module principia_materia.phonon_id.lid\n","ref":"/docs/references/principia_materia.phonon_id.lid.html","tags":"","title":"Module principia_materia.phonon_id.lid"},{"body":"principia_materia.phonon_id.lid_mesh module class principia_materia.phonon_id.lid_mesh.LIDMesh(structure, supa, order, pg=‘C1’, full_symmetry=False, hidden_order=1, fdtype=‘c’, tol=1e-06) Bases: object\nCompute phonons and their interactions with LID approach on a given mesh.\nParameters\nstructure (CrystalFTG object or a structure file of CrystalFTG) – The crystal structure.\nsupa (array of int, shape(dim, dim)) – The supercell matrix (a.k.a the mesh) to compute phonons and their interactions in.\norder (int) – The order of the phonon interactions.\npg (str or PointGroup object, optional, default to “C1”) – The point group.\nfull_symmetry (bool, optional, default to False) – If True, use full group analysis (not implemented yet). If False, use little group analysis.\nhidden_order (int, optional, default to 1) – The order of derivatives from first principles.\nfdtype (str, choice of [“c”, “f”, “b”]) – Type of finite displacement.\ntol (float, optional, default to 1.0E-6) – Error tolerence.\ncreate_jobs(job_handler, deltas, Q_dir_format=‘Qpoint_{:\u003e03d}’, delta_format=, measurement_label=, jobname_prefix=’’, config_file=‘finite_displacements.yml’, fdseries_filename=‘fdseries.hdf5’, lid_filename=‘loneqID_fp.hdf5’, append=False, dry_run=False) Create jobs for LID calculations for the irreducible Q-points.\nParameters\njob_handler (ComputeJobSeries or JobsDB) – Either a ComputeJobSeries or a JobsDB object as the interface to the jobs.\ndeltas (list of numbers, list of arrays, 1-d or 2-d array) – Displacement amplitude. Can take following types:\n1. a number, will be broadcast into a shape(n_measurements, 1) array. 2. an 1-d array of length N, will be broadcast into a shape(n_measurements, N) array. 3. a 2-d array of shape(n_measurements, N). Q_dir_format (str, optional, default to “Qpoint_{:\u003e03d}”) – The format of directory name representing a Q-point.\ndelta_format (callable, optional, default to function: format_delta_dirname.) – A function that format a delta into a string for directory name. Must be in form of def function(delta, ...): ....\nmeasurement_label (callable, optioal, default to function: format_measurement_label.) – A function the format a measurement index into a measurement label string.\njobname_prefix (str) – Prefix for jobnames.\nconfig_file (str, optional, default to “finite_displacements.yml”) – The name of the finite displacements configuration file.\nfdseries_filename (str, optional, default to “fdseries.hdf5”) – The name of the FDSeries data file to store finite displacement information.\nlid_filename (str, optional, default to “loneqID_fp.hdf5”) – The name of HDF5 file to save LID data into.\ndry_run (bool, optional, default to False) – If True, don’t actually create the job.\nget_dynamic_tensors() Compute irreducible derivatives and construct dynamic tensors of irreducible Q-points.\nReturns\ndynamic_tensors – The dynamic tensors of irreducible Q-points.\nReturn type\narray of complex, shape(N irreducible Q-points, norbitals, …)\nget_fourier_interpolation() Construct the FourierInterpolation object from dynamic tensors of irreducible Q-points.\nReturns\nfourier_interpolation – A FourierInterpolation object.\nReturn type\nFourierInterpolation\nget_irreducible_derivative_names() get_irreducible_derivatives() property irreducible_derivatives() load_lid(root_directory, lid_filename=‘loneqID_fp.hdf5’, fdseries_filename=‘fdseries.hdf5’) Load LID objects from HDF5 files.\nParameters\nroot_directory (str) – The root directory of the LIDMesh jobs.\nlid_filename (str, optional, default to “loneqID_fp.hdf5”) – The name of HDF5 file to save LID data into.\nfdseries_filename (str, optional, default to “fdseries.hdf5”) – The name of the FDSeries data file to store finite displacement information.\nset_errortail_results(pick_min=3, pick_max=None, consecutive=False, penalty=, separate_complex=True, output=None, overwrite=True) Compute error tail for the FrozenPhonons result.\nParameters\npick_min (int, optional, default to 3) – The minimum number of picks for delta selection.\npick_max (int, optional, default to None) – The maximum number of picks for delta selection. If None, the pick n scheme is used with n=pick_min. If not None, the pick N schcme is used with N=[pick_min, pick_max].\nconsecutive (bool, optional, default to False) – Whether to pick consecutive deltas in the picking process.\npenalty (callable, optional, default to penalty_linear_mse) – The penalty function to determine the best fit.\nseparate_complex (bool, optional, default to False) – Whether to fit real and imaginary part of the complex data points separetely.\noutput (str, optional, default to None) – Path of the output file. If not None, save the output of errortail fit to the file.\nset_lid() Construct LID objects for irreducible Q-points.\nset_results(job_handler, data_type, fill=0.0, config_file=‘finite_displacements.yml’) Get finite displacements results from calculations.\nParameters\njob_handler (ComputeJobSeries or JobsDB) – Either a ComputeJobSeries or a JobsDB object as the interface to the jobs.\ndata_type (str, choices of “forces” and “energy”) – Type of data to read from compute jobs.\nconfig_file (str, optional, default to “finite_displacements.yml”) – The name of the finite displacements configuration file.\nprincipia_materia.phonon_id.lid_mesh.get_LIDMesh_config_wrapper(title=‘LID Mesh Configuration’) YAML data wrapper for LIDMesh configurations.\nprincipia_materia.phonon_id.lid_mesh.get_LIDMesh_from_hdf5(h5file, tol=1e-06) principia_materia.phonon_id.lid_mesh.get_LIDMesh_from_yaml(filename, tol=1e-06) principia_materia.phonon_id.lid_mesh.get_LIDMesh_hdf5_wrapper() HDF5 data wrapper for LIDMesh configurations.\nprincipia_materia.phonon_id.lid_mesh.save_LIDMesh_to_hdf5(obj, h5file=‘lid_mesh.hdf5’, overwrite=False) principia_materia.phonon_id.lid_mesh.save_LIDMesh_to_yaml(obj, filename=‘lid_mesh.yml’, overwrite=False) ","categories":"","description":"Module principia_materia.phonon_id.lid_mesh\n","excerpt":"Module principia_materia.phonon_id.lid_mesh\n","ref":"/docs/references/principia_materia.phonon_id.lid_mesh.html","tags":"","title":"Module principia_materia.phonon_id.lid_mesh"},{"body":"principia_materia.phonon_id.little_group_adt module class principia_materia.phonon_id.little_group_adt.LittleGroupADT(structure, pg, Qpoint, tol=1e-06) Bases: AnalyticDynamicTensor\nLittle group analytic representation of dynamic tensor under group theory.\nIt works under the little group scheme, which is the point group that only maps each q in Q-set into itself. Then it uses this little group to find the irrep decomposition of each q, perform symmetric product and for the ones that contain identity, find the coefficients in the expansion in terms of symmetric basis products. The symmetric basis vectors will be later used for rotating the tensor from symmetric basis to naive basis.\nParameters\nstructure (CrystalFTG object or a structure file of CrystalFTG) – The crystal structure.\npg (str or PointGroup object) – The point group.\nQpoint (array of Fraction or a parse_array supported Fraction array.) – The Q-point\ntol (float, optional, default to 1.0E-6) – Error tolerence.\nset_irreducible_derivatives(conjugate=False) The irreducible derivatives is constructued as well as the coefficients for them in the symmetrized basis.\nset_qpoint_displacement_rep() Find all irreducible derivatives allowed in the given Qpoint and PointGroup.\nprincipia_materia.phonon_id.little_group_adt.get_LittleGroupADT_from_hdf5(h5file, tol=1e-06) Read data from HDF5 file and construct a LittleGroupADT object.\nParameters\nh5file (str or h5py.File/h5py.Group obejct) – Path to a HDF5 file or a h5py.File/h5py.Group object.\ntol (float, optional, default to 1.0E-6) – Error tolerance to use when constructing the LittleGroupADT object.\nprincipia_materia.phonon_id.little_group_adt.inverse_qpoint(qpoint) principia_materia.phonon_id.little_group_adt.save_LittleGroupADT_to_hdf5(obj, h5file=‘little_group_adt.hdf5’, overwrite=False) Save data of a LittleGroupADT object into a HDF5 file.\nParameters\nobj (LittleGroupADT) – A LittleGroupADT object.\nh5file (str or h5py.File/h5py.Group obejct, optional, default to “little_group_adt.hdf5”) – Path to a HDF5 file or a h5py.File/h5py.Group object.\noverwrite (bool, optional, default to False) – When the file exists, whether to replace the content of the file with the content to be saved.\n","categories":"","description":"Module principia_materia.phonon_id.little_group_adt\n","excerpt":"Module principia_materia.phonon_id.little_group_adt\n","ref":"/docs/references/principia_materia.phonon_id.little_group_adt.html","tags":"","title":"Module principia_materia.phonon_id.little_group_adt"},{"body":"principia_materia.phonon_id.phonon_db module principia_materia.phonon_id.phonon_db.create_BID_table(db, table, exists=True) principia_materia.phonon_id.phonon_db.create_LID_table(db, table, exists=True) principia_materia.phonon_id.phonon_db.create_metadata_table(db, table, exists=True) principia_materia.phonon_id.phonon_db.create_strain_table(db, table, exists=True) ","categories":"","description":"Module principia_materia.phonon_id.phonon_db\n","excerpt":"Module principia_materia.phonon_id.phonon_db\n","ref":"/docs/references/principia_materia.phonon_id.phonon_db.html","tags":"","title":"Module principia_materia.phonon_id.phonon_db"},{"body":"principia_materia.phonon_id.phonon_report_util module principia_materia.phonon_id.phonon_report_util.summarize_bid(inp, include_title=True, include_structure=True, include_pg=True) principia_materia.phonon_id.phonon_report_util.summarize_hsbid(inp) principia_materia.phonon_id.phonon_report_util.summarize_lid(inp, include_title=True, include_structure=True, include_pg=True) principia_materia.phonon_id.phonon_report_util.summarize_lid_mesh(inp) principia_materia.phonon_id.phonon_report_util.summarize_structure(structure) ","categories":"","description":"Module principia_materia.phonon_id.phonon_report_util\n","excerpt":"Module principia_materia.phonon_id.phonon_report_util\n","ref":"/docs/references/principia_materia.phonon_id.phonon_report_util.html","tags":"","title":"Module principia_materia.phonon_id.phonon_report_util"},{"body":"principia_materia.phonon_id.phonon_tools module principia_materia.phonon_id.phonon_tools.adjust_eigenvectors_subspace(mat, frequencies, eigenvectors, tol=0.0001) Adjust eigenvectors in degerate subspace based on the input matrices.\nIt picks the eigenvectors in the frequency degenarete subspace so that the sub-matrix of mat can be diagonalized by the eigenvectors as well.\nParameters\nmat (array of complex, shape(nq, nband, nband)) – Matrices the adjustments of eigenvectors are based on. Renormalized with mass.\nfrequencies (array of float, shape(nq, nband)) – Phonon frequencies, the subspace of eigenvectors are based on the degenracy of the phonon frequencies.\neigenvectors (array of complex, shape(nq, nband, nband)) – Phonon eigenvectors.\ntol (float, optional, default to 1.0E-4) – Tolerance threshold.\nReturns\nadjusted_eigenvectors – Ajusted eigenvectors.\nReturn type\narray of complex, shape(nq, nband, nband)\nprincipia_materia.phonon_id.phonon_tools.compute_eigenvalues(dq, mass_matrix, UPLO=‘L’, decimal=8) Just find the eigenvalues and eigenvectors of Dq with mass matrix.\nParameters\ndq (array of complex, shape (nband, nband) or (nq, nband, nband)) – Dynamic matrix or an array of dynamic matrices.\nmass_matrix (array of float, shape (nband, ) or (nband, nband)) – Mass matrix. (either mass_matrix or structure need to be present to compute phonon)\nUPLO (‘L’ or ‘U’, optional, default to ‘L’) – Use either lower or upper triangular of the Hermetian matrix.\ndecimal (int, optional, default to 8) – Decimal points of the precision.\nReturns\nevals (array of float, shape (nband, ) or (nq, nband)) – Eigenvalues of dynamic matrices.\nevecs (array of complex, shape (nband, nband) or (nq, nband, nband)) – Phonon eigenvectors.\nprincipia_materia.phonon_id.phonon_tools.compute_phonon_frequencies_from_eigenvalues(evals, units=‘cm-1’) Compute phonon frequencies from eigenvalues.\nParameters\nevals (array of float, shape (nband, ) or (nq, nband)) – Eigenvalues of dynamic matrices.\nunits (str, optional, default to ‘cm-1’) – Unit of phonon frequencies\nReturns\nfreqs – Phonon frequencies.\nReturn type\narray of float, shape (nband, ) or (nq, nband)\nprincipia_materia.phonon_id.phonon_tools.compute_phonons(dq, mass_matrix=None, structure=None, units=‘cm-1’, UPLO=‘L’, decimal=8) Compute phonon and eigenvectors for given structure, dynamic matrices and units.\nIt is using the following formula:\n$$ \\hat{M}^{-\\frac{1}{2}} \\hat{D_q} \\hat{M}^{-\\frac{1}{2}} \\vec{S} = \\omega^2 \\vec{S} $$ This class also support diagonalization and unit adjustments for an array of dynamic matrices.\nParameters\ndq (array of complex, shape (nband, nband) or (nq, nband, nband)) – Dynamic matrix or an array of dynamic matrices.\nmass_matrix (array of float, shape (nband, ) or (nband, nband)) – Mass matrix. (either mass_matrix or structure need to be present to compute phonon)\nstructure (str or CrystalFTG instance) – Path to the CrystalFTG structure file or a CrystalFTG instance.\nunits (str, optional, default to ‘cm-1’) – Unit of phonon frequencies\nUPLO (‘L’ or ‘U’, optional, default to ‘L’) – Use either lower or upper triangular of the Hermetian matrix.\ndecimal (int, optional, default to 8) – Decimal points of the precision.\nReturns\nfreqs (array of float, shape (nband, ) or (nq, nband)) – Phonon frequencies.\nevecs (array of complex, shape (nband, nband) or (nq, nband, nband)) – Phonon eigenvectors.\nprincipia_materia.phonon_id.phonon_tools.find_degenerate_frequencies(frequencies, tol=0.0001) Find degerate sets of frequencies.\nParameters\nfrequencies (array of float, shape(nq, nband)) – Phonon frequencies.\ntol (float, optional, default to 1.0E-4) – Tolerance threshold.\nReturns\ndegenerate_indicies – Index of degenerate indices of the frequencies grouped into list of lists.\nReturn type\nlist of lists of integers\nprincipia_materia.phonon_id.phonon_tools.get_mass_matrix(structure) Compute mass matrix from given structure.\nParameters\nstructure (str or CrystalFTG instance) – Path to the CrystalFTG structure file or a CrystalFTG instance.\nReturns\nmass_matrix – Mass matrix.\nReturn type\narray of float, shape (nband, nband)\nprincipia_materia.phonon_id.phonon_tools.multiply_mass_matrix(dq, mass_matrix) Multiply mass matrix to dynamic matrices.\nParameters\ndq (array of complex, shape (nband, nband) or (nq, nband, nband)) – Dynamic matrices.\nmass_matrix (array of float, shape (nband, ) or (nband, nband)) – Mass matrix. (either mass_matrix or structure need to be present to compute phonon)\nReturns\ndq – Mass renormalized dynamic matrices.\nReturn type\narray of complex, shape (nband, nband) or (nq, nband, nband)\n","categories":"","description":"Module principia_materia.phonon_id.phonon_tools\n","excerpt":"Module principia_materia.phonon_id.phonon_tools\n","ref":"/docs/references/principia_materia.phonon_id.phonon_tools.html","tags":"","title":"Module principia_materia.phonon_id.phonon_tools"},{"body":"principia_materia.phonon_id.strained_finite_displacements module class principia_materia.phonon_id.strained_finite_displacements.StrainedFiniteDisplacements(structure, supa, fdtype=‘c’, tol=1e-06) Bases: FiniteDisplacements\nCompute finite difference of strain and displacements.\nThe class is capable of compute strain derivatives without atomic displacements, as well as derivatives of atomic displacements without strains.\nParameters\nstructure (CrystalFTG object or a structure file of CrystalFTG) – The crystal structure.\nsupa (array of int, shape(dim, dim)) – Supercell matrix.\nfdtype (str, choice of [“c”, “f”, “b”]) – Type of finite displacement.\ntol (float, optional, default to 1.0E-6) – Error tolerence.\ncreate_jobs(job_handler, prefix=None, config_file=‘strained_finite_displacements.yml’, append=False, dry_run=False) Create compute jobs for the finite displacements calculations.\nParameters\njob_handler (ComputeJobSeries or JobsDB) – The interface to create and collect result from compute jobs or a database.\nprefix (str, optional, default to None) – Prefix to the jobnames.\nconfig_file (str, optional, default to “finite_displacements.yml”) – The name of the finite displacements configuration file.\ndry_run (bool, optional, default to False) – If True, don’t actually create the job.\nproperty delta() The displacement amplitutes.\nproperty get_jobname() Return a jobname template function.\nIf attribute “_jobname_template” is set, return the value in the attribute, otherwise, return the default template.\nproperty order() set_delta(delta) Set the deltas to compute for the finite displacements calculations.\nParameters\ndelta (float or array of float) – The displacement amplitute.\nset_displacement_vectors(dispvecs, displabels, order=None) Setup displacement vectors for the finite displacement calculation.\nParameters\ndispvecs (array of float, shape(N, natoms, dim)) – Displacement vectors.\ndisplabels (list, lenth of N) – The name of the displacements.\norder (tuple of int, length of N) – The order of derivatives.\nset_finite_difference(overwrite=False) Initialize the finite difference object.\nset_jobname_template(template) Set custom jobname template\nMust be def template(job_id, prefix, index_pad): …\nParameters\ntemplate (callable, with parameters (job_id, prefix, index_pad)) – The jobname template function.\nset_jobs(jobname_prefix=’’, skip_zero=True) Parameters\njobname_prefix (str) – Prefix for jobnames.\nset_strain(strain, strain_orders=None) Set strain basis and derivative order of each basis.\nParameters\nstrain (array of float) –\nstrain_orders (int or array of int) –\nset_strain_delta(strain_delta) Set the perturbation amplitudes to compute strain derivatives.\nParameters\nstrain_delta (float or array of float) –\nset_strain_internal_displacements(strains, internal_displacements) property strain_delta() property uniq_strains() principia_materia.phonon_id.strained_finite_displacements.get_StrainedFD_from_configuration(config_file, file_type=‘yaml’, tol=1e-06) Read data from configuration file and construct a StrainedFiniteDisplacements object.\nParameters\nconfig_file (str) – Path to configuration file.\nfile_type (str, optional, default to “yaml”) – The type of the configuration file.\ntol (float, optional, default to 1.0E-6) – Error tolerance.\nprincipia_materia.phonon_id.strained_finite_displacements.get_strain_fd_config_hdf5_wrapper() principia_materia.phonon_id.strained_finite_displacements.get_strain_fd_config_yaml_wrapper(title=‘Strained Finite Displacements Configuration’) principia_materia.phonon_id.strained_finite_displacements.save_StrainedFD_config_to_hdf5(obj, directory, filename=‘strained_finite_displacements.hdf5’) Save strained finite displacements configuration in HDF5\nParameters\ndirectory (str) – The directory of the finite displacements dft jobs.\nfilename (str, optional, default to “finite_displacements.hdf5”) – The name of the configuration file.\nprincipia_materia.phonon_id.strained_finite_displacements.save_StrainedFD_config_to_yaml(obj, directory, filename=‘strained_finite_displacements.yml’, overwrite=False) Save strained finite displacements configuration in HDF5\nParameters\ndirectory (str) – The directory of the finite displacements dft jobs.\nfilename (str, optional, default to “finite_displacements.yml”) – The name of the configuration file.\n","categories":"","description":"Module principia_materia.phonon_id.strained_finite_displacements\n","excerpt":"Module principia_materia.phonon_id.strained_finite_displacements\n","ref":"/docs/references/principia_materia.phonon_id.strained_finite_displacements.html","tags":"","title":"Module principia_materia.phonon_id.strained_finite_displacements"},{"body":"principia_materia.plotting package Submodules principia_materia.plotting.kpath module\nKPath\nKPath.dim\nKPath.get_gridpoints_on_path()\nKPath.kpoints\nKPath.kpoints_distances\nKPath.n_vertices\nKPath.npoints\nKPath.point_on_kpath()\nKPath.rvec\nKPath.set_kpath()\nKPath.vertices\nKPath.vertices_distances\nKPath.vertices_names\nprincipia_materia.plotting.plot_band module\nget_band_plot_config_wrapper()\nmain()\nplot_band()\nprincipia_materia.plotting.plot_errortail module\nmain()\nplot_errortail()\nModule contents ","categories":"","description":"Module principia_materia.plotting\n","excerpt":"Module principia_materia.plotting\n","ref":"/docs/references/principia_materia.plotting.html","tags":"","title":"Module principia_materia.plotting"},{"body":"principia_materia.plotting.kpath module class principia_materia.plotting.kpath.KPath(vertices, vertices_names, npoints=101, rvec=None) Bases: object\nGenerate K-points path for plotting band structure.\nParameters\nvertices (array of Fraction or float, shape(N, dim) or shape(N-1, 2, dim)) – Vertices of K-path in either points or lines format.\nvertices_names (array of str, shape(N, )) – The name of the vertices points.\nnpoints (int, optional, default to 100) – The number of K-points to generate between a poir of vertices points.\nrvec (array of float, shape(dim, dim), optional, default to None) – Reciprocal basis vector used to renormalize K-points. If None, use identity matrix.\nproperty dim() Dimension of the K-points.\nget_gridpoints_on_path(supa, tol=1e-06) Find the grid points of a given mesh/supa that are on the K-points path.\nThis search algorithm can search beyond first BZ, finding points that are on non-trivial K-paths that are not fully within the first BZ.\nParameters\nsupa (array of int, shape(dim, dim)) – Supercell matrix.\ntol (float, optional, default to 1.0E-6) – Error tolerance.\nReturns\nkpoints (array of float, shape(N, dim)) – The K-points from supa that are on the path.\nkpoints_distances (array of float, shape(N)) – The distances of the K-points from supa that are on the path used in plotting.\nproperty kpoints() All the K-points generated along the K-path.\nproperty kpoints_distances() The distances of the K-points used in plotting.\nproperty n_vertices() Number of vertices points.\nproperty npoints() Number of points to generate between the vertices.\npoint_on_kpath(points, tol=1e-06) Find the distances of the K-points if they are on the K-path.\nParameters\npoints (array of float, shape(dim, ) or (N, dim)) – The points to check.\ntol (float, optional, default to 1.0E-6) – Error tolerance.\nReturns\ndistances – The distances of each points on the kpath used in plotting.\nReturn type\nnested list of float\nproperty rvec() Reciprocal basis vector to renormalize K-points.\nset_kpath() Generate the K-points along the K-path and their distances for plotting.\nproperty vertices() The vertices of K-path in lines format.\nproperty vertices_distances() The distances of the vertices K-points used in plotting.\nproperty vertices_names() The names of the veritces.\n","categories":"","description":"Module principia_materia.plotting.kpath\n","excerpt":"Module principia_materia.plotting.kpath\n","ref":"/docs/references/principia_materia.plotting.kpath.html","tags":"","title":"Module principia_materia.plotting.kpath"},{"body":"principia_materia.plotting.plot_band module principia_materia.plotting.plot_band.get_band_plot_config_wrapper(title=‘Band plot configuration’) principia_materia.plotting.plot_band.main(args=None) principia_materia.plotting.plot_band.plot_band(config, show=True, output=None, width_ratio=3, dpi=150) ","categories":"","description":"Module principia_materia.plotting.plot_band\n","excerpt":"Module principia_materia.plotting.plot_band\n","ref":"/docs/references/principia_materia.plotting.plot_band.html","tags":"","title":"Module principia_materia.plotting.plot_band"},{"body":"principia_materia.plotting.plot_errortail module principia_materia.plotting.plot_errortail.main(args=None) principia_materia.plotting.plot_errortail.plot_errortail(data, linestyle=’-’, marker=‘o’, pick_marker=‘D’, linecolor=‘tab:blue’, markercolor=‘tab:red’, iscomplex=False, imag_linecolor=‘tab:green’, imag_markercolor=‘tab:purple’, filename=None, dpi=150, show=True) ","categories":"","description":"Module principia_materia.plotting.plot_errortail\n","excerpt":"Module principia_materia.plotting.plot_errortail\n","ref":"/docs/references/principia_materia.plotting.plot_errortail.html","tags":"","title":"Module principia_materia.plotting.plot_errortail"},{"body":"principia_materia.representation package Submodules principia_materia.representation.base_representation module\nBaseRepresentation\nBaseRepresentation.G\nBaseRepresentation.basis\nBaseRepresentation.chi\nBaseRepresentation.construct_irreducible_basis()\nBaseRepresentation.irrvec_dict\nBaseRepresentation.construct_irrep_matrices()\nBaseRepresentation.irrep_matr\nBaseRepresentation.get_integer_irrvec()\nBaseRepresentation.has_multi_dim_irrep()\nBaseRepresentation.irreducible_basis_rowname\nBaseRepresentation.irrep_counter\nBaseRepresentation.irreps\nBaseRepresentation.irrvec\nBaseRepresentation.orthogonalize_modes()\nBaseRepresentation.project_irrep()\nBaseRepresentation.rdim\nkronecker_product()\nprincipia_materia.representation.charm_bloch_rep module\nCharmBlochRep\nCharmBlochRep.construct_irreducible_basis()\nCharmBlochRep.irrvec_dict\nCharmBlochRep.is_qpoint_Gamma\nCharmBlochRep.orthogonalize_shift_modes()\nprincipia_materia.representation.cluster_rep module\nClusterRep principia_materia.representation.direct_product module\nDirectProduct\nDirectProduct.irrep_matr get_irrep_name()\nprincipia_materia.representation.disp_cluster_rep module\nDispClusterRep\nDispClusterRep.orthogonalize_shift_modes() principia_materia.representation.qstar_rep module\nQStarRep\nQStarRep.find_multiplication_table()\nQStarRep.initial_Q\nSymmetricQStarRep\nSymmetricQStarRep.initial_Q principia_materia.representation.shift_mode module\nShiftMode\nShiftMode.set_shift_mode_vectors()\nShiftMode.irrep_counter\nShiftMode.shift_mode_vectors\nprincipia_materia.representation.single_tensor_rep module\nSingleTensorRep principia_materia.representation.symmetric_direct_product module\nSymmetricDirectProduct\nSymmetricDirectProduct.construct_irreducible_basis()\nSymmetricDirectProduct.irrvec_dict\nSymmetricDirectProduct.contract_dp_to_sdp_basis()\nSymmetricDirectProduct.direct_product\nSymmetricDirectProduct.irrep_matr\nSymmetricDirectProduct.rdim\nSymmetricDirectProduct.set_irreducible_basis_via_contraction()\nModule contents ","categories":"","description":"Module principia_materia.representation\n","excerpt":"Module principia_materia.representation\n","ref":"/docs/references/principia_materia.representation.html","tags":"","title":"Module principia_materia.representation"},{"body":"principia_materia.representation.base_representation module class principia_materia.representation.base_representation.BaseRepresentation(rdim, tol=1e-06) Bases: object\nThe abstract class for representations\nAs a abstract class for all different representations to derive from, this class contains the most core functionalities for representation, including the group elements, computing characters, decomposing irreducible representations, projecting irreducible basis, etc.\nAll derived representation classes need to implement following methods to be usable: __init__, _set_group_elements and _set_basis.\nproperty G() The matrix representation of the group elements.\nproperty basis() The name of the basis of the representation.\nThis is the original basis of the representation before symmetrization.\nReturns\nbasis – List of names of basis.\nReturn type\nlist of tuple or str\nproperty chi() The characters of the representation.\nReturns\nchi – The characters of the representation.\nReturn type\narray of int, length of number of classes in the group\nconstruct_irreducible_basis(seeds=None, identity_only=False) Construct irreducible basis using projection operators for all instances of existing irreducible representations\nirrvec_dict() A dictionary contains irreducible basis of every instances of existing irreducible basis.\nType\ndict with keys of tuple(str, int) and values of array of float or complex (same type as self.G) shape(dim of irrep, self.rdim)\nconstruct_irrep_matrices(use_Cornwell=True) Construct the representation matrices for irreps with dimension greater than 1.\nThese are only unique up to a unitary transformation, but we will pick a particular convention.\nirrep_matr() A nested dictionary with each multi-dimensional irreducible representation, a dictionary of the irrep matrices of each group element.\nType\ndict with keys of str and values of dict\nget_integer_irrvec(irrep_instance, max_number=500) Computes interger form of the irreducible basis.\nAttempts to compute the integer form of the given irreducible basis, if not successful, attempts make as many matrix elements into integer form as possible.\n$$ \\vec{v} \\times \\sqrt{n} | n \\in [1, max\\_number] $$\nReturns\nirrvec – The integer form of a irreducible basis.\nReturn type\narray of float or complex (same type as self.G), shape(dim of irrep, rdim)\nhas_multi_dim_irrep() property irreducible_basis_rowname() The names of the rows for the irreducible basis.\nReturns\nirreducible_basis_rowname – The name of the rows for the irreducible basis as tuple (irrep instance tuple, row number)\nReturn type\nlist of tuple(str, int), shape(self.rdim, )\nproperty irrep_counter() The dictionary of the irreducible representations and the number of instances.\nReturns\nirrep_counter – The dictionary of the irreducible representations as keys and the number of instances as values.\nReturn type\ndict with keys of str and values of int\nproperty irreps() A list of irreducible representations and it’s instance number.\nThis can be used to distinguish between different irreps as well as different instances of the same irrep.\nReturns\nirreps – Instances of irreducible representations as tuple(irrep name, instance number)\nReturn type\nlist of tuple(str, int), shape(number of irreps, )\nproperty irrvec() The matrix form of irreducible basis.\nReturns\nirrvec – Irreducible basis matrix.\nReturn type\narray of float or complex (same type as self.G)\northogonalize_modes(vectors) Orthogonalize modes against input vectors\nThe vectors can only be first rows of the existing irreps in the decomposition, the rest of the rows from each multi-dimensional irrep will be projected out.\nParameters\nvectors (array of dtype, shape(N, self.rdim)) – The vectors to orthogonlize against.\nproject_irrep(irrep, other=[], seeds=None, check_projection=True, without_irrep_matrices=False) Contruct irreducible basis of a given irreducible representation from the given representation.\nThe routine will consider if there are already irreps of that it needs to avoid. We will simply return a matrix of dimension (dim_irrep,dim_rep).\nParameters\nirrep (str) – Name of irrep to project.\nother (array of float, shape(n, dim of basis)) – Basis of other existing instances of the irrep.\nReturns\nvec_irrep – A matrix of basis vector(s) of the irrep.\nReturn type\narray of float, shape(dim of irrep, dim of basis)\nproperty rdim() Dimension of the representations\nprincipia_materia.representation.base_representation.kronecker_product(a, b) Kronecker product of 2 2-D arrays.\n","categories":"","description":"Module principia_materia.representation.base_representation\n","excerpt":"Module principia_materia.representation.base_representation\n","ref":"/docs/references/principia_materia.representation.base_representation.html","tags":"","title":"Module principia_materia.representation.base_representation"},{"body":"principia_materia.representation.charm_bloch_rep module class principia_materia.representation.charm_bloch_rep.CharmBlochRep(structure, pg, qpoint, tol=1e-06) Bases: BaseRepresentation\nPoint group representation of give q-point at given orbitals.\nParameters\nstructure (CrystalFTG object or a structure file of CrystalFTG) – The crystal structure.\npg (str or PointGroup object) – The point group.\nqpoint (array of Fraction or a parse_array supported Fraction array.) – The q-point\ntol (float, optional, default to 1.0E-6) – Error tolerence.\nconstruct_irreducible_basis(identity_only=False) Construct irreducible basis using projection operators for all instances of existing irreducible representations\nirrvec_dict() A dictionary contains irreducible basis of every instances of existing irreducible basis.\nType\ndict with keys of tuple(str, int) and values of array of float or complex (same type as self.G) shape(dim of irrep, self.rdim)\nproperty is_qpoint_Gamma() orthogonalize_shift_modes(remove=False) Parameters\nremove (bool, optional, default to False) – Whether to remove shift modes after orthogonalization.\n","categories":"","description":"Module principia_materia.representation.charm_bloch_rep\n","excerpt":"Module principia_materia.representation.charm_bloch_rep\n","ref":"/docs/references/principia_materia.representation.charm_bloch_rep.html","tags":"","title":"Module principia_materia.representation.charm_bloch_rep"},{"body":"principia_materia.representation.cluster_rep module class principia_materia.representation.cluster_rep.ClusterRep(cluster, pg, center=False, tol=1e-06) Bases: BaseRepresentation\nRepresentation of a cluster.\nA representation of a cluster can be rotated by point group and stay invariant. The class can figure out how the atoms in the cluster get rotated around and build the point group representation of the cluster and perform standard group theory operations.\nParameters\ncluster (Cluster object or a structure file of Cluster) – The cluster to compute point group representation of.\npg (str or PointGroup object) – The point group.\ncenter (bool, optional, default to False) – Whether to shift origin to center of the cluster.\ntol (float, optional, default to 1.0E-6) – Error tolerence.\n","categories":"","description":"Module principia_materia.representation.cluster_rep\n","excerpt":"Module principia_materia.representation.cluster_rep\n","ref":"/docs/references/principia_materia.representation.cluster_rep.html","tags":"","title":"Module principia_materia.representation.cluster_rep"},{"body":"principia_materia.representation.direct_product module class principia_materia.representation.direct_product.DirectProduct(pg, irrep_inputs, tol=1e-06) Bases: BaseRepresentation\nCompute direct product representation of irreducible representations of a point group\nParameters\npg (str or PointGroup object) – The point group\nirrep_inputs (list of str or tuple) – A list of irreducible representations to compute direct product with. Must be types supported by parser get_irrep_name.\ntol (float, optional, default to 1.0E-6) – Error tolerence.\nproperty irrep_matr() principia_materia.representation.direct_product.get_irrep_name(ir) Find name of irreducible representation from input\nParameters\nir (tuple or str) – Irreducible representation. Following types are supported:\ntuple type: (, ) irrep name in str type str type: “[]” ","categories":"","description":"Module principia_materia.representation.direct_product\n","excerpt":"Module principia_materia.representation.direct_product\n","ref":"/docs/references/principia_materia.representation.direct_product.html","tags":"","title":"Module principia_materia.representation.direct_product"},{"body":"principia_materia.representation.disp_cluster_rep module class principia_materia.representation.disp_cluster_rep.DispClusterRep(cluster, pg, orthogonalize_shifts=False, remove_shifts=False, center=False, tol=1e-06) Bases: BaseRepresentation\nRepresentation of the displacements of atoms in a cluster.\nComputes the point group representation of the displacements of atoms in a cluster.\nParameters\ncluster (Cluster object or a structure file of Cluster) – The cluster to compute point group representation of.\npg (str or PointGroup object) – The point group\northogonalize_shifts (bool, optional, default to False) – Whether to orthogonalize shift modes.\nremove_shifts (bool, optional, default to False) – Whether to remove shift modes after orthogonalization.\ncenter (bool, optional, default to False) – Whether to shift origin to center of the cluster.\ntol (float, optional, default to 1.0E-6) – Error tolerence.\northogonalize_shift_modes(remove=False) Find the shift modes in the cluster and orthogonalize irreducible with respect to those shift modes.\nParameters\nremove (bool, optional, default to False) – Whether to remove shift modes after orthogonalization.\n","categories":"","description":"Module principia_materia.representation.disp_cluster_rep\n","excerpt":"Module principia_materia.representation.disp_cluster_rep\n","ref":"/docs/references/principia_materia.representation.disp_cluster_rep.html","tags":"","title":"Module principia_materia.representation.disp_cluster_rep"},{"body":"principia_materia.representation.qstar_rep module class principia_materia.representation.qstar_rep.QStarRep(pg, rvec, Q, identifiers=None, tol=1e-06) Bases: BaseRepresentation\nRepresentation of Q-star\nIt represents how Q transform in the Q-star under symmetry operation of the point group.\nParameters\nQ – The initial Q.\npg – Point group.\nrvec – The reciprocal basis vector for q.\ntol – Number of decimal points to preserve for rounding.\nfind_multiplication_table() property initial_Q() class principia_materia.representation.qstar_rep.SymmetricQStarRep(pg, rvec, Q, identifiers=None, tol=1e-06) Bases: SymmetricDirectProduct\nSymmetric Product representation of Q\nIt represents how Q transform in the Q-star under symmetry operation of the point group, with an extra constraint that the order of the q-identifier pair does not matter.\n:param : pg: Point group. :param : irrep_inputs: A list of q’s or q-identifier pairs. :param : rvec: The reciprocal basis vector for q. :param : rdp: Number of decimal points to preserve for rounding.\nproperty initial_Q() ","categories":"","description":"Module principia_materia.representation.qstar_rep\n","excerpt":"Module principia_materia.representation.qstar_rep\n","ref":"/docs/references/principia_materia.representation.qstar_rep.html","tags":"","title":"Module principia_materia.representation.qstar_rep"},{"body":"principia_materia.representation.shift_mode module class principia_materia.representation.shift_mode.ShiftMode(pg, orbitals, tol=1e-06) Bases: BaseRepresentation\nThe point group representation of shift modes.\nParameters\npg (str or PointGroup object) – The point group.\norbitals (list of str) – A list or orbitals. Shift mode vectors will be computed base on this list.\ntol (float, optional, default to 1.0E-6) – Error tolerence.\nset_shift_mode_vectors() Computes the shift mode irreducible basis for the input orbitals list.\nThis method goes through the list of orbitals, construct the shift mode vectors, and orthonomalize them to keep the non-zero shift mode irreps and vectors.\nirrep_counter() shift_mode_vectors() ","categories":"","description":"Module principia_materia.representation.shift_mode\n","excerpt":"Module principia_materia.representation.shift_mode\n","ref":"/docs/references/principia_materia.representation.shift_mode.html","tags":"","title":"Module principia_materia.representation.shift_mode"},{"body":"principia_materia.representation.single_tensor_rep module class principia_materia.representation.single_tensor_rep.SingleTensorRep(rank, pg, dim=3, tol=1e-06) Bases: BaseRepresentation\nPoint group representation for a rank N tensor.\nParameters\nrank (int) – Rank of the tensor.\npg (str or PointGroup object) – The point group.\ndim (int, optional, default to 3) – Dimension of the space.\ntol (float, optional, default to 1.0E-6) – Error tolerence.\n","categories":"","description":"Module principia_materia.representation.single_tensor_rep\n","excerpt":"Module principia_materia.representation.single_tensor_rep\n","ref":"/docs/references/principia_materia.representation.single_tensor_rep.html","tags":"","title":"Module principia_materia.representation.single_tensor_rep"},{"body":"principia_materia.representation.symmetric_direct_product module class principia_materia.representation.symmetric_direct_product.SymmetricDirectProduct(pg, irrep_inputs, tol=1e-06) Bases: BaseRepresentation\nCompute symmetric direct product representation of irreducible representations of a point group\nParameters\npg (str or PointGroup object) – The point group\nirrep_inputs (list of str or tuple) – A list of irreducible representations to compute direct product with. Must be types supported by parser principia_materia.representation.direct_product.get_irrep_name.\ntol (float, optional, default to 1.0E-6) – Error tolerence.\nconstruct_irreducible_basis(identity_only=False) Construct irreducible basis using projection operators for all instances of existing irreducible representations\nirrvec_dict() A dictionary contains irreducible basis of every instances of existing irreducible basis.\nType\ndict with keys of tuple(str, int) and values of array of float or complex (same type as self.G) shape(dim of irrep, self.rdim)\ncontract_dp_to_sdp_basis() property direct_product() property irrep_matr() property rdim() Dimension of the representations\nset_irreducible_basis_via_contraction() This method will take the direct product irreps and contract them in order to get the irreps of the symmetric direct product. This is another means to get the essential information of the SDP.\n","categories":"","description":"Module principia_materia.representation.symmetric_direct_product\n","excerpt":"Module principia_materia.representation.symmetric_direct_product\n","ref":"/docs/references/principia_materia.representation.symmetric_direct_product.html","tags":"","title":"Module principia_materia.representation.symmetric_direct_product"},{"body":"principia_materia.symmetry package Submodules principia_materia.symmetry.cornwell_data module\nCornwell_group_matrices\nCornwell_group_matrices.D_M\nCornwell_group_matrices.D_M_text\nCornwell_group_matrices.D_X\nCornwell_group_matrices.D_X_text\nCornwell_group_matrices.D_p\nCornwell_group_matrices.D_p_text\nCornwell_group_matrices.D_pp\nCornwell_group_matrices.D_pp_text\nCornwell_group_matrices.Gamma_p\nCornwell_group_matrices.Gamma_p_text\nCornwell_group_matrices.Gamma_pp\nCornwell_group_matrices.Gamma_pp_text\nCornwell_group_matrices.R\nCornwell_group_matrices.R_text\nCornwell_group_matrices.S\nCornwell_group_matrices.S_text\nCornwell_group_matrices.i\nCornwell_group_matrices.ii\nCornwell_group_matrices.jj\nCornwell_group_matrices.kk\nCornwell_point_group\nCornwell_point_group.get_mirror_notation()\nCornwell_point_group.parse_data()\nCornwell_point_group.parse_irrep_matr()\nprincipia_materia.symmetry.little_group module\nget_little_group() principia_materia.symmetry.point_group module\nPointGroup\nPointGroup.check_irrep_matr()\nPointGroup.clas\nPointGroup.create_all_pg()\nPointGroup.create_alternate_pgs()\nPointGroup.create_pgop_to_pg()\nPointGroup.find_multiplication_table()\nPointGroup.init_from()\nPointGroup.init_from_operators()\nPointGroup.set_alias()\nPointGroup.set_clas()\nPointGroup.set_ct()\nPointGroup.set_gmatr()\nPointGroup.set_iname()\nPointGroup.set_irrep_matr()\nPointGroup.set_mirror_notation()\nPointGroup.set_subgroups()\nPointGroup.store_characters()\nclass_method_descriptor\nfind_inv()\ngroup_lineage()\nModule contents ","categories":"","description":"Module principia_materia.symmetry\n","excerpt":"Module principia_materia.symmetry\n","ref":"/docs/references/principia_materia.symmetry.html","tags":"","title":"Module principia_materia.symmetry"},{"body":"principia_materia.symmetry.cornwell_data module class principia_materia.symmetry.cornwell_data.Cornwell_group_matrices() Bases: object\nThis class is a simple container holding all of the rotation matrices that are used within the point groups. This information was taken from Appendix C of ‘Group Theory in Physics’ by J.F. Cornwell, 1997 Edition. Everything is input in a human readable form, and then processed into matrices. These matrices can be used in conjunction with the Cornwell character table data.\nD_M(_ = {‘E’: array([[1., 0.], [0., 1.]]), ‘c2e’: array([[0., 1.], [1., 0.]]), ‘c2f’: array([[ 0., -1.], [-1., 0.]]), ‘c2x’: array([[-1., 0.], [ 0., -1.]]), ‘c2y’: array([[ 1., 0.], [ 0., -1.]]), ‘c2z’: array([[-1., 0.], [ 0., 1.]]), ‘c4x’: array([[ 0., 1.], [-1., 0.]]), ‘ci4x’: array([[ 0., -1.], [ 1., 0.]])_ ) D_M_text(_ = ‘\\n E 1 0 0 1\\n c2x -1 0 0 -1 \\n c2y 1 0 0 -1\\n c2z -1 0 0 1 \\n c4x 0 1 -1 0 \\n ci4x 0 -1 1 0 \\n c2e 0 1 1 0\\n c2f 0 -1 -1 0\\n _ ) D_X(_ = {‘E’: array([[1., 0.], [0., 1.]]), ‘c2a’: array([[0., 1.], [1., 0.]]), ‘c2b’: array([[ 0., -1.], [-1., 0.]]), ‘c2x’: array([[ 1., 0.], [ 0., -1.]]), ‘c2y’: array([[-1., 0.], [ 0., 1.]]), ‘c2z’: array([[-1., 0.], [ 0., -1.]]), ‘c4z’: array([[ 0., 1.], [-1., 0.]]), ‘ci4z’: array([[ 0., -1.], [ 1., 0.]])_ ) D_X_text(_ = ‘\\n E 1 0 0 1\\n c2x 1 0 0 -1\\n c2y -1 0 0 1\\n c2z -1 0 0 -1 \\n c4z 0 1 -1 0 \\n ci4z 0 -1 1 0\\n c2a 0 1 1 0\\n c2b 0 -1 -1 0\\n _ ) D_p(_ = {‘E’: array([[1., 0.], [0., 1.]]), ‘c2A’: array([[ 0.5 , -0.8660254], [-0.8660254, -0.5 ]]), ‘c2B’: array([[ 0.5 , 0.8660254], [ 0.8660254, -0.5 ]]), ‘c2C’: array([[ 0.5 , -0.8660254], [-0.8660254, -0.5 ]]), ‘c2D’: array([[ 0.5 , 0.8660254], [ 0.8660254, -0.5 ]]), ‘c2x’: array([[-1., 0.], [ 0., 1.]]), ‘c2y’: array([[-1., 0.], [ 0., 1.]]), ‘c2z’: array([[1., 0.], [0., 1.]]), ‘c3z’: array([[-0.5 , 0.8660254], [-0.8660254, -0.5 ]]), ‘c6z’: array([[-0.5 , -0.8660254], [ 0.8660254, -0.5 ]]), ‘ci3z’: array([[-0.5 , -0.8660254], [ 0.8660254, -0.5 ]]), ‘ci6z’: array([[-0.5 , 0.8660254], [-0.8660254, -0.5 ]])_ ) D_p_text(_ = ‘\\n E c2z 1 0 0 1\\n c6z ci3z -1/2. -3**0.5/2. 3**0.5/2. -1/2.\\n ci6z c3z -1/2. 3**0.5/2. -3**0.5/2. -1/2.\\n c2x c2y -1 0 0 1\\n c2A c2C 1/2. -3**0.5/2. -3**0.5/2. -1/2.\\n c2B c2D 1/2. 3**0.5/2. 3**0.5/2. -1/2.\\n _ ) D_pp(_ = {‘E’: array([[1., 0.], [0., 1.]]), ‘c2A’: array([[-0.5 , 0.8660254], [ 0.8660254, 0.5 ]]), ‘c2B’: array([[-0.5 , -0.8660254], [-0.8660254, 0.5 ]]), ‘c2C’: array([[ 0.5 , -0.8660254], [-0.8660254, -0.5 ]]), ‘c2D’: array([[ 0.5 , 0.8660254], [ 0.8660254, -0.5 ]]), ‘c2x’: array([[ 1., 0.], [ 0., -1.]]), ‘c2y’: array([[-1., 0.], [ 0., 1.]]), ‘c2z’: array([[-1., 0.], [ 0., -1.]]), ‘c3z’: array([[-0.5 , 0.8660254], [-0.8660254, -0.5 ]]), ‘c6z’: array([[ 0.5 , 0.8660254], [-0.8660254, 0.5 ]]), ‘ci3z’: array([[-0.5 , -0.8660254], [ 0.8660254, -0.5 ]]), ‘ci6z’: array([[ 0.5 , -0.8660254], [ 0.8660254, 0.5 ]])_ ) D_pp_text(_ = ‘\\n E 1 0 0 1 \\n c6z 1/2. 3**0.5/2. -3**0.5/2. 1/2.\\n ci6z 1/2. -3**0.5/2. 3**0.5/2. 1/2.\\n c3z -1/2. 3**0.5/2. -3**0.5/2. -1/2.\\n ci3z -1/2. -3**0.5/2. 3**0.5/2. -1/2.\\n c2z -1 0 0 -1\\n c2x 1 0 0 -1 \\n c2A -1/2. 3**0.5/2. 3**0.5/2. 1/2.\\n c2B -1/2. -3**0.5/2. -3**0.5/2. 1/2.\\n c2y -1 0 0 1\\n c2C 1/2. -3**0.5/2. -3**0.5/2. -1/2.\\n c2D 1/2. 3**0.5/2. 3**0.5/2. -1/2.\\n _ ) Gamma_p(_ = {‘E’: array([[1., 0., 0.], [0., 1., 0.], [0., 0., 1.]]), ‘c2a’: array([[ 1., 0., 0.], [ 0., 0., -1.], [ 0., -1., 0.]]), ‘c2b’: array([[1., 0., 0.], [0., 0., 1.], [0., 1., 0.]]), ‘c2c’: array([[ 0., -1., 0.], [-1., 0., 0.], [ 0., 0., 1.]]), ‘c2d’: array([[0., 1., 0.], [1., 0., 0.], [0., 0., 1.]]), ‘c2e’: array([[ 0., 0., -1.], [ 0., 1., 0.], [-1., 0., 0.]]), ‘c2f’: array([[0., 0., 1.], [0., 1., 0.], [1., 0., 0.]]), ‘c2x’: array([[-1., 0., 0.], [ 0., 1., 0.], [ 0., 0., -1.]]), ‘c2y’: array([[-1., 0., 0.], [ 0., -1., 0.], [ 0., 0., 1.]]), ‘c2z’: array([[ 1., 0., 0.], [ 0., -1., 0.], [ 0., 0., -1.]]), ‘c3al’: array([[ 0., -1., 0.], [ 0., 0., 1.], [-1., 0., 0.]]), ‘c3be’: array([[ 0., 1., 0.], [ 0., 0., -1.], [-1., 0., 0.]]), ‘c3de’: array([[0., 1., 0.], [0., 0., 1.], [1., 0., 0.]]), ‘c3ga’: array([[ 0., -1., 0.], [ 0., 0., -1.], [ 1., 0., 0.]]), ‘c4x’: array([[ 0., 0., 1.], [ 0., -1., 0.], [-1., 0., 0.]]), ‘c4y’: array([[ 0., -1., 0.], [ 1., 0., 0.], [ 0., 0., -1.]]), ‘c4z’: array([[-1., 0., 0.], [ 0., 0., -1.], [ 0., 1., 0.]]), ‘ci3al’: array([[ 0., 0., -1.], [-1., 0., 0.], [ 0., 1., 0.]]), ‘ci3be’: array([[ 0., 0., -1.], [ 1., 0., 0.], [ 0., -1., 0.]]), ‘ci3de’: array([[0., 0., 1.], [1., 0., 0.], [0., 1., 0.]]), ‘ci3ga’: array([[ 0., 0., 1.], [-1., 0., 0.], [ 0., -1., 0.]]), ‘ci4x’: array([[ 0., 0., -1.], [ 0., -1., 0.], [ 1., 0., 0.]]), ‘ci4y’: array([[ 0., 1., 0.], [-1., 0., 0.], [ 0., 0., -1.]]), ‘ci4z’: array([[-1., 0., 0.], [ 0., 0., 1.], [ 0., -1., 0.]])_ ) Gamma_p_text(_ = ‘\\n E 1 0 0 0 1 0 0 0 1 \\n c2x -1 0 0 0 1 0 0 0 -1 \\n c2y -1 0 0 0 -1 0 0 0 1 \\n c2z 1 0 0 0 -1 0 0 0 -1 \\n c4x 0 0 1 0 -1 0 -1 0 0 \\n ci4x 0 0 -1 0 -1 0 1 0 0 \\n c4y 0 -1 0 1 0 0 0 0 -1 \\n ci4y 0 1 0 -1 0 0 0 0 -1 \\n c4z -1 0 0 0 0 -1 0 1 0 \\n ci4z -1 0 0 0 0 1 0 -1 0 \\n c2a 1 0 0 0 0 -1 0 -1 0 \\n c2b 1 0 0 0 0 1 0 1 0 \\n c2c 0 -1 0 -1 0 0 0 0 1 \\n c2d 0 1 0 1 0 0 0 0 1 \\n c2e 0 0 -1 0 1 0 -1 0 0 \\n c2f 0 0 1 0 1 0 1 0 0 \\n c3al 0 -1 0 0 0 1 -1 0 0 \\n c3be 0 1 0 0 0 -1 -1 0 0 \\n c3ga 0 -1 0 0 0 -1 1 0 0 \\n c3de 0 1 0 0 0 1 1 0 0 \\n ci3al 0 0 -1 -1 0 0 0 1 0 \\n ci3be 0 0 -1 1 0 0 0 -1 0 \\n ci3ga 0 0 1 -1 0 0 0 -1 0 \\n ci3de 0 0 1 1 0 0 0 1 0 \\n _ ) Gamma_pp(_ = {‘E’: array([[1., 0.], [0., 1.]]), ‘c2a’: array([[-1., 0.], [ 0., 1.]]), ‘c2b’: array([[-1., 0.], [ 0., 1.]]), ‘c2c’: array([[ 0.5 , 0.8660254], [ 0.8660254, -0.5 ]]), ‘c2d’: array([[ 0.5 , 0.8660254], [ 0.8660254, -0.5 ]]), ‘c2e’: array([[ 0.5 , -0.8660254], [-0.8660254, -0.5 ]]), ‘c2f’: array([[ 0.5 , -0.8660254], [-0.8660254, -0.5 ]]), ‘c2x’: array([[1., 0.], [0., 1.]]), ‘c2y’: array([[1., 0.], [0., 1.]]), ‘c2z’: array([[1., 0.], [0., 1.]]), ‘c3al’: array([[-0.5 , -0.8660254], [ 0.8660254, -0.5 ]]), ‘c3be’: array([[-0.5 , -0.8660254], [ 0.8660254, -0.5 ]]), ‘c3de’: array([[-0.5 , -0.8660254], [ 0.8660254, -0.5 ]]), ‘c3ga’: array([[-0.5 , -0.8660254], [ 0.8660254, -0.5 ]]), ‘c4x’: array([[ 0.5 , -0.8660254], [-0.8660254, -0.5 ]]), ‘c4y’: array([[ 0.5 , 0.8660254], [ 0.8660254, -0.5 ]]), ‘c4z’: array([[-1., 0.], [ 0., 1.]]), ‘ci3al’: array([[-0.5 , 0.8660254], [-0.8660254, -0.5 ]]), ‘ci3be’: array([[-0.5 , 0.8660254], [-0.8660254, -0.5 ]]), ‘ci3de’: array([[-0.5 , 0.8660254], [-0.8660254, -0.5 ]]), ‘ci3ga’: array([[-0.5 , 0.8660254], [-0.8660254, -0.5 ]]), ‘ci4x’: array([[ 0.5 , -0.8660254], [-0.8660254, -0.5 ]]), ‘ci4y’: array([[ 0.5 , 0.8660254], [ 0.8660254, -0.5 ]]), ‘ci4z’: array([[-1., 0.], [ 0., 1.]])_ ) Gamma_pp_text(_ = ‘\\n E c2x c2y c2z 1 0 0 1 \\n c3al c3be c3ga c3de -1/2. -3**0.5/2. 3**0.5/2. -1/2.\\n ci3al ci3be ci3ga ci3de -1/2. 3**0.5/2. -3**0.5/2. -1/2.\\n c4x ci4x c2e c2f 1/2. -3**0.5/2. -3**0.5/2. -1/2.\\n c4y ci4y c2c c2d 1/2. 3**0.5/2. 3**0.5/2. -1/2.\\n c4z ci4z c2a c2b -1 0 0 1\\n _ ) R(_ = {‘E’: array([[1., 0., 0.], [0., 1., 0.], [0., 0., 1.]]), ‘I’: array([[-1., -0., -0.], [-0., -1., -0.], [-0., -0., -1.]]), ‘II’: array([[1., 0., 0.], [0., 1., 0.], [0., 0., 1.]]), ‘Ic2A’: array([[ 0.5 , -0.8660254, -0. ], [-0.8660254, -0.5 , -0. ], [-0. , -0. , 1. ]]), ‘Ic2B’: array([[ 0.5 , 0.8660254, -0. ], [ 0.8660254, -0.5 , -0. ], [-0. , -0. , 1. ]]), ‘Ic2C’: array([[-0.5 , 0.8660254, -0. ], [ 0.8660254, 0.5 , -0. ], [-0. , -0. , 1. ]]), ‘Ic2D’: array([[-0.5 , -0.8660254, -0. ], [-0.8660254, 0.5 , -0. ], [-0. , -0. , 1. ]]), ‘Ic2a’: array([[-0., -1., -0.], [-1., -0., -0.], [-0., -0., 1.]]), ‘Ic2b’: array([[-0., 1., -0.], [ 1., -0., -0.], [-0., -0., 1.]]), ‘Ic2c’: array([[-0., -0., -1.], [-0., 1., -0.], [-1., -0., -0.]]), ‘Ic2d’: array([[-0., -0., 1.], [-0., 1., -0.], [ 1., -0., -0.]]), ‘Ic2e’: array([[ 1., -0., -0.], [-0., -0., -1.], [-0., -1., -0.]]), ‘Ic2f’: array([[ 1., -0., -0.], [-0., -0., 1.], [-0., 1., -0.]]), ‘Ic2x’: array([[-1., -0., -0.], [-0., 1., -0.], [-0., -0., 1.]]), ‘Ic2y’: array([[ 1., -0., -0.], [-0., -1., -0.], [-0., -0., 1.]]), ‘Ic2z’: array([[ 1., -0., -0.], [-0., 1., -0.], [-0., -0., -1.]]), ‘Ic3al’: array([[-0., -1., -0.], [-0., -0., 1.], [ 1., -0., -0.]]), ‘Ic3be’: array([[-0., 1., -0.], [-0., -0., 1.], [-1., -0., -0.]]), ‘Ic3de’: array([[-0., -1., -0.], [-0., -0., -1.], [-1., -0., -0.]]), ‘Ic3ga’: array([[-0., 1., -0.], [-0., -0., -1.], [ 1., -0., -0.]]), ‘Ic3z’: array([[ 0.5 , -0.8660254, -0. ], [ 0.8660254, 0.5 , -0. ], [-0. , -0. , -1. ]]), ‘Ic4x’: array([[-1., -0., -0.], [-0., -0., -1.], [-0., 1., -0.]]), ‘Ic4y’: array([[-0., -0., 1.], [-0., -1., -0.], [-1., -0., -0.]]), ‘Ic4z’: array([[-0., -1., -0.], [ 1., -0., -0.], [-0., -0., -1.]]), ‘Ic6z’: array([[-0.5 , -0.8660254, -0. ], [ 0.8660254, -0.5 , -0. ], [-0. , -0. , -1. ]]), ‘Ici3al’: array([[-0., -0., 1.], [-1., -0., -0.], [-0., 1., -0.]]), ‘Ici3be’: array([[-0., -0., -1.], [ 1., -0., -0.], [-0., 1., -0.]]), ‘Ici3de’: array([[-0., -0., -1.], [-1., -0., -0.], [-0., -1., -0.]]), ‘Ici3ga’: array([[-0., -0., 1.], [ 1., -0., -0.], [-0., -1., -0.]]), ‘Ici3z’: array([[ 0.5 , 0.8660254, -0. ], [-0.8660254, 0.5 , -0. ], [-0. , -0. , -1. ]]), ‘Ici4x’: array([[-1., -0., -0.], [-0., -0., 1.], [-0., -1., -0.]]), ‘Ici4y’: array([[-0., -0., -1.], [-0., -1., -0.], [ 1., -0., -0.]]), ‘Ici4z’: array([[-0., 1., -0.], [-1., -0., -0.], [-0., -0., -1.]]), ‘Ici6z’: array([[-0.5 , 0.8660254, -0. ], [-0.8660254, -0.5 , -0. ], [-0. , -0. , -1. ]]), ‘c2A’: array([[-0.5 , 0.8660254, 0. ], [ 0.8660254, 0.5 , 0. ], [ 0. , 0. , -1. ]]), ‘c2B’: array([[-0.5 , -0.8660254, 0. ], [-0.8660254, 0.5 , 0. ], [ 0. , 0. , -1. ]]), ‘c2C’: array([[ 0.5 , -0.8660254, 0. ], [-0.8660254, -0.5 , 0. ], [ 0. , 0. , -1. ]]), ‘c2D’: array([[ 0.5 , 0.8660254, 0. ], [ 0.8660254, -0.5 , 0. ], [ 0. , 0. , -1. ]]), ‘c2a’: array([[ 0., 1., 0.], [ 1., 0., 0.], [ 0., 0., -1.]]), ‘c2b’: array([[ 0., -1., 0.], [-1., 0., 0.], [ 0., 0., -1.]]), ‘c2c’: array([[ 0., 0., 1.], [ 0., -1., 0.], [ 1., 0., 0.]]), ‘c2d’: array([[ 0., 0., -1.], [ 0., -1., 0.], [-1., 0., 0.]]), ‘c2e’: array([[-1., 0., 0.], [ 0., 0., 1.], [ 0., 1., 0.]]), ‘c2f’: array([[-1., 0., 0.], [ 0., 0., -1.], [ 0., -1., 0.]]), ‘c2x’: array([[ 1., 0., 0.], [ 0., -1., 0.], [ 0., 0., -1.]]), ‘c2y’: array([[-1., 0., 0.], [ 0., 1., 0.], [ 0., 0., -1.]]), ‘c2z’: array([[-1., 0., 0.], [ 0., -1., 0.], [ 0., 0., 1.]]), ‘c3al’: array([[ 0., 1., 0.], [ 0., 0., -1.], [-1., 0., 0.]]), ‘c3be’: array([[ 0., -1., 0.], [ 0., 0., -1.], [ 1., 0., 0.]]), ‘c3de’: array([[0., 1., 0.], [0., 0., 1.], [1., 0., 0.]]), ‘c3ga’: array([[ 0., -1., 0.], [ 0., 0., 1.], [-1., 0., 0.]]), ‘c3z’: array([[-0.5 , 0.8660254, 0. ], [-0.8660254, -0.5 , 0. ], [ 0. , 0. , 1. ]]), ‘c4x’: array([[ 1., 0., 0.], [ 0., 0., 1.], [ 0., -1., 0.]]), ‘c4y’: array([[ 0., 0., -1.], [ 0., 1., 0.], [ 1., 0., 0.]]), ‘c4z’: array([[ 0., 1., 0.], [-1., 0., 0.], [ 0., 0., 1.]]), ‘c6z’: array([[ 0.5 , 0.8660254, 0. ], [-0.8660254, 0.5 , 0. ], [ 0. , 0. , 1. ]]), ‘ci3al’: array([[ 0., 0., -1.], [ 1., 0., 0.], [ 0., -1., 0.]]), ‘ci3be’: array([[ 0., 0., 1.], [-1., 0., 0.], [ 0., -1., 0.]]), ‘ci3de’: array([[0., 0., 1.], [1., 0., 0.], [0., 1., 0.]]), ‘ci3ga’: array([[ 0., 0., -1.], [-1., 0., 0.], [ 0., 1., 0.]]), ‘ci3z’: array([[-0.5 , -0.8660254, 0. ], [ 0.8660254, -0.5 , 0. ], [ 0. , 0. , 1. ]]), ‘ci4x’: array([[ 1., 0., 0.], [ 0., 0., -1.], [ 0., 1., 0.]]), ‘ci4y’: array([[ 0., 0., 1.], [ 0., 1., 0.], [-1., 0., 0.]]), ‘ci4z’: array([[ 0., -1., 0.], [ 1., 0., 0.], [ 0., 0., 1.]]), ‘ci6z’: array([[ 0.5 , -0.8660254, 0. ], [ 0.8660254, 0.5 , 0. ], [ 0. , 0. , 1. ]])_ ) R_text(_ = ‘\\n E 1 0 0 0 1 0 0 0 1\\n c2x 1 0 0 0 -1 0 0 0 -1\\n c2y -1 0 0 0 1 0 0 0 -1\\n c2z -1 0 0 0 -1 0 0 0 1\\n c4x 1 0 0 0 0 1 0 -1 0\\n ci4x 1 0 0 0 0 -1 0 1 0\\n c4y 0 0 -1 0 1 0 1 0 0\\n ci4y 0 0 1 0 1 0 -1 0 0\\n c4z 0 1 0 -1 0 0 0 0 1\\n ci4z 0 -1 0 1 0 0 0 0 1\\n c2a 0 1 0 1 0 0 0 0 -1\\n c2b 0 -1 0 -1 0 0 0 0 -1\\n c2c 0 0 1 0 -1 0 1 0 0\\n c2d 0 0 -1 0 -1 0 -1 0 0\\n c2e -1 0 0 0 0 1 0 1 0\\n c2f -1 0 0 0 0 -1 0 -1 0\\n c3al 0 1 0 0 0 -1 -1 0 0\\n c3be 0 -1 0 0 0 -1 1 0 0\\n c3ga 0 -1 0 0 0 1 -1 0 0\\n c3de 0 1 0 0 0 1 1 0 0\\n ci3al 0 0 -1 1 0 0 0 -1 0 \\n ci3be 0 0 1 -1 0 0 0 -1 0\\n ci3ga 0 0 -1 -1 0 0 0 1 0 \\n ci3de 0 0 1 1 0 0 0 1 0 \\n c3z -1/2. 3**0.5/2. 0 -3**0.5/2. -1/2. 0 0 0 1\\n ci3z -1/2. -3**0.5/2. 0 3**0.5/2. -1/2. 0 0 0 1\\n c6z 1/2. 3**0.5/2. 0 -3**0.5/2. 1/2. 0 0 0 1\\n ci6z 1/2. -3**0.5/2. 0 3**0.5/2. 1/2. 0 0 0 1\\n c2A -1/2. 3**0.5/2. 0 3**0.5/2. 1/2. 0 0 0 -1\\n c2B -1/2. -3**0.5/2. 0 -3**0.5/2. 1/2. 0 0 0 -1\\n c2C 1/2. -3**0.5/2. 0 -3**0.5/2. -1/2. 0 0 0 -1\\n c2D 1/2. 3**0.5/2. 0 3**0.5/2. -1/2. 0 0 0 -1\\n _ ) S(_ = {‘E’: array([[1., 0.], [0., 1.]]), ‘c2c’: array([[0., 1.], [1., 0.]]), ‘c2d’: array([[ 0., -1.], [-1., 0.]]), ‘c2x’: array([[ 1., 0.], [ 0., -1.]]), ‘c2y’: array([[-1., 0.], [ 0., -1.]]), ‘c2z’: array([[-1., 0.], [ 0., 1.]]), ‘c4y’: array([[ 0., -1.], [ 1., 0.]]), ‘ci4y’: array([[ 0., 1.], [-1., 0.]])_ ) S_text(_ = ‘\\n E 1 0 0 1 \\n c2y -1 0 0 -1\\n c2c 0 1 1 0\\n c2d 0 -1 -1 0\\n c4y 0 -1 1 0\\n ci4y 0 1 -1 0 \\n c2x 1 0 0 -1\\n c2z -1 0 0 1\\n _ ) i(_ = ‘c2D_ ) ii(_ = [‘c2z’, ‘-1’, ‘0’, ‘0’, ‘1’_ ) jj(_ = [‘c2B’, ‘c2D’_ ) kk(_ = [‘1/2.’, ‘3**0.5/2.’, ‘3**0.5/2.’, ‘-1/2.’_ ) class principia_materia.symmetry.cornwell_data.Cornwell_point_group(pgn) Bases: object\nThis class is a simple container holding all of the information on the crystallographic point groups. This information was taken from Appendix C of ‘Group Theory in Physics’ by J.F. Cornwell, 1997 Edition. Information includes the classes, character tables, irrep matrices, and subgroups. When combined with the information from Cornwell_group_matrices, these classes can be used to instantiate the point group class.\nget_mirror_notation() This method provides a dictionary to map between Cornwell notation and mirror plane notation.\nparse_data() parse_irrep_matr() This method will parse the input for the irrep matrices. This is basically just encoding what is given in the Appendix of Cornwell. We store all the necessary matrices in Cornwell_group_matrices, but we need to know which ones to take and whether or not we should mutliply by -1. A have created the following syntax: Eg | c 1 Gamma_pp | I 1 Gamma_pp T1g | c 1 R | I 1 R\nFirst we have the irrep, then we have either one or two (two in this case) 3-tuple sets of info. The first item ‘c’ tells us that this is the proper rotations, we should use matrices Gamma_pp from Cornwell, and we should multiply by the prefactor of ‘1’. The same logic applies to the next set of info which corresponds to the improper rotations.\n","categories":"","description":"Module principia_materia.symmetry.cornwell_data\n","excerpt":"Module principia_materia.symmetry.cornwell_data\n","ref":"/docs/references/principia_materia.symmetry.cornwell_data.html","tags":"","title":"Module principia_materia.symmetry.cornwell_data"},{"body":"principia_materia.symmetry.little_group module principia_materia.symmetry.little_group.get_little_group(Qpoint, pg, rvec, subgroup=False, tol=1e-06) ","categories":"","description":"Module principia_materia.symmetry.little_group\n","excerpt":"Module principia_materia.symmetry.little_group\n","ref":"/docs/references/principia_materia.symmetry.little_group.html","tags":"","title":"Module principia_materia.symmetry.little_group"},{"body":"principia_materia.symmetry.point_group module class principia_materia.symmetry.point_group.PointGroup(inp, mirror_notation=False) Bases: object\nThis class allows one to encode all of the information about a point group, including the character table. This class mainly is a container for data. The only nontrivial method is for rotating to a different coordinate system.\ncheck_irrep_matr(tol=1e-06) Check if the irrep matrices match the character table.\nThis will check if the irrep matrices that were entered have the proper characters as prescribed by the character table, and we will confirm that they are unitary. This ensures no typos with Cornwell_group_matrices and that no typos are made when entering the point group info below.\nproperty clas() clas will be the alias if set, otherwise it will return the default class names in Cornwell.\nclassmethod create_all_pg() Create all point groups that are listed in Cornwell class and return them as a dictionary.\ncreate_alternate_pgs() Create a list of PointGroup instances enumerating all the different class choices given by clas_choices in Cornwell_point_group.\nclassmethod create_pgop_to_pg() Create a dictionary which maps a tuple of group elements to a point group. The keys must be sorted, and the values are a tuple containing the point group name and the default class.\nfind_multiplication_table(G={}, names=True) This method will find the multiplication table, and it can be returned either in terms of the element names or numbers.\nThe latter is useful to determine if two groups are isomorphic.\nclassmethod init_from(inp) Construct PointGroup object from either a point group name or a list of point group operators.\nclassmethod init_from_operators(pgop) Construct PointGroup object from a list of point group operators.\nset_alias(mapd) Rename the group elements according to the mapping provided by the dictionary mapd.\nset_clas(clas=None) Set the classes using the same notation as in Cornwell file.\nThe different classes are split on the ‘|’, for example:\nE | c3z ci3z | Ic2x Ic2A Ic2B | c2z | c6z ci6z | Ic2y Ic2C Ic2D set_ct(ct=None) Set the character table values as a string using the same notation as in Cornwell file.\nThe default is to take these from Cornwell. A set can be provided as a string:\n1 1 1 1 1 1 1 1 -1 1 1 -1 ... set_gmatr(gmatr=None) Set the group element matrices. The default is to take these from Cornwell.\nA set can be provided as a string (needs to be updated to CP data) or a list of matrices.\nset_iname(iname=None) Set the names of the irreps.\nset_irrep_matr(irrep_matr=None) Set the irreducible representation matrices. They are either taken from Cornwell, or input, or neither.\nThese are not required given that our representation code can compute them.\nset_mirror_notation() set_subgroups() store_characters() Create an OrderedDict characters which stores the character for each group element.\nThis is needed when using the projection operator.\nclass principia_materia.symmetry.point_group.class_method_descriptor(func) Bases: object\nprincipia_materia.symmetry.point_group.find_inv(group, sym_op) This function finds the inverse group operator of the input, in the given point group.\nprincipia_materia.symmetry.point_group.group_lineage(parent, child) Determine the lineage of two groups.\nParameters\nparent (instance of PointGroup) – The parent group.\nchild (instance of PointGroup) – The child group.\nReturns\npc_lineage – A dictionary with keys being a parent irrep and values being a corresponding OrderedDict containing keys with child irreps and values of number of nonzero instances.\nReturn type\nOrderedDict\n","categories":"","description":"Module principia_materia.symmetry.point_group\n","excerpt":"Module principia_materia.symmetry.point_group\n","ref":"/docs/references/principia_materia.symmetry.point_group.html","tags":"","title":"Module principia_materia.symmetry.point_group"},{"body":"principia_materia.tetrahedron package Submodules principia_materia.tetrahedron.tetrahedra module\nTetrahedra\nTetrahedra.diagonal_vecs\nTetrahedra.itet_kpoint_ind_fort\nTetrahedra.make_tetrahedrons()\nTetrahedra.tet_kpoint_ind\nTetrahedra.itet_kpoint_ind\nTetrahedra.itet_map\nTetrahedra.itet_mult\nTetrahedra.ptets\nTetrahedra.shortest_diagonals\nTetrahedra.tet_kpoint_ind_fort\nTetrahedra.tet_mult\nModule contents ","categories":"","description":"Module principia_materia.tetrahedron\n","excerpt":"Module principia_materia.tetrahedron\n","ref":"/docs/references/principia_materia.tetrahedron.html","tags":"","title":"Module principia_materia.tetrahedron"},{"body":"principia_materia.tetrahedron.tetrahedra module class principia_materia.tetrahedron.tetrahedra.Tetrahedra(vec, supa, pg=None, tol=1e-06) Bases: Kpoints\nK-vectors for tetrahedron integration of the reciprocal space\nproperty diagonal_vecs() property itet_kpoint_ind_fort() make_tetrahedrons() Find the irreducible tetrahedra\nConstruct the tetrahedra in terms of irreducible K-vectors and reduce this list of terahedra to a irreducible set.\ntet_kpoint_ind() Tetrahedra in terms of indices of irreducible K-vectors in the irreducible K-vector list.\nType\narray of int, shape(self.vol * 6, 4)\nitet_kpoint_ind() Irreducible tetrahedra in terms of indices of irreducible K-vectors in the irreducible K-vector list.\nType\narray of int, shape(N, 4)\nitet_map() The index of irreducible tetrahedra of each tetradedron.\nType\narray of int, shape(self.vol * 6, )\nitet_mult() The multiplicity of each irreducible tetrahedra.\nType\narray of int, shape(N)\nproperty ptets() property shortest_diagonals() property tet_kpoint_ind_fort() property tet_mult() ","categories":"","description":"Module principia_materia.tetrahedron.tetrahedra\n","excerpt":"Module principia_materia.tetrahedron.tetrahedra\n","ref":"/docs/references/principia_materia.tetrahedron.tetrahedra.html","tags":"","title":"Module principia_materia.tetrahedron.tetrahedra"},{"body":"principia_materia.translation_group package Submodules principia_materia.translation_group.cluster module\nCluster\nCluster.dim\nCluster.natoms\nCluster.nspecies\nCluster.positions\nCluster.orbitals\nCluster.norbitals\nCluster.atoms\nCluster.species\nCluster.center\nCluster.atoms\nCluster.atoms_species_map\nCluster.axial_strain()\nCluster.center\nCluster.check_atoms_overlap()\nCluster.copy()\nCluster.dim\nCluster.find_atoms()\nCluster.natoms\nCluster.norbitals\nCluster.nspecies\nCluster.orbitals\nCluster.positions\nCluster.rotate()\nCluster.rotate_atoms()\nCluster.shift_atom()\nCluster.shift_atoms()\nCluster.shift_origin()\nCluster.species\nCluster.species_names\nCluster.strain()\nCluster.to_dict()\nget_cluster_io_wrapper()\nprincipia_materia.translation_group.crystal module\nCrystal\nCrystal.copy()\nCrystal.get_subcell()\nCrystal.positions_cartesian\nCrystal.rotate_atoms()\nCrystal.to_dict()\nget_crystal_io_wrapper()\nprincipia_materia.translation_group.crystal_ftg module\nCrystalFTG\nCrystalFTG.as_primitive()\nCrystalFTG.atoms\nCrystalFTG.copy()\nCrystalFTG.find_atoms()\nCrystalFTG.from_primitive()\nCrystalFTG.get_basis_at_q()\nCrystalFTG.get_wigner_seitz_cell()\nCrystalFTG.invsupa\nCrystalFTG.orbitals\nCrystalFTG.rotate()\nCrystalFTG.shift_atom()\nCrystalFTG.species_names\nCrystalFTG.supa\nCrystalFTG.supa_atoms_map\nCrystalFTG.supa_translations\nCrystalFTG.to_dict()\nCrystalFTG.tol\nget_crystal_ftg_io_wrapper()\nprincipia_materia.translation_group.kpoints module\nKpoints\nKpoints.copy()\nKpoints.find_irreducible_lattice_points()\nKpoints.get_index()\nKpoints.invsupa\nKpoints.irreducible_kpoints\nKpoints.irreducible_kpoints_index_map\nKpoints.irreducible_kpoints_map\nKpoints.irreducible_kpoints_mult\nKpoints.irreducible_kpoints_trans\nKpoints.kpoints\nKpoints.kpoints_to_rlattice()\nKpoints.multiplicity\nKpoints.rlattice_to_kpoints()\nKpoints.rotated_kpoints\nKpoints.rvec_bz\nKpoints.supa\nKpoints.to_dict()\nget_kpoints_io_wrapper()\nprincipia_materia.translation_group.lattice module\nLattice\nLattice.abc\nLattice.abg\nLattice.axial_strain()\nLattice.cartesian_to_lattice()\nLattice.copy()\nLattice.dim\nLattice.lattice_to_cartesian()\nLattice.rabc\nLattice.rabg\nLattice.rvec\nLattice.rvol\nLattice.set_ws_cell()\nLattice.similarity_transform()\nLattice.strain()\nLattice.to_dict()\nLattice.vec\nLattice.vol\nLattice.ws_weight()\nget_lattice_io_wrapper()\nprincipia_materia.translation_group.lattice_ftg module\nLatticeFTG\nLatticeFTG.copy()\nLatticeFTG.find_irreducible_lattice_points()\nLatticeFTG.rotated_lattice_points\nLatticeFTG.irreducible_lattice_points_trans\nLatticeFTG.irreducible_lattice_points_index_map\nLatticeFTG.irreducible_lattice_points_index\nLatticeFTG.irreducible_lattice_points_map\nLatticeFTG.irreducible_lattice_points_mult\nLatticeFTG.irreducible_lattice_points\nLatticeFTG.get_index()\nLatticeFTG.invsupa\nLatticeFTG.multiplicity\nLatticeFTG.set_lattice_points()\nLatticeFTG.set_lattice_points_diagonal()\nLatticeFTG.set_lattice_points_generic()\nLatticeFTG.lattice_points\nLatticeFTG.supa\nLatticeFTG.supa_is_diagonal\nLatticeFTG.to_dict()\nget_lattice_ftg_io_wrapper()\nget_lattice_points()\nprincipia_materia.translation_group.minimum_supercell module\nget_minimum_supercell() principia_materia.translation_group.qpoints_n module\nQpointsN\nQpointsN.Qpoints\nQpointsN.Qpoints_orbits\nQpointsN.find_irreducible_Qpoints()\nQpointsN.get_Qindex()\nQpointsN.irreducible_Qpoints\nQpointsN.irreducible_Qpoints_Qind\nQpointsN.irreducible_Qpoints_inverse\nQpointsN.irreducible_Qpoints_map\nQpointsN.irreducible_Qpoints_mult\nQpointsN.irreducible_Qpoints_permutation\nQpointsN.irreducible_Qpoints_rotation\nQpointsN.multiplicity\nQpointsN.nQpoints\nQpointsN.n_irreducible_Qpoints\nQpointsN.supa\nQpointsN.to_dict()\nQpointsPerm\nQpointsPerm.Qpoints\nQpointsPerm.find_permutationally_irreducible_Qpoints()\nQpointsPerm.get_Qindex()\nQpointsPerm.irreducible_Qpoints\nQpointsPerm.irreducible_Qpoints_Qind\nQpointsPerm.irreducible_Qpoints_inverse\nQpointsPerm.irreducible_Qpoints_map\nQpointsPerm.irreducible_Qpoints_mult\nQpointsPerm.irreducible_Qpoints_permutation\nQpointsPerm.multiplicity\nQpointsPerm.nQpoints\nQpointsPerm.n_irreducible_Qpoints\nQpointsPerm.supa\nQpointsPerm.to_dict()\nget_QpointsN_io_wrapper()\nprincipia_materia.translation_group.wigner_seitz module\nWignerSeitz\nWignerSeitz.weight() Module contents principia_materia.translation_group.fit_in_supercell(qpoint, supa, decimal=6) Check if q-point fit in a supercell.\nParameters\nqpoint (array of floats of Fraction, shape (dim, ) or (N, …, N’, dim)) – qpoint(s) to check the fit.\nsupa (array of int, shape(dim, dim)) – Supercell matrix.\ndecimal (int, optional, default to 6) – Decimal points for tolerance.\nReturns\nfit – Whether the q-point(s) fit in the given supercell.\nReturn type\nbool or array of bool\nprincipia_materia.translation_group.get_structure(inp=None, vec=None, pg=None, supa=None, atoms=None, orbitals=None, scale=None, strict_symmetry=False, lattice_coordinate=True, tol=1e-06, stype=‘auto’, copy=False) Construct a translation group object based on input data.\nThere are several types of inputs accepted:\nIf a translation group object (i.e. an object of type Lattice/LatticeFTG/Cluster/Kpoints/Crystal/CrystalFTG) is passed in as inp, it will return the object back directly, or return a copy of the object if copy==True. If A YAML file containing information to construct the object, is passed in as inp, it will be parsed and its content will be used to construct the object. The key information of the object can be directly passed in. The keyword stype determines which type of the translation group object to construct. It can be set to each of the translation group type, or “auto”. If stype is not “auto” input type 1 is used, it will check if the input object is an instance of stype.\nIf stype==auto, and input type 2 or 3 is passed in, then the type of object to construct will be determined using the following rule:\nIf vec is provided (either in YAML file or in arguments), and atoms, supa are missing, Lattice will be constructed. If vec and supa are provided and pg, atoms, are missing, LatticeFTG will be constructed. If vec, supa and pg are provided and atoms, are missing, Kpoints will be constructed. If atoms is provided and vec, supa are missing, Cluster will be constructed. If vec, atoms are provided and supa is missing, Crystal will be constructed. If vec, atoms and supa are all provided, CrystalFTG will be constructed. In cases 1, 4, 5, 6 pg is optional, and in cases 4, 5, 6 orbitals is optional.\nParameters\ninp (str or translation group object, default to None) – A YAML file/YAML string containing information to construct the translation group object, or a translation group object. If inp is provided, vec, pg, supa, atoms, orbitals should not be provided through the arguments, vice versa.\nvec (arrays of float, shape(dim, dim), default to None) – The lattice vectors, in row convention.\npg (str or PointGroup object, default to None) – The point group of the lattice.\nsupa (array of int, shape(dim, dim), default to None) – Super lattice matrix.\natoms (dict (preferably ordered), with str as keys and array of float as values, default None) – A dictionary of names of atoms and their positions.\norbitals (str or list of str or nested list of str, default to None) – Orbital names to assign to the atoms.\nscale (float or array of float with shape of (dim, ), default to None) – Scale the lattice vectors.\nstrict_symmetry (bool, optional, default to False) – In case of LatticeFTG or Kpoints, whether to allow points be rotated out of the given grid.\nlattice_coordinate (bool, optional, default to True) – In case of Crystal or CrystalFTG, the positions are in lattice coordinate if lattice_coordinate==True, otherwise they are in cartesian coordinate.\ntol (float, optional, default to 1.0E-6) – Tolerance threshold.\nstype (str or traslation group types, optional, default to “auto”) – The type of translation group object to construct.\ncopy (bool, optional, default to False) – In the case when inp is a translation group object, whether to return the object directly or a copy of it.\nExamples \u003e\u003e\u003e struct = get_structure(\"structure.yml\") \u003e\u003e\u003e type(struct) \u003cclass 'principia_materia.translation_group.crystal_ftg.CrystalFTG'\u003e \u003e\u003e\u003e print(struct.to_dict()) OrderedDict([('vec', array([[2., 0., 0.], [0., 2., 0.], [0., 0., 2.]])), ('atoms', OrderedDict([('H', array([[0., 0., 0.]])), ('He', array([[0.25, 0.25, 0.25], [0.75, 0.75, 0.75]]))])), ('orbitals', ['s', 'd', 'p']), ('supa', array([[2, 0, 0], [0, 2, 0], [0, 0, 1]]))]) principia_materia.translation_group.register_structure_datawrapper_type(wrapper) principia_materia.translation_group.register_structure_hdf5wrapper_type(wrapper) principia_materia.translation_group.save_structure(structure, file=None, use_config=False) Save structure object into YAML file.\nParameters\nstructure (Lattice, Cluster, LatticeFTG, Crystal, Kpoints or CrystalFTG object) – A structure object to save.\nfile (str, optional, default to None) – The file to save YAML string into, if None return the string.\n","categories":"","description":"Module principia_materia.translation_group\n","excerpt":"Module principia_materia.translation_group\n","ref":"/docs/references/principia_materia.translation_group.html","tags":"","title":"Module principia_materia.translation_group"},{"body":"principia_materia.translation_group.cluster module class principia_materia.translation_group.cluster.Cluster(atoms, orbitals=None, tol=1e-06) Bases: object\nA cluster of atoms or particles.\nWe will only refer to them as atoms for now.\nParameters\natoms (dict of str as keys and array of float as values) – A dictionary of names of atoms and their positions.\norbitals (str or array of str) – Orbital names to assign to the atoms.\ntol (float) – Tolerance.\ndim() Dimension of the cluster.\nType\nint\nnatoms() Number of atoms in the cluster.\nType\nint\nnspecies() Number of different species in the cluster.\nType\nint\npositions() Positions of atoms in the cluster.\nType\narray of float, shape(natoms, dim)\norbitals() A list of all orbitals of the all the atoms in the cluster.\nType\narray of tuple\u003cint, str\u003e\nnorbitals() Total number of orbitals in the cluster.\nType\nfloat\natoms() A dictionary of names of atoms and their positions.\nType\ndict of str as keys and array of float as values\nspecies() A dictionary of names of atoms and their index in all the atoms in the cluster.\nType\ndict of str as keys and array of int as values\ncenter() The averanged positions of all the atoms in the cluster.\nType\narray of float, shape(dim, )\nproperty atoms() A dictionary of atoms and their positions.\nproperty atoms_species_map() A list of indices of species of each atom.\naxial_strain(strain) Apply axial strain to the cluster.\nParameters\nstrain (array of float, shape(dim, dim) or shape(dim, )) – The strain matrix or the diagonal of the diaongal strain matrix.\nproperty center() The center of the cluster.\nThis center is defined as average positions of all atoms.\ncheck_atoms_overlap(tol=None) Check if atoms overlap with each other.\ncopy() Return a copy of the object.\nReturns\nnew – A copy of the object itself.\nReturn type\nCluster\nproperty dim() Dimension of the cluster.\nfind_atoms(positions) Find the indices of atoms of the same position.\nIf an atom is not found, in return index will be -1.\nParameters\npositions (array of float, shape (dim, ) or (N, dim)) – Positions of atoms to be found. If input shape is (dim, ), it will be reshaped into (1, dim) and N = 1.\nReturns\natoms_index – The indices of atoms.\nReturn type\narray of int, shape (N, )\nproperty natoms() Number of atoms in the cluster.\nproperty norbitals() Number of orbitals in the cluster.\nproperty nspecies() Number of species in the cluster.\nproperty orbitals() A list of all orbitals of atoms in the cluster.\nproperty positions() The coordinates of all atoms.\nrotate(rotation) Rotate atoms (in place).\nParameters\nrotation (arrat of floats, shape(dim, dim)) – The rotation matrix in column convention.\nrotate_atoms(rotation) Return the rotated positions of atoms.\nParameters\nrotation (arrat of floats, shape(dim, dim)) – The rotation matrix in column convention.\nshift_atom(atom_index, shift) Shift an atom.\nParameters\natom_index (int) – Index of the atom to shift.\nshift (float or array of float, shape(dim, )) – The shift amount.\nshift_atoms(shift) Shift all atoms.\nParameters\nshift (float or array of float, shape(dim, ), or array of float shape(natoms, dim)) – The shift amount.\nshift_origin(shift) Shift the origin of the cluster.\nParameters\nshift (arrat of floats, shape(dim, )) – The shift amount.\nproperty species() The dictionary of species and the indices of atoms of each species.\nproperty species_names() A list of names of species.\nstrain(strain) Apply strain to the cluster.\nParameters\nstrain (array of float, shape(dim, dim) or shape(dim, )) – The strain matrix.\nto_dict() Return a dictionary containing key information about the cluster.\nprincipia_materia.translation_group.cluster.get_cluster_io_wrapper(title=‘Cluster’) YAML data wrapper for Cluster class.\n","categories":"","description":"Module principia_materia.translation_group.cluster\n","excerpt":"Module principia_materia.translation_group.cluster\n","ref":"/docs/references/principia_materia.translation_group.cluster.html","tags":"","title":"Module principia_materia.translation_group.cluster"},{"body":"principia_materia.translation_group.crystal module class principia_materia.translation_group.crystal.Crystal(vec, atoms, orbitals=None, lattice_coordinate=True, pg=None, tol=1e-06) Bases: Lattice, Cluster\nA crystal structure.\nParameters\nvec (array of float, shape(dim, dim)) – The lattice vectors.\natoms (dict of str as keys and array of float as values) – A dictionary of names of atoms and their positions. The positions are in lattice coordinate if lattice_coordinate == True, otherwise they are in cartesian coordinate.\norbitals (str or array of str) – Orbital names to assign to the atoms.\nlattice_coordinate (bool, optional, default to True) – If True, the coordinate in input variable atoms is in Cartesian coordinates.\npg (str or a PointGroup object) – The point group of the lattice.\ntol (float, optional, default to 1.0E-6) – Tolerance.\ncopy() Return a copy of the object.\nReturns\nnew – A copy of the object itself.\nReturn type\nCrystal\nget_subcell(supa) Get the subcell that can transform to the current cell with the supercell matrix.\nSometimes, the crystal at hand is not the primitive cell, this method will help obtain the primitive cell once the supercell matrix is found.\nParameters\nsupa (array of int) – The supercell matrix.\nReturns\nsubcell – The subcell.\nReturn type\nCrystal\nproperty positions_cartesian() The Cartesian coordinates of the atoms.\nThe posision attribute now returns the direct coodinates of the atoms.\nrotate_atoms(rotation) Return the rotated positions of atoms.\nParameters\nrotation (arrat of floats, shape(dim, dim)) – The rotation matrix in column convention\nto_dict() Return a dictionary containing key information about the crystal.\nprincipia_materia.translation_group.crystal.get_crystal_io_wrapper(title=‘Crystal’) YAML data wrapper for Crystal class.\nIt’s a sum of Lattice wrapper and Cluster wrapper.\n","categories":"","description":"Module principia_materia.translation_group.crystal\n","excerpt":"Module principia_materia.translation_group.crystal\n","ref":"/docs/references/principia_materia.translation_group.crystal.html","tags":"","title":"Module principia_materia.translation_group.crystal"},{"body":"principia_materia.translation_group.crystal_ftg module class principia_materia.translation_group.crystal_ftg.CrystalFTG(vec, atoms, supa=None, orbitals=None, lattice_coordinate=True, pg=None, tol=1e-06) Bases: Crystal\nA crystal structure with a finite translation group (FTG).\nHere we define a finite translation group by mapping the infinite translation group of the crystal with periodic boundary condition. This boundary condition is defined with a supercell.\nParameters\nvec (array of float, shape(dim, dim)) – The lattice vectors.\natoms (dict of str as keys and array of float as values) – A dictionary of names of atoms and their positions. The positions are in lattice coordinate if lattice_coordinate == True, otherwise they are in cartesian coordinate.\nsupa (array of int, shape(dim, dim)) – The supercell matrix.\norbitals (str or array of str) – Orbital names to assign to the atoms.\nlattice_coordinate (bool, optional, default to True) – If True, the coordinate in input variable atoms is in Cartesian coordinates.\npg (str or a PointGroup object) – The point group of the lattice.\ntol (float, optional, default to 1.0E-6) – Tolerance.\nas_primitive() Return a copy of the object with the current structure as the primitive cell and supa equal to identity.\nReturns\nnew – An CrystalFTG object with the current vec, atoms, orbitals, pg and tol, supa set to identity.\nReturn type\nCrystalFTG\nproperty atoms() A dictionary of atoms and their positions.\ncopy() Return a copy of the object.\nReturns\nnew – A copy of the object itself.\nReturn type\nCrystalFTG\nfind_atoms(positions) Find the indices of atoms of that have identical positions within a translation.\nIf an atom is not found, in return index will be -1.\nParameters\npositions (array of float, shape (dim, ) or (N, dim)) – Positions of atoms to be found. If input shape is (dim, ), it will be reshaped into (1, dim) and N = 1.\nReturns\natoms_index (array of int, shape (N, )) – The indices of atoms.\ntranslation (array of int, shape (N, dim)) – The translation that will take the atoms in the crystal to the input atom position.\nclassmethod from_primitive(primitive, supa) Construct CrystalFTG from Crystal and a supercell.\nParameters\nprimitive (Crystal) – The Crystal object of a primitive cell.\nsupa (array of int, shape(dim, dim)) – The supercell matrix.\nReturns\nnew – The produced CrystalFTG object.\nReturn type\nCrystalFTG\nget_basis_at_q(qpoint) Compute the basis vectors of the primitive cell orbitals at a q-point.\nThe input q-point has to fit in the supercell.\nParameters\nqpoint (array of Fraction, shape(dim, )) – A q-point.\nReturns\nbasis – The dictionary of the basis vectors of the primitive cell orbitals.\nReturn type\ndict with tuple(int, str) as keys and array of complex, shape(natoms, dim) as values\nget_wigner_seitz_cell(center) Find atoms in the Wigner Seitz (WS) cell at a given center.\nParameters\ncenter (array of float, shape(self.dim)) – The coordinate of the center of the WS cell in lattice coordinate.\nReturns\nws_cell_translation (array of int, shape(N, self.dim)) – The primitive translation vector of the WS atom. N is the total number of the atoms in the WS cell.\nws_cell_atoms (array of int, shape(N)) – The index of the WS atom in the primitive cell.\nws_cell_weights (array of float, shape(N)) – The weight of the WS atom.\nproperty invsupa() The inverse of the supercell matrix.\nproperty orbitals() A list of all orbitals of atoms in the cluster.\nrotate(rotation) Rotate atoms (in place).\nParameters\nrotation (arrat of floats, shape(dim, dim)) – The rotation matrix in column convention.\nshift_atom(atom_index, shift) Shift an atom.\nParameters\natom_index (int) – Index of the atom to shift.\nshift (float or array of float, shape(dim, )) – The shift amount.\nproperty species_names() A list of names of species.\nproperty supa() The supercell matrix.\nproperty supa_atoms_map() The atom indices of the supercell atoms with respect to their corresponding atoms in primitive cell.\nproperty supa_translations() The translation vectors of the supercell atoms with respect to their corresponding atoms in primitive cell.\nto_dict() Return a dictionary containing key information about the CrystalFTG object.\nproperty tol() Error tolerance.\nprincipia_materia.translation_group.crystal_ftg.get_crystal_ftg_io_wrapper(title=‘CrystalFTG’) YAML data wrapper for CrystalFTG class.\n","categories":"","description":"Module principia_materia.translation_group.crystal_ftg\n","excerpt":"Module principia_materia.translation_group.crystal_ftg\n","ref":"/docs/references/principia_materia.translation_group.crystal_ftg.html","tags":"","title":"Module principia_materia.translation_group.crystal_ftg"},{"body":"principia_materia.translation_group.kpoints module class principia_materia.translation_group.kpoints.Kpoints(vec, supa, pg=‘C1’, strict_symmetry=True, tol=1e-06) Bases: Lattice\nA list of K-points that fit in a given supercell.\nParameters\nvec (array of float, shape(dim, dim)) – The lattice vectors, in row convention.\nsupa (array of int, shape(dim, dim)) – Super lattice matrix.\npg (str or a PointGroup object) – The point group of the lattice.\nstrict_symmetry (bool, optional, default to True) – If True, lattice points must rotate into a point that also fits in the cell.\ntol (float, optional, default to 1.0E-6) – Tolerance threshold.\ncopy() Return a copy of the object.\nReturns\nnew – A copy of the object itself.\nReturn type\nKpoints\nfind_irreducible_lattice_points() Find the irreducible set of k-points under the given symmetry.\nget_index(vecs) Find the index of a given K-vector or a list of K-vectors\nproperty invsupa() The inverse of the supercell matrix.\nproperty irreducible_kpoints() The irreducible k-points.\nproperty irreducible_kpoints_index_map() The corresponding irreducible k-point index in the k-point list for each k-point.\nproperty irreducible_kpoints_map() The corresponding irreducible k-point index in the irreducible k-point list for each k-point.\nproperty irreducible_kpoints_mult() The multiplicity of each irreducible k-point.\nproperty irreducible_kpoints_trans() The name of the operation takes the k-points at its index to one of the irreducible k-points.\nproperty kpoints() The k-points that fit in the supercell.\nkpoints_to_rlattice(vecs) Convert Fraction K-vector(s) to reciprocal lattice points\nParameters\nvecs (array of Fraction, same shape as vecs) – The K-vectors (q-points).\nReturns\nretval – An array of a series of arrays of the reciprocal lattice points (p-points).\nReturn type\narray of int, shape(N, dim) or shape(dim, )\nproperty multiplicity() The multiplicity of the supercell.\nrlattice_to_kpoints(vecs) Convert reciprocal lattice points to Fraction K-vector(s)\nParameters\nvecs (array of int, shape(N, dim) or shape(dim, )) – An array of a series of arrays of the reciprocal lattice points (p-points).\nReturns\nretval – The K-vectors (q-points).\nReturn type\narray of Fraction, same shape as vecs\nproperty rotated_kpoints() Dictionary of how what each k-points rotate into for each group operation. (Indices)\nproperty rvec_bz() The reciprocal lattice vector of the supercell.\nproperty supa() The supercell matrix.\nto_dict() Return a dictionary containing key information about the LatticeFTG object.\nprincipia_materia.translation_group.kpoints.get_kpoints_io_wrapper(title=‘Kpoints’) YAML data wrapper for Kpoints class.\n","categories":"","description":"Module principia_materia.translation_group.kpoints\n","excerpt":"Module principia_materia.translation_group.kpoints\n","ref":"/docs/references/principia_materia.translation_group.kpoints.html","tags":"","title":"Module principia_materia.translation_group.kpoints"},{"body":"principia_materia.translation_group.lattice module class principia_materia.translation_group.lattice.Lattice(vec, pg=None, tol=1e-06) Bases: object\nA lattice.\nIt can be a lattice in any kind\nParameters\nvec (array of float, shape(dim, dim)) – The lattice vectors, in row convention.\npg (str or a PointGroup object) – The point group of the lattice.\ntol (float, optional, default to 1.0E-6) – Tolerance threshold.\nproperty abc() Length of each lattice vector\nproperty abg() Angle between lattice vectors\naxial_strain(strain) Strains the unit cell.\nParameters\nstrain (array of floats, shape(dim)) – Strain on each axis.\ncartesian_to_lattice(vector) Convert the position of a point from cartesian coordinate to lattice coordinate.\nParameters\nvector (array of float, shape(dim)) – A point in the space, in cartesian coordinate.\ncopy() Return a copy of the object.\nReturns\nnew – A copy of the object itself.\nReturn type\nLattice\nproperty dim() Dimentions of the lattice.\nlattice_to_cartesian(vector) Convert the position of a point from lattice coordinate to cartesian coordinate.\nParameters\nvector (array of float, shape(dim)) – A point in the space, in lattice coordinate.\nproperty rabc() Length of each reciprocal lattice vector\nproperty rabg() Angle between reciprocal lattice vectors\nproperty rvec() Reciprocal lattice vectors.\nproperty rvol() Volume of the reciprocal lattice\nset_ws_cell(nrange=2) Construct WS cell object for ws_weight calculation.\nsimilarity_transform(transformation_matrix) Similarity transformation on lattice vectors.\nParameters\ntransformation_matrix (array of floats, shape(dim, dim)) – An invertable similarity transformation matrix, in row convention.\nstrain(strain) Strains the unit cell.\nParameters\nstrain (array of floats, shape(dim)) – Strain on each axis.\nto_dict() Return a dictionary containing key information about the lattice.\nproperty vec() Lattice vectors.\nproperty vol() Volume of the lattice\nws_weight(vector, lattice_coordinate=True) Compute the weight of a point in the WS cell of the lattice.\nParameters\nvector (array of float, shape(dim)) – A point in the space, in lattice coordinate if lattice_coordinate == True, otherwise in cartesian coordinate.\nlattice_coordinate (bool) – Whether the input point is in lattice coordinate or cartesian coordinate.\nprincipia_materia.translation_group.lattice.get_lattice_io_wrapper(title=‘Lattice’) YAML data wrapper for Lattice class.\n","categories":"","description":"Module principia_materia.translation_group.lattice\n","excerpt":"Module principia_materia.translation_group.lattice\n","ref":"/docs/references/principia_materia.translation_group.lattice.html","tags":"","title":"Module principia_materia.translation_group.lattice"},{"body":"principia_materia.translation_group.lattice_ftg module class principia_materia.translation_group.lattice_ftg.LatticeFTG(vec, supa, pg=None, strict_symmetry=True, tol=1e-06) Bases: Lattice\nA finite translation group (i.e. supercell) of the primitive lattice with point symmetry.\nParameters\nvec (array of float, shape(dim, dim)) – The lattice vectors, in row convention.\nsupa (array of int, shape(dim, dim)) – Super lattice matrix.\npg (str or a PointGroup object) – The point group of the lattice.\nstrict_symmetry (bool, optional, default to True) – If True, lattice points must rotate into a point that also fits in the cell.\ntol (float, optional, default to 1.0E-6) – Tolerance threshold.\ncopy() Return a copy of the object.\nReturns\nnew – A copy of the object itself.\nReturn type\nLatticeFTG\nfind_irreducible_lattice_points() Find the irreducible set of lattice points under the given symmetry.\nrotated_lattice_points() Dictionary of how what each lattice points rotate into for each group operation. (Indices)\nType\ndict with str as keys and array of int as values\nirreducible_lattice_points_trans() The name of the operation takes the lattice points at its index to one of the irreducible lattice points.\nType\narray of str, shape(multiplicity)\nirreducible_lattice_points_index_map() The corresponding irreducible lattice point index in the lattice point list for each lattice point.\nType\narray of int, shape(multiplicity)\nirreducible_lattice_points_index() Index of irreducible lattice points in the lattice points list.\nType\narray of int, shape(nilp)\nirreducible_lattice_points_map() The corresponding irreducible lattice point index in the irreducible lattice point list for each lattice point.\nType\narray of int, shape(multiplicity)\nirreducible_lattice_points_mult() The multiplicity of each irreducible lattice point.\nType\narray of int, shape(nilp)\nirreducible_lattice_points() The list of irreducible lattice point.\nType\narray of array of int, shape(nilp, dim)\n\\* nilp=number of irreducible lattice points() get_index(points) Find the index of a given lattice point or a list of lattice points.\nThe algorithm is descrived in method create_mesh. For each lattice point, instead of using the ordinary indexing of a list, this algorithm only has the time complexity of O(1), which is much more efficient when used.\nIn order to compute the index, the a tranformation matrix $\\textrm{H}_p$ and an index weight vector $\\textrm{IW}$\n$$ \u0026 H_{p, (j, i)} = H^{-1}_{(j, i)} \\times H_{(i, i)} \\forall i \\in [1, d], j \\in [1, i)\n\u0026 \\textrm{IW}_{i} = \\prod_{j=1}^{i} H_{(j, j)} $$ Then the index of any given point in the supercell can be computed directly:\n$$ \u0026 \\textrm{index}_{t} = ((t \\cdot L + \\textrm{floor}(t \\cdot L \\cdot H_p)) \\mod \\textrm{diag}(H)) \\cdot \\textrm{IW} $$\nParameters\npoints (array of integers, shape(dim) or shape(N, dim)) – Points to compute indices.\nproperty invsupa() The inverse of the supercell matrix.\nproperty multiplicity() The multiplicity of the supercell.\nset_lattice_points() Find t-points that fit in the supercell.\nset_lattice_points_diagonal() Find the lattice points that fit in the given diagonal supercell.\nSame as set_lattice_points_generic, except for diagonal supercells it can be simplified.\nset_lattice_points_generic() Find the lattice points that fit in the given supercell.\nIt uses the algorithm implemented in get_lattice_points function (described in Phys. Rev. B 100, 014303 (2019)). And meanwhile, prepares the matrices to determine the index of each lattice point using the inverse operation of the above metioned function.\nlattice_points() Lattice points of the super cell (i.e. FTG).\nType\narray of int, shape(self.multiplicity, 3)\nproperty supa() The supercell matrix.\nproperty supa_is_diagonal() Whether the supercell is a diagonal matrix.\nto_dict() Return a dictionary containing key information about the LatticeFTG object.\nprincipia_materia.translation_group.lattice_ftg.get_lattice_ftg_io_wrapper(title=‘LatticeFTG’) YAML data wrapper for LatticeFTG class.\nprincipia_materia.translation_group.lattice_ftg.get_lattice_points(supa, decimals=6) Find t-points using Hermite Normal Form (HNF) of the $S_BZ$.\nThe algorithm is described in paper:\nWe can decompose the supercell matrix into its HNF: $$ \u0026 S_BZ = HL^{-1}\n\u0026 S_BZ^{-1} = LH^{-1} $$\nThen we have the condition of the t-points that fit in the supercell: $$ \u0026 0 \u003c= t S_BZ^{-1} e_j \u003c 1\n\u0026 0 \u003c= t L H^{-1} e_j \u003c 1 $$\nIf we let $t’ = tL$, we can rewrite the condition $$ 0 \u003c= t’ H^{-1} e_j \u003c 1 $$ , and we can solve for $t’$ and recover $t$ afterwards:\n$$ t = t’ L^{-1} $$\nParameters\nsupa (array of int, shape(dim, dim)) – Supercell matrix.\ndecimals (int, optional, default to 6) – The decimal points to round\n","categories":"","description":"Module principia_materia.translation_group.lattice_ftg\n","excerpt":"Module principia_materia.translation_group.lattice_ftg\n","ref":"/docs/references/principia_materia.translation_group.lattice_ftg.html","tags":"","title":"Module principia_materia.translation_group.lattice_ftg"},{"body":"principia_materia.translation_group.minimum_supercell module principia_materia.translation_group.minimum_supercell.get_minimum_supercell(qpoints, dim=3) Find the minimum supercell that accommodates the input qpoints.\nThe algorithm is described in Section III.B of paper Phys. Rev. B 100, 014303 (2019).\nParameters\nqpoints (1-D or 2-D array of Fraction, shape(dim, ) or shape(N, dim)) – Q-points for the supercell to accommodate.\ndim (integer, optional, default to 3) – Dimension of the space.\noptimize (..) –\nsupercell. (.. Whether to optimize found) –\nReturns\nsupa – Found supercell that accommodates the input qpoints.\nReturn type\narray of integer\n","categories":"","description":"Module principia_materia.translation_group.minimum_supercell\n","excerpt":"Module principia_materia.translation_group.minimum_supercell\n","ref":"/docs/references/principia_materia.translation_group.minimum_supercell.html","tags":"","title":"Module principia_materia.translation_group.minimum_supercell"},{"body":"principia_materia.translation_group.qpoints_n module class principia_materia.translation_group.qpoints_n.QpointsN(vec, supa, order, pg=‘C1’, tol=1e-06) Bases: Lattice\nA list of Q-points at a given order that fit in a given supercell find irreducible Q with point and permutaion symmetry.\nParameters\nvec (array of float, shape(dim, dim)) – The lattice vectors, in row convention.\nsupa (array of int, shape(dim, dim)) – Super lattice matrix.\npg (str or a PointGroup object) – The point group of the lattice.\ntol (float, optional, default to 1.0E-6) – Tolerance threshold.\nproperty Qpoints() The Q-points that fit in the supercell.\nproperty Qpoints_orbits() find_irreducible_Qpoints() Find the irreducible set of Q-points under the given symmetry.\nget_Qindex(Qpoints) Computes the indices of Q-points.\nproperty irreducible_Qpoints() The irreducible Qpoints.\nproperty irreducible_Qpoints_Qind() The index of the irreducible Q-points in the Q-points list.\nproperty irreducible_Qpoints_inverse() The index of the corresponding irreducible Q-points of the Q-points in the irreducible Q-points list.\nproperty irreducible_Qpoints_map() The corresponding irreducible Q-point index in the irreducible Q-point list for each Q-point.\nproperty irreducible_Qpoints_mult() The multiplicity of the irreducible Q-points.\nproperty irreducible_Qpoints_permutation() The permutation that maps a Q-point to the corresponding irreducible Q-point.\nproperty irreducible_Qpoints_rotation() The point group operation that maps a Q-point to the corresponding irreducible Q-point.\nproperty multiplicity() The multiplicity of the supercell.\nproperty nQpoints() Number of Q-points\nproperty n_irreducible_Qpoints() property supa() The supercell matrix.\nto_dict() Return a dictionary containing key information about the QpointsN object.\nclass principia_materia.translation_group.qpoints_n.QpointsPerm(vec, supa, order, pg=‘C1’, tol=1e-06) Bases: Lattice\nA list of Q-points at a given order that fit in a given supercell, find permutationally irreducible Q.\nFor a given order N Q point, in contains N-1 independent q-point, since the Q point needs to satisfy conservation of momentum and the sum of all q-points in a Q point must be equivalent to Gamma point (0, 0, 0).\nParameters\nvec (array of float, shape(dim, dim)) – The lattice vectors, in row convention.\nsupa (array of int, shape(dim, dim)) – Super lattice matrix.\npg (str or a PointGroup object) – The point group of the lattice.\ntol (float, optional, default to 1.0E-6) – Tolerance threshold.\nproperty Qpoints() The Q-points that fit in the supercell.\nfind_permutationally_irreducible_Qpoints() Find the permutationally irreducible set of Q-points.\nget_Qindex(Qpoints) Computes the indices of Q-points.\nproperty irreducible_Qpoints() The irreducible Q-points.\nproperty irreducible_Qpoints_Qind() The index of the irreducible Q-points in the Q-points list.\nproperty irreducible_Qpoints_inverse() The index of the corresponding irreducible Q-points of the Q-points in the irreducible Q-points list.\nproperty irreducible_Qpoints_map() The index of corresponding irreducible Q-point of each Q-point.\nproperty irreducible_Qpoints_mult() The multiplicity of each irreducible Q-point.\nproperty irreducible_Qpoints_permutation() The permutation that transform the Q-point to the corresponding irreducible Q-point.\nproperty multiplicity() The multiplicity of the supercell.\nproperty nQpoints() Number of Q-points.\nproperty n_irreducible_Qpoints() Number of irreducible Q-points.\nproperty supa() The supercell matrix.\nto_dict() Return a dictionary containing key information about the QpointsPerm object.\nprincipia_materia.translation_group.qpoints_n.get_QpointsN_io_wrapper(title=‘QpointsN’) YAML data wrapper for QpointsN class.\n","categories":"","description":"Module principia_materia.translation_group.qpoints_n\n","excerpt":"Module principia_materia.translation_group.qpoints_n\n","ref":"/docs/references/principia_materia.translation_group.qpoints_n.html","tags":"","title":"Module principia_materia.translation_group.qpoints_n"},{"body":"principia_materia.translation_group.wigner_seitz module class principia_materia.translation_group.wigner_seitz.WignerSeitz(vec, nrange=2, tol=1e-05) Bases: object\nFind the weight of a point in Wigner Seitz cell.\nIf a point is in the cell, it has weight of 1. If a point is out of the cell, it has weight of 0. If a point is on the boundaries of the cell, the weight is 1 / (1 + # of cells the point is shared with neighbor WS cells.)\nParameters\nvec (array of floats, shape(dim, dim)) – Lattice vectors.\nnrange (int, optional, default 2) – Number of translations in each direction used to find neighbor list.\ntol (float, optional, default 1.0E-5) – Tolerance.\nweight(vector) Weighing by counting how many times the point sit of one of the ws cell edges\nParameters\nvector (array of float) – The Cartesian coordinates of a point.\nReturns\nweight – The weight of the point.\nReturn type\nfloat\n","categories":"","description":"Module principia_materia.translation_group.wigner_seitz\n","excerpt":"Module principia_materia.translation_group.wigner_seitz\n","ref":"/docs/references/principia_materia.translation_group.wigner_seitz.html","tags":"","title":"Module principia_materia.translation_group.wigner_seitz"},{"body":"principia_materia.utils package Submodules principia_materia.utils.config_manager module\nupdate_recursive() principia_materia.utils.db_utils module\nSQLiteDB\nSQLiteDB.commit()\nSQLiteDB.create_table()\nSQLiteDB.cursor\nSQLiteDB.execute()\nSQLiteDB.get_column_names()\nSQLiteDB.insert_to_table()\nSQLiteDB.row_in_table()\nSQLiteDB.search_table()\nSQLiteDB.table_exists()\nSQLiteDB.update_table()\nadapt_array()\nconvert_array()\nprincipia_materia.utils.testing module\nassertDictAlmostEqual()\nassertDictEqual()\nprincipia_materia.utils.text_file_search module\nfind_all()\nfind_first()\nfind_last()\nsearch()\nModule contents ","categories":"","description":"Module principia_materia.utils\n","excerpt":"Module principia_materia.utils\n","ref":"/docs/references/principia_materia.utils.html","tags":"","title":"Module principia_materia.utils"},{"body":"principia_materia.utils.config_manager module principia_materia.utils.config_manager.update_recursive(d, u) ","categories":"","description":"Module principia_materia.utils.config_manager\n","excerpt":"Module principia_materia.utils.config_manager\n","ref":"/docs/references/principia_materia.utils.config_manager.html","tags":"","title":"Module principia_materia.utils.config_manager"},{"body":"principia_materia.utils.db_utils module class principia_materia.utils.db_utils.SQLiteDB(database) Bases: object\nInterface to SQLite database.\nParameters\ndatabase (str) – The path to the database file.\ncommit() Commit the current transaction.\ncreate_table(table, columns, exists=True) Create a table.\nParameters\ntable (str) – The name of the table.\ncolumns (list of str) – The columns to create in the table.\nexists (bool, optional, default to True) – If True, do not throw and error when table exists. Otherwise. an error will be thrown if table exits.\nproperty cursor() Get the Cursor object of the database.\nReturns\ncursor – The Cursor object.\nReturn type\nCursor\nexecute(sql, parameters=None) Execute SQLl command with parameters.\nParameters\nsql (str) – The SQL command.\nparameters (tuple, optional, default to None) – The parameters in the SQL command.\nget_column_names(table) Get the column names of a table.\nParameters\ntable (str) – The name of the table.\ninsert_to_table(table, data) Inseart a new row into a table.\nParameters\ntable (str) – The name of the table.\ndata (dict) – The values to insert into the new row of the table.\nrow_in_table(table, key, value) Check if a row is in a table.\nParameters\ntable (str) – The name of the table.\nkey (str) – A column name in the table.\nvalue (str) – The value of the column to match in the table.\nReturns\nflat – Whether the row is in the table.\nReturn type\nbool\nsearch_table(table, keys, match_column={}, search_conditions=None) Search in a table.\nThe found rows can be retrieved from the Cursor object.\nParameters\ntable (str) – The name of the table.\nmatch_column (dict) – The column match conditions.\nsearch_conditions (list of str, optional, default to None) – Search conditions other than column matches.\nkeys (list of str) – The columns of the table to return.\ntable_exists(table) Check if table exists.\nParameters\ntable (str) – The name of the table.\nReturns\nflat – Whether the table exits.\nReturn type\nbool\nupdate_table(table, match_column, data) Update new row into a table.\nParameters\ntable (str) – The name of the table.\nmatch_column (dict) – The column match conditions.\ndata (dict) – The values to insert into the new row of the table.\nprincipia_materia.utils.db_utils.adapt_array(arr) Converts np.array to TEXT when inserting\nhttp://stackoverflow.com/a/31312102/190597 (SoulNibbler)\nprincipia_materia.utils.db_utils.convert_array(text) Converts TEXT to np.array when selecting\n","categories":"","description":"Module principia_materia.utils.db_utils\n","excerpt":"Module principia_materia.utils.db_utils\n","ref":"/docs/references/principia_materia.utils.db_utils.html","tags":"","title":"Module principia_materia.utils.db_utils"},{"body":"principia_materia.utils.testing module principia_materia.utils.testing.assertDictAlmostEqual(a, b, decimal=6, err_msg=None) principia_materia.utils.testing.assertDictEqual(a, b, err_msg=None) ","categories":"","description":"Module principia_materia.utils.testing\n","excerpt":"Module principia_materia.utils.testing\n","ref":"/docs/references/principia_materia.utils.testing.html","tags":"","title":"Module principia_materia.utils.testing"},{"body":"principia_materia.utils.text_file_search module principia_materia.utils.text_file_search.find_all(filename, pattern) principia_materia.utils.text_file_search.find_first(filename, pattern, abort_pattern=None, blocksize=4096) principia_materia.utils.text_file_search.find_last(filename, pattern, abort_pattern=None, blocksize=4096) principia_materia.utils.text_file_search.search(filename, pattern) ","categories":"","description":"Module principia_materia.utils.text_file_search\n","excerpt":"Module principia_materia.utils.text_file_search\n","ref":"/docs/references/principia_materia.utils.text_file_search.html","tags":"","title":"Module principia_materia.utils.text_file_search"},{"body":"principia_materia.visualization package Module contents ","categories":"","description":"Module principia_materia.visualization\n","excerpt":"Module principia_materia.visualization\n","ref":"/docs/references/principia_materia.visualization.html","tags":"","title":"Module principia_materia.visualization"},{"body":"This page could probably be the landing for Overview.\nWhat is it? PM can be used to compute phonons and their interactions via the lone irreducible derivative (LID) and bundled irreducible derivative (BID) approaches, based on some first-principles method or using empirical potentials.\nGiven some anharmonic vibrational Hamiltonian, perhaps computed using PM, one can compute various vibrational observables, including phonon lineshifts and linewidths, thermal conductivity, density of states, etc.\nGiven some real space electronic Hamiltonian, various electronic observables can be computed, including density of states, magnetism within Hartree-Fock (assuming local interactions), etc.\nWhy do I want it? Our BID algorithm for computing phonons and their interactions is the fastest finite displacement algorithm allowed by group theory.\n","categories":"","description":"PM allows one to compute various electronic and phononic properties of crystals.\n","excerpt":"PM allows one to compute various electronic and phononic properties of …","ref":"/docs/overview/","tags":"","title":"Overview"},{"body":"Here we illustrate how to symmtrize displacements at a given q-point according to irreducible representations of the little group using the script pm-disp-qrep. Take the example of \\(\\bm{q}=(\\frac{1}{2},\\frac{1}{2},\\frac{1}{2})\\) in cubic SrTiO\\(_3\\). We will use pm-prototype-xtal to generate the crystal structure file.\n$ pm-prototype-xtal --perovskite \u003e xtal.yml Printing out the irreducible representations, we have\n$ pm-disp-qrep xtal.yml --point-group Oh --qpoint 1/2,1/2,1/2 --print-irreps OrbitKey(name='Sr', index=0) [0] T2g OrbitKey(name='Ti', index=0) [0] T1u OrbitKey(name='O', index=0) [0, 1, 2] A1g+Eg+T1g+T2g We can also print out the irreducible representation vectors.\n$ pm-disp-qrep xtal.yml --point-group Oh --qpoint 1/2,1/2,1/2 --print-vectors T2g[Sr] 0.0000 0.0000 1.0000 1.0000 0.0000 0.0000 0.0000 1.0000 0.0000 T1u[Ti] 1.0000 0.0000 0.0000 0.0000 1.0000 0.0000 0.0000 0.0000 1.0000 A1g[O] 0.5774 0.0000 0.0000 0.0000 0.5774 0.0000 0.0000 0.0000 0.5774 Eg[O] 0.7071 0.0000 0.0000 0.0000 -0.7071 0.0000 0.0000 0.0000 0.0000 -0.4082 0.0000 0.0000 0.0000 -0.4082 0.0000 0.0000 0.0000 0.8165 T1g[O] 0.0000 0.0000 0.0000 0.0000 0.0000 0.7071 0.0000 -0.7071 0.0000 0.0000 0.0000 -0.7071 0.0000 0.0000 0.0000 0.7071 0.0000 0.0000 0.0000 0.7071 0.0000 -0.7071 0.0000 0.0000 0.0000 0.0000 0.0000 T2g[O] 0.0000 0.7071 0.0000 0.7071 0.0000 0.0000 0.0000 0.0000 0.0000 0.0000 0.0000 0.0000 0.0000 0.0000 0.7071 0.0000 0.7071 0.0000 0.0000 0.0000 0.7071 0.0000 0.0000 0.0000 0.7071 0.0000 0.0000 ","categories":["Examples"],"description":"A key task is to symmetrize the basis such that the vectors transform like irreducible representations.\n","excerpt":"A key task is to symmetrize the basis such that the vectors transform …","ref":"/docs/functionality/xtal-symmetrization/","tags":["test","sample","docs"],"title":"Symmetrizing displacements"},{"body":"Here we encode all information about the crystallographic point groups. In the near future, we will add space group information here as well.\nCornwell_group_matrices Cornwell_point_group PointGroup get_little_group ","categories":"","description":"The symmetry module contains code related to point and space group symmetry.\n","excerpt":"The symmetry module contains code related to point and space group …","ref":"/docs/modules/symmetry/","tags":"","title":"Symmetry"},{"body":"","categories":"","description":"PM uses a sqlite database to store information related to first-principles calculations.\n","excerpt":"PM uses a sqlite database to store information related to …","ref":"/docs/data_management/database/","tags":"","title":"Database"},{"body":"Principia Materia (PM) consists of Python codes with C++ and Fortran extensions. There will soon be a variety of options for installing PM, but we presently recommend cloning the git repository, creating a virtual environment, installing the required dependencies, and compiling the source code. We also provide the option of having auto-completion at the Bash shell using argcomplete. Please note that Python 3.7 or later is required to install and use PM.\nObtaining the source code Clone the git repository:\ngit clone git@github.com:marianettigroup/principia-materia.git Using a Virtual Environment A virtual environment is recommended when working with PM. To setup a virtual environment:\npython3 -m virtualenv ENVNAME (replace ENVNAME with the name you choose for the environment).\nTo launch the environment, issue the following command:\nsource ENVNAME/bin/activate This virtual environment will be launched whenever running PM.\nInstalling dependencies PM depends on several external libraries:\nopenmp, lapack, blas, gcc, gfortran For Ubuntu 18.04 and later with gcc compilers sudo apt install gcc gfortran libopenblas-dev libgomp1 libhdf5-dev For macOS with Homebrew brew install gcc openblas Required python modules for PM are listed in the file requirements.txt\npip install --upgrade -r requirements.txt Compiling PM The final step is compiling the source code.\nFor Ubuntu 18.04 and latear with gcc compilers:: python setup.py build For macOS with Homebrew:: CC=gcc-11 CXX=g++-11 F90=gfortran-11 python setup.py build The installation step can be executed with either the regular mode:\npython setup.py install or the development mode:\npython setup.py develop In development mode, the repository is dynamically link to serve as the python module so that any changes to the code come into effect without reinstalling the module. However for the extensions of the module that are written in either C or FORTRAN, the module requires recompilation to reflect any changes to the source code. We currently recommend installing in the development mode, given that many changes are still being made to the code.\nSetup Shell Auto-Complete The auto-complete feature is optional, and is realized with the argcomplete module. To activate this feature in Bash, for example, install the module first:\npip install argcomplete activate-global-python-argcomplete Then within the virtual environment, source the pm-completion.sh script in activation script ENVNAME/bin/activate:\nsource ${VIRTUAL_ENV}/../pm-completion.sh ","categories":"","description":"How you can obtain and install PM.\n","excerpt":"How you can obtain and install PM.\n","ref":"/docs/installation/","tags":"","title":"Installation"},{"body":"A common group theoretical task is the direct product or symmetric direct product of irreducible representations. The composition of a product is obtained as\npm-irrep-product --point-group Oh --irreps T2g,T2g # output # T2gxT2g = A1g+Eg+T1g+T2g The composition of a symmetric product is obtained as\npm-irrep-product --point-group Oh --irreps T2g,T2g --symmetric # output # [T2gxT2g] = A1g+Eg+T2g An arbitrary number of irreps can be handled\npm-irrep-product --point-group Oh --irreps T2g,T2g,Eg,Eg,A2g # output # T2gxT2gxEgxEgxA2g = 2A1g+2A2g+4Eg+4T1g+4T2g Another important task is constructing the irreducible representation vectors of the product representation in terms of the rows of the original irreducible representations.\npm-irrep-product --point-group Oh --irreps Eg,Eg --print-vectors # output # # EgxEg = A1g+A2g+Eg # # irr Eg.0xEg.0 Eg.0xEg.1 Eg.1xEg.0 Eg.1xEg.1 # A1g 0.7071 0.0 0.0 0.7071 # A2g 0.0 0.7071 -0.7071 0.0 # Eg.0 0.0 0.7071 0.7071 0.0 # Eg.1 0.7071 0.0 0.0 -0.7071 The same can be done for the symmetric product\npm-irrep-product --point-group Oh --irreps Eg,Eg --print-vectors --symmetric # output # # [EgxEg] = A1g+Eg # # irr Eg.0xEg.0 Eg.0xEg.1 Eg.1xEg.1 # A1g 0.7071 0.0 0.7071 # Eg.0 0.0 1.0 0.0 # Eg.1 0.7071 0.0 -0.7071 ","categories":"","description":"Perform direct products and symmetric direct products of irreps.\n","excerpt":"Perform direct products and symmetric direct products of irreps.\n","ref":"/docs/functionality/irrep-product/","tags":"","title":"Products of Irreducible Representations"},{"body":"This module contains all classes relevant to building a representation of a group, finding the composition in terms of irreducible representations, and building irreducible vectors.\nBaseRepresentation CharmBlochRep ShiftMode ClusterRep DispClusterRep SingleTensorRep DirectProduct SymmetricDirectProduct StarCharmBlochRep and Stars ProductofQIrreps SymmetricProductofQIrreps QStarRep SymmetricQStarRep ","categories":"","description":"Build representation of group and decompose into irreducible representations.\n","excerpt":"Build representation of group and decompose into irreducible …","ref":"/docs/modules/representation/","tags":"","title":"Representation"},{"body":"The documentation for PM is generated using Hugo with the Docsy theme. The main advangtage of Hugo is how fast it is, and you can basically see your changes to the documentation in real time when viewing the site on a local server. The Docsy theme brings all of the advanced features that are needed for technical documentation, including detailed support for code markup (via prism), latex support (via katex), etc.\nThis documentation is stored in the github repository principia-materia-docsy. When you push to the github repository, the site will automatically be built using github actions and served at https://marianettigroup.github.io/. If you want to push to github without rebuilding, include [skip actions] in your commit message.\nTo view the documentation locally, start by installing hugo; snap is probably the most convenient way:\nsudo snap install hugo Now change into the directory of your local pm-docsy repo, and start the hugo server:\nhugo server You can then view the docs by pointing your browser to the local port that hugo prints out, which is normally http://localhost:1313/.\n","categories":"","description":"How to contribute to the documentation of PM.\n","excerpt":"How to contribute to the documentation of PM.\n","ref":"/docs/docsy_docs/","tags":"","title":"Docsy Documentation"},{"body":"","categories":"","description":"PM uses hdf files to store irreducible derivatives, force tensors, etc.\n","excerpt":"PM uses hdf files to store irreducible derivatives, force tensors, …","ref":"/docs/data_management/hdf5/","tags":"","title":"hdf5"},{"body":"Most key tasks can be performed from the command line, and here we document all such functionality.\n","categories":"","description":"Executing core functionality of PM from the command line.\n","excerpt":"Executing core functionality of PM from the command line.\n","ref":"/docs/functionality/","tags":"","title":"Command Line Functionality"},{"body":"Here we document various classes and functions within each module, and provide minimal examples.\n","categories":"","description":"Documenting key classes and functions in each module.\n","excerpt":"Documenting key classes and functions in each module.\n","ref":"/docs/modules/","tags":"","title":"Modules"},{"body":"PM deals with varied data sets, some of which is read in from other sources and some of which is generated.\n","categories":"","description":"How PM handles data that it intakes and generates.\n","excerpt":"How PM handles data that it intakes and generates.\n","ref":"/docs/data_management/","tags":"","title":"Data Management"},{"body":"Here we document how unit testing is performed for PM, and provide an overview of what sort of tests are performed. Unit tests for PM are stored in a separate repository called principia-materia-tests.\nPM performs unit testing with Pytest, which is a standard framework for unit testing within python. All unit tests may be run by going into the repo, installing the required dependencies, and executing pytest.\ngit clone git@github.com:marianettigroup/principia-materia-tests.git cd principia-materia-test pip install requirements.txt pytest An individual test can be run by changing into a directory and running pytest on a specific test. For example,\ncd tests/translation_group pytest test_translation_group.py ","categories":"","description":"Unit testing PM.\n","excerpt":"Unit testing PM.\n","ref":"/docs/unit_testing/","tags":"","title":"Unit Testing"},{"body":"Within this package we can compute irreducible derivatives of phonons and phonon interactions at a given order with either LID or BID approach. The theory behind these approaches are described in the following paper:\nL. Fu, M. Kornbluth, Z. Cheng, and C. A. Marianetti, Phys. Rev. B 100, 014303 (2019). Specifically, we can execute the LID, SS-BID and HS-BID approaches from the command line using the following commands:\npm-lid-mesh: compute irreducible derivatives of a given FTG and order using LID method;\npm-bid: compute irreducible derivatives of a given FTG and order using SS-BID method;\npm-hsbid: compute irreducible derivatives of a given FTG and order using HD-BID method.\nThese commands take in generally the same command line options, therefore one can switch between approaches by changing the command while keeping the options the same. For example, below is guide on using the LID approach to compute irreducible derivatives of NaCl at second order but one can replace pm-lid-mesh with pm-bid or pm-hsbid to execute SS-BID or HS-BID approach.\nLID Approach on NaCl at Second Order There are many ways to use this package to execute calculations of the irreducible derivatives with LID approach. Here we demonstrate a recommended workflow to execute our LID approach at second order on NaCl from forces computed by first principle method.\nSymmetry Analysis and Find the Measurements to Compute First we create a file xtal.yml describing the structure of NaCl:\n# xtal.yml vec: [[ 0.00000000, 2.83000729, 2.83000729], [ 2.83000729, 0.00000000, 2.83000729], [ 2.83000729, 2.83000729, 0.00000000]] atoms: - Na: [[ 0.00000000, 0.00000000, 0.00000000]] - Cl: [[ 0.50000000, 0.50000000, 0.50000000]] Then, with this structure and the point group \\(O_h\\), we can write the minimal configuration file, named config.yml, to execute the LID approach with a supercell \\(\\hat{S}_{BZ}=2\\hat1\\):\n# config.yml structure: 'xtal.yml' supa: | 2 0 0 0 2 0 0 0 2 pg: 'Oh' order: 2 full_symmetry: True delta: [ 0.02, 0.03, 0.04] There are numerous parameters which have default settings that can be changed, and these can be added to the config.yml file listed above:\nfdtype: 'c' root_directory: '.' database: 'database.db' db_type: 'sqlite' db_table: 'lid_phonon' With the configuration file we can initiate the pre-processing step which will execute the symmetry analysis and create the jobs that need to be computed with first principles:\npm-lid-mesh --config config.yml --create The above step will create two files:\nlid_mesh.hdf5: A HDF5 file containing the computed symmetry analysis results, which will be used in the post-processing step to compute the irreducible derivatives after first principle calculations are finished.\ndatabase.db: A SQLite database file containing the jobs need to be computed with first principle calculations (db_type is specified to be ‘sqlite’ in the config.yml file, other database can be used if a working interface is provided).\nNote The above steps can also be executed purely in command line with the following command:\npm-lid-mesh --save-config --create --structure xtal.yml \\ --supa '2,0,0;0,2,0;0,0,2' --pg Oh --order 2 --full-symmetry \\ --delta 0.02,0.03,0.04 --fdtype c --database database.db \\ --db-type sqlite --db-table lid_phonon Prepare and Execute First Principle Calculations The next step is to create the first principle jobs to be computed, the package generically supports all types of first principle compute engines provided a working interface, and here we demonstrate using VASP. We begin by create the VASP jobs to be executed:\npm-jobs --config config.yml --create --engine vasp --save-config jobs_config.yml \\ --job-config-path path-to-vasp-input-templates --root-directory jobs-ro-run Inside the path-to-vasp-input-templates directory, one usually needs to provide “INCAR”, “KPOINTS” and “POTCAR” files and they will be used as templates when creating the vasp jobs, each vasp job will be created in a separate directory for convenience. Once these directories are created, VASP can be executed within each directory. Afterwards, the calculation results can be collected and stored in the database:\npm-jobs --config jobs_config.yml --retrieve Note We initiated the pm-jobs command with the input configuration file for the LID analysis config.yml, and subsequently saved a new configuration file jobs_config.yml for the pm-jobs code for the purpose of convenience. These configuration files contains all the input arguments that are required to reproduce the exact same setup. Compute Irreducible Derivatives from the Results of First Principle Calculations Finally, we can execute the post-processing step of the LID approach to compute the irreducible derivatives and, for example, compute the force constants tensors for Fourier interpolation:\npm-lid-mesh --load-lid-mesh lid_mesh.hdf5 --config config.yml \\ --post --save-fi --save-ids --save-dts If the material of interest is an insulator and the dipole-dipole interaction needs to be considered, the dataset for computing the dipole-dipole interaction needs to be provided as an input as well:\npm-lid-mesh --load-lid-mesh lid_mesh.hdf5 --config config.yml --epsilon path-to-epsilon.yml \\ --post --save-fi --save-ids --save-dts The dataset for computing the dipole-dipole interaction can be computed from first principle methods. Continuing with the VASP example, we can obtain the dataset by executing a static calculation adding LEPSILON=.TRUE. to the “ICNAR” file. Once the calculation is finished, use the following command inside the calculation directory to parse the output from VASP and create the epsilon.yml file:\npm-epsilon --vasp -o epsilon.yml . then replace path-to-epsilon.yml with the path to the generated epsilon.yml file.\nThe following files are created in this step:\nirreducible_derivatives.hdf5: A HDF5 files containing the names of the irreducible derivatives and their values.\nfourier_interpolation.hdf5: A HDF5 files containing all the necessary information (structure, force constants tensors, FTG and dipole-dipole contributions if at second order) to compute Fourier interpolation.\ndynamic_tensors.hdf5: A HDF5 files containing all the dynamic tensors in the naive basis within irreducible Q.\nNote Both BID and HS-BID approaches can be executed following the exact same workflow while replacing the command pm-lid-mesh with pm-bid and pm-hsbid respectively, and a change of the table name for the database is also recommended (e.g. change to ‘bid_phonon’). Computing and analyzing error tails The results of any finite displacement approach are only reliable if the discretization error has been properly controlled. Forward and backward finite difference guarantee a linear error tail, while central finite difference guarantees a quadratic error tail. Resolving the error tail is a sure sign that the discretization error has been properly extrapolated to zero. For phonons, we will be taking either the first derivatives of the forces or the second derivatives of the energy, which are typically not sensitive. Therefore, it is common practice to use a single finite displacement (i.e. a single delta), and then there is nothing to analyze. However, there are plenty of situations where one does find sensitive results, such as metallic systems with Fermi surface nesting or even band insulators when using the SCAN functional. If one computes three or more deltas, then the error tail can be scrutinized to judge the quality of the result.\nTo examine the error tails, the corresponding data must be output during the post-processing of results. The above lid-mesh commands needs the –err-output flag as follows:\npm-lid-mesh --load-lid-mesh lid_mesh.hdf5 --config config.yml \\ --post --save-fi --save-ids --save-dts --err-output error_tails.hdf5 The next step is extract the results from the hdf5 file and output them to individual yaml files:\npm-convert-errortail error_tails.hdf5 The yaml files can then be plotted to PDF files. For example:\npm-plot-errortail 1_0_errortail.yml --iscomplex --output 1_0_errortail.pdf At present, one can execute a loop in bash over all the files:\nfor i in *_errortail.yml; do echo $i pm-plot-errortail $i --iscomplex --output $(basename $i .yml).pdf done Computing phonon dispersion and DOS With the fourier_interpolation.hdf5 file obtained at second order, we can compute phonon dispersion and density of states (DOS).\nLet’s continue the NaCl example and first prepare the configuration file phonon_config.yml for computing the phonon dispersion and DOS:\n# phonon_config.yml band: - ['0 0 0', '1/2 1/2 0'] - ['-1/2 1/2 0', '0 0 0'] - ['0 0 0', '1/2 1/2 1/2'] band_label: - $\\Gamma$ - X - $\\Gamma$ - L mesh: 20 20 20 Then we can execute the following command to compute the band structure and DOS:\npm-phonon-band-dos --load-fi fourier_interpolation.hdf5 --config phonon_config.yml \\ --save-band --save-grid --save-dos --save-plot The following files are created in this step:\nband_plot_config.yml: A YAML file with the configuration the plot the band structure and DOS;\nbands.dat: A text file with the phonon band structure data computed with Fourier interpolation;\ngrid_phonons.dat: A text file with the data of the phonons that are measured at the FTG that fall on the path in the plot;\ndos.dat: A text file with the data of phonon DOS.\nWe can plot the phonon band structure and DOS with the following command:\npm-plot-band -s band_plot_config.yml Phonon bands and DOS of NaCl ","categories":"","description":"Describes how to compute irreducible derivatives for a xtal using LID or BID.\n","excerpt":"Describes how to compute irreducible derivatives for a xtal using LID …","ref":"/docs/functionality/compute-id/","tags":"","title":"Compute Irreducible Derivative"},{"body":"Finite difference is used to compute phonons and phonon interactions in PM, and this module isolates all the tasks associated with performing finite difference. Here we give some examples to illustrate the key features.\nLet us consider a potential with three variables, labeled 0, 1, 2, and set up all derivatives to second order. Begin by instantiating the class:\n\u003e\u003e\u003e from principia_materia.finite_difference.finite_difference_np import FiniteDifferenceNP \u003e\u003e\u003e fd=FiniteDifferenceNP() Set all the derivatives to be evaluated:\n\u003e\u003e\u003e fd.set_deriv(varset=[[0],[1],[2],[0,1],[0,2],[1,2]], ... ordset=[[2],[2],[2],[1,1],[1,1],[1,1]]) Set the deltas to be the same for all variables and setup the finite difference amplitudes:\n\u003e\u003e\u003e fd.set_delta_global([0.01,0.02]) \u003e\u003e\u003e fd.setup_amplitude() We now have all the information we need to perform finite difference. For example, all amplitudes associated with a given set of variables is retrieved as:\n\u003e\u003e\u003e print (fd.get_var_amplitude([0,2])) [[-0.02 -0.02] [-0.02 0.02] [-0.01 -0.01] [-0.01 0.01] [ 0.01 -0.01] [ 0.01 0.01] [ 0.02 -0.02] [ 0.02 0.02]] In more complicated scenarios, the same amplitudes would appear multiple times, but this class accounts for that when making a final list of amplitudes. Take the following example containing second and fourth derivatives:\n\u003e\u003e\u003e fd.set_deriv(varset=[[0,1],[0,1]], ... ordset=[[1,1],[2,2]]) Inspecting the list of amplitudes for variable [0,1], we see:\n\u003e\u003e\u003e print (fd.get_var_amplitude([0,1])) [[-0.02 -0.02] [-0.02 0.02] [-0.01 -0.01] [-0.01 0.01] [ 0.01 -0.01] [ 0.01 0.01] [ 0.02 -0.02] [ 0.02 0.02] [-0.04 -0.04] [-0.04 0.04] [ 0.04 -0.04] [ 0.04 0.04]] The same amplitudes are used for both the second and fourth derivatives, and the class is aware of this. Additionally, the fourth derivatives will need cases where one amplitude is zero, which do not appear. In this case, the class creates a new variable sets [0] and [1] that contain these amplitudes. For example,\n\u003e\u003e\u003e print (fd.get_var_amplitude([0])) [[-0.04] [-0.02] [ 0.02] [ 0.04]] ","categories":"","description":"This module sets up arbitrary order finite difference calculations for an arbitrary number of variables.\n","excerpt":"This module sets up arbitrary order finite difference calculations for …","ref":"/docs/modules/finite-difference/","tags":"","title":"Finite Difference"},{"body":"Second and third order irreducible derivatives must be computed first, as described here, and the second and third order force constants may then be used to predict the phonon linewidth using perturbation theory. The phonons and the linewidths can then be used to computed thermal conductivity with the relaxation time approximation.\nPhonon Linewidth Here we continue the NaCl example from before.\nFirst, we need to prepare a configuration file config.yml for the pm-conductivity command:\n# config.yml structure: xtal.yml load_fi2: fi_order2.hdf5 load_fi3: fi_order3.hdf5 mesh: [11, 11, 11] band: - ['0 0 0', '1/2 1/2 0'] - ['-1/2 1/2 0', '0 0 0'] - ['0 0 0', '1/2 1/2 1/2'] band_label: - $\\Gamma$ - X - $\\Gamma$ - L where:\nxtal.yml contains structure of NaCl;\nfi_order2.hdf5 is the HDF5 data file for the FourierInterpolation class at second order, which contains the 2nd order force constants;\nfi_order3.hdf5 is the HDF5 data file for the FourierInterpolation class at third order, which contains the 3rd order force constants.\nIn this example, we use the FourierInterpolation object of a \\(\\hat{S}_{BZ}=4\\hat{\\mathbf{1}}\\) FTG (i.e. a \\(4 \\times 4 \\times 4\\) supercell) at second order and the FourierInterpolation object of a \\(\\hat{S} _{BZ}=2\\hat{\\mathbf{1}}\\) FTG (i.e. a \\(2 \\times 2 \\times 2\\) supercell) at third order. We interpolate the phonons and phonon interactions to the mesh of \\(11\\hat{\\mathbf{1}}\\), and compute the linewidth along the K-path \\(\\Gamma \\to X \\to \\Gamma \\to L\\).\nExecute the following command the compute the phonon linewidth:\npm-conductivity --config config.yml --save-gamma Thermal Conductivity Using the same NaCl example, we can prepare a configuration file config.yml similar to the one above:\n# config.yml structure: xtal.yml load_fi2: fi_order2.hdf5 load_fi3: fi_order3.hdf5 mesh: [11, 11, 11] Execute the following command the compute the thermal conductivity using relaxation time approximation (RTA):\npm-conductivity --config config.yml --save-kappa --mode RTA ","categories":"","description":"Using second and third order irreducible derivatives to compute the phonon linewidth and thermal conductivity.\n","excerpt":"Using second and third order irreducible derivatives to compute the …","ref":"/docs/functionality/phonon-linewidth/","tags":"","title":"Phonon Linewidth and Thermal Conductivity"},{"body":"Here we document all aspects of the code.\n","categories":"","description":"","excerpt":"Here we document all aspects of the code.\n","ref":"/docs/","tags":"","title":"Documentation"},{"body":"","categories":"","description":"","excerpt":"","ref":"/blog/news/","tags":"","title":"News About Docsy"},{"body":"","categories":"","description":"","excerpt":"","ref":"/blog/releases/","tags":"","title":"New Releases"},{"body":"principia_materia package principia_materia.translation_group package\nSubmodules\nprincipia_materia.translation_group.cluster module\nCluster\nget_cluster_io_wrapper()\nprincipia_materia.translation_group.crystal module\nCrystal\nget_crystal_io_wrapper()\nprincipia_materia.translation_group.crystal_ftg module\nCrystalFTG\nget_crystal_ftg_io_wrapper()\nprincipia_materia.translation_group.kpoints module\nKpoints\nget_kpoints_io_wrapper()\nprincipia_materia.translation_group.lattice module\nLattice\nget_lattice_io_wrapper()\nprincipia_materia.translation_group.lattice_ftg module\nLatticeFTG\nget_lattice_ftg_io_wrapper()\nget_lattice_points()\nprincipia_materia.translation_group.minimum_supercell module\nget_minimum_supercell() principia_materia.translation_group.qpoints_n module\nQpointsN\nQpointsPerm\nget_QpointsN_io_wrapper()\nprincipia_materia.translation_group.wigner_seitz module\nWignerSeitz Module contents\nfit_in_supercell()\nget_structure()\nregister_structure_datawrapper_type()\nregister_structure_hdf5wrapper_type()\nsave_structure()\nprincipia_materia.representation package\nSubmodules\nprincipia_materia.representation.base_representation module\nBaseRepresentation\nkronecker_product()\nprincipia_materia.representation.charm_bloch_rep module\nCharmBlochRep principia_materia.representation.cluster_rep module\nClusterRep principia_materia.representation.direct_product module\nDirectProduct\nget_irrep_name()\nprincipia_materia.representation.disp_cluster_rep module\nDispClusterRep principia_materia.representation.qstar_rep module\nQStarRep\nSymmetricQStarRep\nprincipia_materia.representation.shift_mode module\nShiftMode principia_materia.representation.single_tensor_rep module\nSingleTensorRep principia_materia.representation.symmetric_direct_product module\nSymmetricDirectProduct Module contents\nprincipia_materia.hamiltonian package\nSubmodules\nprincipia_materia.hamiltonian.electron_hamiltonian module\nElectronHamiltonian principia_materia.hamiltonian.hamiltonian module\nHamiltonian principia_materia.hamiltonian.model_hamiltonian module\nModelHamiltonian\nformat_hamiltonian_to_yaml()\nget_ModelHamiltonian_hdf5_wrapper()\nget_ModelHamiltonian_yaml_wrapper()\nget_modelhamiltonian_from_hdf5()\nget_modelhamiltonian_from_yaml()\nload_hamiltonian()\nsave_modelhamiltonian_to_hdf5()\nsave_modelhamiltonian_to_yaml()\nprincipia_materia.hamiltonian.phonon_hamiltonian module\nPhononHamiltonian Module contents\nprincipia_materia.io_interface package\nSubmodules\nprincipia_materia.io_interface.array_io module\nArrayFormatter\nformat_array()\npad_array()\nparse_array()\nparse_expression()\nparse_number()\ntex_array_formatter()\nprincipia_materia.io_interface.base_data_wrapper module\nBaseDataWrapper principia_materia.io_interface.compute_job module\nComputeJob principia_materia.io_interface.compute_job_series module\nComputeJobSeries principia_materia.io_interface.data_wrapper module\nDataWrapper principia_materia.io_interface.hdf5_wrapper module\nHDF5Wrapper principia_materia.io_interface.jobs_db module\nJobsDB principia_materia.io_interface.qpoints_io module\narray_to_list()\narray_to_tuple()\nprincipia_materia.io_interface.vasp module\nparse_poscar()\nwrite_poscar()\nprincipia_materia.io_interface.yaml_dump module\nyaml_dumps() Module contents\nformat_tensor()\nget_compute_engine_map()\nindent()\njobs_series_to_jobs_db()\ntuple_to_str()\nprincipia_materia.mathematics package\nSubmodules\nprincipia_materia.mathematics.array_utils module\narray_in_2darray()\nindex_array_in_array()\nprincipia_materia.mathematics.core_math module\ngaussian()\ngs_orthog()\nprincipia_materia.mathematics.errortail module\nfit_errortail()\ngenerate_picks()\nget_errortail()\nget_errortail_yaml_wrapper()\nleast_square()\npenalty_linear_mse()\npenalty_sqrt_mse()\npenalty_square_mse()\nprincipia_materia.mathematics.finite_difference module\nFiniteDifference principia_materia.mathematics.fourier_transform module\nbackward_fourier_transform()\nforward_fourier_transform()\nprincipia_materia.mathematics.new_fraction module\nFraction principia_materia.mathematics.smith_normal_form module\nDiagonalForm()\nHermiteNormalForm_AU()\nHermiteNormalForm_UA()\nSmithNormalForm()\nprincipia_materia.mathematics.tensor_utils module\nfind_linearly_independent_vectors()\nfind_most_linearly_independent_rows()\nrotate_tensor()\nModule contents\nint_det() principia_materia.phonon_id package\nSubmodules\nprincipia_materia.phonon_id.analytic_dynamic_tensor module\nAnalyticDynamicTensor\nget_AnalyticDynamicTensor_hdf5_wrapper()\nget_IrreducibleDerivatives_hdf5_wrapper()\nprincipia_materia.phonon_id.analytic_strain_tensor module\nAnalyticStrainTensor principia_materia.phonon_id.analytic_tensors module\nAnalyticTensors\nget_AnalyticTensors_from_hdf5()\nget_AnalyticTensors_hdf5_wrapper()\nsave_AnalyticTensors_to_hdf5()\nprincipia_materia.phonon_id.anharmonic_interpolation module\nAnharmincInterpolation\nmode_heat_capacuty()\nprincipia_materia.phonon_id.bid module\nBID\nDisplacementGenerator\nRandomDisplacementGenerator\nformat_measurement_label()\nget_BID_from_hdf5()\nget_BID_hdf5_wrapper()\nsave_BID_to_hdf5()\nsave_bid_errortails()\nprincipia_materia.phonon_id.chainrule_derivatives module\nChainruleDerivatives\nget_ChainruleDerivatives_from_hdf5()\nget_ChainruleDerivatives_hdf5_wrapper()\nsave_ChainruleDerivatives_to_hdf5()\nprincipia_materia.phonon_id.conductivity module\nConductivity\nbedist()\nreciprocal()\nprincipia_materia.phonon_id.dipole_dipole module\nDipoleDipole\nget_DipoleDipole_from_yaml()\nget_dipole_dataset_yaml_wrapper()\nsave_DipoleDipole_to_yaml()\nprincipia_materia.phonon_id.dynamic_tensors module\nDynamicTensors\nget_DynamicTensors_from_hdf5()\nget_DynamicTensors_hdf5_wrapper()\nsave_DynamicTensors_to_hdf5()\nprincipia_materia.phonon_id.fd_series module\nFDSeries\nformat_delta_dirname()\nget_FDSeries_from_hdf5()\nget_FDSeries_hdf5_wrapper()\nget_FDSeries_results_hdf5_wrapper()\nsave_FDSeries_results_to_hdf5()\nsave_FDSeries_to_hdf5()\nprincipia_materia.phonon_id.finite_displacements module\nFiniteDisplacements\nget_FD_from_configuration()\nget_fd_config_hdf5_wrapper()\nget_fd_config_yaml_wrapper()\nget_fd_results_hdf5_wrapper()\nget_fd_results_yaml_wrapper()\nsave_FD_config_to_hdf5()\nsave_FD_config_to_yaml()\nprincipia_materia.phonon_id.fourier_interpolation module\nFourierInterpolation\nget_FourierInterpolation_from_hdf5()\nget_FourierInterpolation_hdf5_wrapper()\nsave_FourierInterpolation_to_hdf5()\nprincipia_materia.phonon_id.frozen_phonons module\nFrozenPhonons\nLoneQ_FP\nfind_realspace_displacements()\nfind_unique()\nformat_irrep_instances()\nformat_measurement_label()\nget_FrozenPhonons_hdf5_wrapper()\nget_LoneQ_from_hdf5()\nget_dynamic_tensor_wrapper()\nis_qpoint_real()\nload_fp_errortails()\nmake_displacement_identifier()\nsave_LoneQ_to_hdf5()\nsave_dynamic_tensor_to_hdf5()\nsave_fp_errortails()\nprincipia_materia.phonon_id.hsbid module\nHSBID\nfind_hierarchical_supercells()\nformat_supa_dirname()\nget_HSBID_from_hdf5()\nget_HSBID_hdf5_wrapper()\nsave_HSBID_to_hdf5()\nprincipia_materia.phonon_id.lid module\nLoneID_FP\nget_LoneID_from_hdf5()\nget_LoneID_hdf5_wrapper()\nsave_LoneID_to_hdf5()\nprincipia_materia.phonon_id.lid_mesh module\nLIDMesh\nget_LIDMesh_config_wrapper()\nget_LIDMesh_from_hdf5()\nget_LIDMesh_from_yaml()\nget_LIDMesh_hdf5_wrapper()\nsave_LIDMesh_to_hdf5()\nsave_LIDMesh_to_yaml()\nprincipia_materia.phonon_id.little_group_adt module\nLittleGroupADT\nget_LittleGroupADT_from_hdf5()\ninverse_qpoint()\nsave_LittleGroupADT_to_hdf5()\nprincipia_materia.phonon_id.phonon_db module\ncreate_BID_table()\ncreate_LID_table()\ncreate_metadata_table()\ncreate_strain_table()\nprincipia_materia.phonon_id.phonon_report_util module\nsummarize_bid()\nsummarize_hsbid()\nsummarize_lid()\nsummarize_lid_mesh()\nsummarize_structure()\nprincipia_materia.phonon_id.phonon_tools module\nadjust_eigenvectors_subspace()\ncompute_eigenvalues()\ncompute_phonon_frequencies_from_eigenvalues()\ncompute_phonons()\nfind_degenerate_frequencies()\nget_mass_matrix()\nmultiply_mass_matrix()\nprincipia_materia.phonon_id.strained_finite_displacements module\nStrainedFiniteDisplacements\nget_StrainedFD_from_configuration()\nget_strain_fd_config_hdf5_wrapper()\nget_strain_fd_config_yaml_wrapper()\nsave_StrainedFD_config_to_hdf5()\nsave_StrainedFD_config_to_yaml()\nModule contents\nprincipia_materia.plotting package\nSubmodules\nprincipia_materia.plotting.kpath module\nKPath principia_materia.plotting.plot_band module\nget_band_plot_config_wrapper()\nmain()\nplot_band()\nprincipia_materia.plotting.plot_errortail module\nmain()\nplot_errortail()\nModule contents\nprincipia_materia.symmetry package\nSubmodules\nprincipia_materia.symmetry.cornwell_data module\nCornwell_group_matrices\nCornwell_point_group\nprincipia_materia.symmetry.little_group module\nget_little_group() principia_materia.symmetry.point_group module\nPointGroup\nclass_method_descriptor\nfind_inv()\ngroup_lineage()\nModule contents\nprincipia_materia.tetrahedron package\nSubmodules\nprincipia_materia.tetrahedron.tetrahedra module\nTetrahedra Module contents\nprincipia_materia.utils package\nSubmodules\nprincipia_materia.utils.config_manager module\nupdate_recursive() principia_materia.utils.db_utils module\nSQLiteDB\nadapt_array()\nconvert_array()\nprincipia_materia.utils.testing module\nassertDictAlmostEqual()\nassertDictEqual()\nprincipia_materia.utils.text_file_search module\nfind_all()\nfind_first()\nfind_last()\nsearch()\nModule contents\nprincipia_materia.constants package\nSubmodules\nprincipia_materia.constants.periodic_table module\nprincipia_materia.constants.physical_constant module\nPhysicalConstant principia_materia.constants.point_group_notation_table module\nprincipia_materia.constants.unit_conversion module\nUnitConversion Module contents\n","categories":"","description":"API References for Principia Materia package\n","excerpt":"API References for Principia Materia package\n","ref":"/docs/references/","tags":"","title":"API References"},{"body":"This is a typical blog post that includes images.\nThe front matter specifies the date of the blog post, its title, a short description that will be displayed on the blog landing page, and its author.\nIncluding images Here’s an image (featured-sunset-get.png) that includes a byline and a caption.\nFetch and scale an image in the upcoming Hugo 0.43. Photo: Riona MacNamara / CC-BY-CA\nThe front matter of this post specifies properties to be assigned to all image resources:\nresources: - src: \"**.{png,jpg}\" title: \"Image #:counter\" params: byline: \"Photo: Riona MacNamara / CC-BY-CA\" To include the image in a page, specify its details like this:\nFetch and scale an image in the upcoming Hugo 0.43. Photo: Riona MacNamara / CC-BY-CA\nThe image will be rendered at the size and byline specified in the front matter.\n","categories":"","description":"The Docsy Hugo theme lets project maintainers and contributors focus on content, not on reinventing a website infrastructure from scratch","excerpt":"The Docsy Hugo theme lets project maintainers and contributors focus …","ref":"/blog/2018/10/06/easy-documentation-with-docsy/","tags":"","title":"Easy documentation with Docsy"},{"body":"Text can be bold, italic, or strikethrough. Links should be blue with no underlines (unless hovered over).\nThere should be whitespace between paragraphs. There should be whitespace between paragraphs. There should be whitespace between paragraphs. There should be whitespace between paragraphs.\nThere should be whitespace between paragraphs. There should be whitespace between paragraphs. There should be whitespace between paragraphs. There should be whitespace between paragraphs.\nThere should be no margin above this first sentence.\nBlockquotes should be a lighter gray with a border along the left side in the secondary color.\nThere should be no margin below this final sentence.\nFirst Header This is a normal paragraph following a header. Bacon ipsum dolor sit amet t-bone doner shank drumstick, pork belly porchetta chuck sausage brisket ham hock rump pig. Chuck kielbasa leberkas, pork bresaola ham hock filet mignon cow shoulder short ribs biltong. Bacon ipsum dolor sit amet t-bone doner shank drumstick, pork belly porchetta chuck sausage brisket ham hock rump pig. Chuck kielbasa leberkas, pork bresaola ham hock filet mignon cow shoulder short ribs biltong. Bacon ipsum dolor sit amet t-bone doner shank drumstick, pork belly porchetta chuck sausage brisket ham hock rump pig. Chuck kielbasa leberkas, pork bresaola ham hock filet mignon cow shoulder short ribs biltong.\nBacon ipsum dolor sit amet t-bone doner shank drumstick, pork belly porchetta chuck sausage brisket ham hock rump pig. Chuck kielbasa leberkas, pork bresaola ham hock filet mignon cow shoulder short ribs biltong.\nOn big screens, paragraphs and headings should not take up the full container width, but we want tables, code blocks and similar to take the full width.\nLorem markdownum tuta hospes stabat; idem saxum facit quaterque repetito occumbere, oves novem gestit haerebat frena; qui. Respicit recurvam erat: pignora hinc reppulit nos aut, aptos, ipsa.\nMeae optatos passa est Epiros utiliter Talibus niveis, hoc lata, edidit. Dixi ad aestum.\nHeader 2 This is a blockquote following a header. Bacon ipsum dolor sit amet t-bone doner shank drumstick, pork belly porchetta chuck sausage brisket ham hock rump pig. Chuck kielbasa leberkas, pork bresaola ham hock filet mignon cow shoulder short ribs biltong.\nHeader 3 This is a code block following a header. Header 4 This is an unordered list following a header. This is an unordered list following a header. This is an unordered list following a header. Header 5 This is an ordered list following a header. This is an ordered list following a header. This is an ordered list following a header. Header 6 What Follows A table A header A table A header A table A header There’s a horizontal rule above and below this.\nHere is an unordered list:\nSalt-n-Pepa Bel Biv DeVoe Kid ‘N Play And an ordered list:\nMichael Jackson Michael Bolton Michael Bublé And an unordered task list:\nCreate a sample markdown document Add task lists to it Take a vacation And a “mixed” task list:\nSteal underpants ? Profit! And a nested list:\nJackson 5 Michael Tito Jackie Marlon Jermaine TMNT Leonardo Michelangelo Donatello Raphael Definition lists can be used with Markdown syntax. Definition terms are bold.\nName Godzilla Born 1952 Birthplace Japan Color Green Tables should have bold headings and alternating shaded rows.\nArtist Album Year Michael Jackson Thriller 1982 Prince Purple Rain 1984 Beastie Boys License to Ill 1986 If a table is too wide, it should scroll horizontally.\nArtist Album Year Label Awards Songs Michael Jackson Thriller 1982 Epic Records Grammy Award for Album of the Year, American Music Award for Favorite Pop/Rock Album, American Music Award for Favorite Soul/R\u0026B Album, Brit Award for Best Selling Album, Grammy Award for Best Engineered Album, Non-Classical Wanna Be Startin’ Somethin’, Baby Be Mine, The Girl Is Mine, Thriller, Beat It, Billie Jean, Human Nature, P.Y.T. (Pretty Young Thing), The Lady in My Life Prince Purple Rain 1984 Warner Brothers Records Grammy Award for Best Score Soundtrack for Visual Media, American Music Award for Favorite Pop/Rock Album, American Music Award for Favorite Soul/R\u0026B Album, Brit Award for Best Soundtrack/Cast Recording, Grammy Award for Best Rock Performance by a Duo or Group with Vocal Let’s Go Crazy, Take Me With U, The Beautiful Ones, Computer Blue, Darling Nikki, When Doves Cry, I Would Die 4 U, Baby I’m a Star, Purple Rain Beastie Boys License to Ill 1986 Mercury Records noawardsbutthistablecelliswide Rhymin \u0026 Stealin, The New Style, She’s Crafty, Posse in Effect, Slow Ride, Girls, (You Gotta) Fight for Your Right, No Sleep Till Brooklyn, Paul Revere, Hold It Now, Hit It, Brass Monkey, Slow and Low, Time to Get Ill Code snippets like var foo = \"bar\"; can be shown inline.\nAlso, this should vertically align with this and this.\nCode can also be shown in a block element.\nfoo := \"bar\"; bar := \"foo\"; Code can also use syntax highlighting.\nfunc main() { input := `var foo = \"bar\";` lexer := lexers.Get(\"javascript\") iterator, _ := lexer.Tokenise(nil, input) style := styles.Get(\"github\") formatter := html.New(html.WithLineNumbers()) var buff bytes.Buffer formatter.Format(\u0026buff, style, iterator) fmt.Println(buff.String()) } Long, single-line code blocks should not wrap. They should horizontally scroll if they are too long. This line should be long enough to demonstrate this. Inline code inside table cells should still be distinguishable.\nLanguage Code Javascript var foo = \"bar\"; Ruby foo = \"bar\"{ Small images should be shown at their actual size.\nLarge images should always scale down and fit in the content container.\nComponents Alerts This is an alert. Note: This is an alert with a title. This is a successful alert. This is a warning! Warning! This is a warning with a title! Sizing Add some sections here to see how the ToC looks like. Bacon ipsum dolor sit amet t-bone doner shank drumstick, pork belly porchetta chuck sausage brisket ham hock rump pig. Chuck kielbasa leberkas, pork bresaola ham hock filet mignon cow shoulder short ribs biltong.\nParameters available Bacon ipsum dolor sit amet t-bone doner shank drumstick, pork belly porchetta chuck sausage brisket ham hock rump pig. Chuck kielbasa leberkas, pork bresaola ham hock filet mignon cow shoulder short ribs biltong.\nUsing pixels Bacon ipsum dolor sit amet t-bone doner shank drumstick, pork belly porchetta chuck sausage brisket ham hock rump pig. Chuck kielbasa leberkas, pork bresaola ham hock filet mignon cow shoulder short ribs biltong.\nUsing rem Bacon ipsum dolor sit amet t-bone doner shank drumstick, pork belly porchetta chuck sausage brisket ham hock rump pig. Chuck kielbasa leberkas, pork bresaola ham hock filet mignon cow shoulder short ribs biltong.\nMemory Bacon ipsum dolor sit amet t-bone doner shank drumstick, pork belly porchetta chuck sausage brisket ham hock rump pig. Chuck kielbasa leberkas, pork bresaola ham hock filet mignon cow shoulder short ribs biltong.\nRAM to use Bacon ipsum dolor sit amet t-bone doner shank drumstick, pork belly porchetta chuck sausage brisket ham hock rump pig. Chuck kielbasa leberkas, pork bresaola ham hock filet mignon cow shoulder short ribs biltong.\nMore is better Bacon ipsum dolor sit amet t-bone doner shank drumstick, pork belly porchetta chuck sausage brisket ham hock rump pig. Chuck kielbasa leberkas, pork bresaola ham hock filet mignon cow shoulder short ribs biltong.\nUsed RAM Bacon ipsum dolor sit amet t-bone doner shank drumstick, pork belly porchetta chuck sausage brisket ham hock rump pig. Chuck kielbasa leberkas, pork bresaola ham hock filet mignon cow shoulder short ribs biltong.\nThis is the final element on the page and there should be no margin below this. ","categories":"","description":"A short lead description about this content page. Text here can also be **bold** or _italic_ and can even be split over multiple paragraphs.\n","excerpt":"A short lead description about this content page. Text here can also …","ref":"/blog/2018/10/06/the-second-blog-post/","tags":"","title":"The second blog post"},{"body":"Text can be bold, italic, or strikethrough. Links should be blue with no underlines (unless hovered over).\nThere should be whitespace between paragraphs. There should be whitespace between paragraphs. There should be whitespace between paragraphs. There should be whitespace between paragraphs.\nThere should be whitespace between paragraphs. There should be whitespace between paragraphs. There should be whitespace between paragraphs. There should be whitespace between paragraphs.\nThere should be no margin above this first sentence.\nBlockquotes should be a lighter gray with a border along the left side in the secondary color.\nThere should be no margin below this final sentence.\nFirst Header This is a normal paragraph following a header. Bacon ipsum dolor sit amet t-bone doner shank drumstick, pork belly porchetta chuck sausage brisket ham hock rump pig. Chuck kielbasa leberkas, pork bresaola ham hock filet mignon cow shoulder short ribs biltong. Bacon ipsum dolor sit amet t-bone doner shank drumstick, pork belly porchetta chuck sausage brisket ham hock rump pig. Chuck kielbasa leberkas, pork bresaola ham hock filet mignon cow shoulder short ribs biltong. Bacon ipsum dolor sit amet t-bone doner shank drumstick, pork belly porchetta chuck sausage brisket ham hock rump pig. Chuck kielbasa leberkas, pork bresaola ham hock filet mignon cow shoulder short ribs biltong.\nBacon ipsum dolor sit amet t-bone doner shank drumstick, pork belly porchetta chuck sausage brisket ham hock rump pig. Chuck kielbasa leberkas, pork bresaola ham hock filet mignon cow shoulder short ribs biltong.\nOn big screens, paragraphs and headings should not take up the full container width, but we want tables, code blocks and similar to take the full width.\nLorem markdownum tuta hospes stabat; idem saxum facit quaterque repetito occumbere, oves novem gestit haerebat frena; qui. Respicit recurvam erat: pignora hinc reppulit nos aut, aptos, ipsa.\nMeae optatos passa est Epiros utiliter Talibus niveis, hoc lata, edidit. Dixi ad aestum.\nHeader 2 This is a blockquote following a header. Bacon ipsum dolor sit amet t-bone doner shank drumstick, pork belly porchetta chuck sausage brisket ham hock rump pig. Chuck kielbasa leberkas, pork bresaola ham hock filet mignon cow shoulder short ribs biltong.\nHeader 3 This is a code block following a header. Header 4 This is an unordered list following a header. This is an unordered list following a header. This is an unordered list following a header. Header 5 This is an ordered list following a header. This is an ordered list following a header. This is an ordered list following a header. Header 6 What Follows A table A header A table A header A table A header There’s a horizontal rule above and below this.\nHere is an unordered list:\nSalt-n-Pepa Bel Biv DeVoe Kid ‘N Play And an ordered list:\nMichael Jackson Michael Bolton Michael Bublé And an unordered task list:\nCreate a sample markdown document Add task lists to it Take a vacation And a “mixed” task list:\nSteal underpants ? Profit! And a nested list:\nJackson 5 Michael Tito Jackie Marlon Jermaine TMNT Leonardo Michelangelo Donatello Raphael Definition lists can be used with Markdown syntax. Definition terms are bold.\nName Godzilla Born 1952 Birthplace Japan Color Green Tables should have bold headings and alternating shaded rows.\nArtist Album Year Michael Jackson Thriller 1982 Prince Purple Rain 1984 Beastie Boys License to Ill 1986 If a table is too wide, it should scroll horizontally.\nArtist Album Year Label Awards Songs Michael Jackson Thriller 1982 Epic Records Grammy Award for Album of the Year, American Music Award for Favorite Pop/Rock Album, American Music Award for Favorite Soul/R\u0026B Album, Brit Award for Best Selling Album, Grammy Award for Best Engineered Album, Non-Classical Wanna Be Startin’ Somethin’, Baby Be Mine, The Girl Is Mine, Thriller, Beat It, Billie Jean, Human Nature, P.Y.T. (Pretty Young Thing), The Lady in My Life Prince Purple Rain 1984 Warner Brothers Records Grammy Award for Best Score Soundtrack for Visual Media, American Music Award for Favorite Pop/Rock Album, American Music Award for Favorite Soul/R\u0026B Album, Brit Award for Best Soundtrack/Cast Recording, Grammy Award for Best Rock Performance by a Duo or Group with Vocal Let’s Go Crazy, Take Me With U, The Beautiful Ones, Computer Blue, Darling Nikki, When Doves Cry, I Would Die 4 U, Baby I’m a Star, Purple Rain Beastie Boys License to Ill 1986 Mercury Records noawardsbutthistablecelliswide Rhymin \u0026 Stealin, The New Style, She’s Crafty, Posse in Effect, Slow Ride, Girls, (You Gotta) Fight for Your Right, No Sleep Till Brooklyn, Paul Revere, Hold It Now, Hit It, Brass Monkey, Slow and Low, Time to Get Ill Code snippets like var foo = \"bar\"; can be shown inline.\nAlso, this should vertically align with this and this.\nCode can also be shown in a block element.\nfoo := \"bar\"; bar := \"foo\"; Code can also use syntax highlighting.\nfunc main() { input := `var foo = \"bar\";` lexer := lexers.Get(\"javascript\") iterator, _ := lexer.Tokenise(nil, input) style := styles.Get(\"github\") formatter := html.New(html.WithLineNumbers()) var buff bytes.Buffer formatter.Format(\u0026buff, style, iterator) fmt.Println(buff.String()) } Long, single-line code blocks should not wrap. They should horizontally scroll if they are too long. This line should be long enough to demonstrate this. Inline code inside table cells should still be distinguishable.\nLanguage Code Javascript var foo = \"bar\"; Ruby foo = \"bar\"{ Small images should be shown at their actual size.\nLarge images should always scale down and fit in the content container.\nComponents Alerts This is an alert. Note: This is an alert with a title. This is a successful alert. This is a warning! Warning! This is a warning with a title! Sizing Add some sections here to see how the ToC looks like. Bacon ipsum dolor sit amet t-bone doner shank drumstick, pork belly porchetta chuck sausage brisket ham hock rump pig. Chuck kielbasa leberkas, pork bresaola ham hock filet mignon cow shoulder short ribs biltong.\nParameters available Bacon ipsum dolor sit amet t-bone doner shank drumstick, pork belly porchetta chuck sausage brisket ham hock rump pig. Chuck kielbasa leberkas, pork bresaola ham hock filet mignon cow shoulder short ribs biltong.\nUsing pixels Bacon ipsum dolor sit amet t-bone doner shank drumstick, pork belly porchetta chuck sausage brisket ham hock rump pig. Chuck kielbasa leberkas, pork bresaola ham hock filet mignon cow shoulder short ribs biltong.\nUsing rem Bacon ipsum dolor sit amet t-bone doner shank drumstick, pork belly porchetta chuck sausage brisket ham hock rump pig. Chuck kielbasa leberkas, pork bresaola ham hock filet mignon cow shoulder short ribs biltong.\nMemory Bacon ipsum dolor sit amet t-bone doner shank drumstick, pork belly porchetta chuck sausage brisket ham hock rump pig. Chuck kielbasa leberkas, pork bresaola ham hock filet mignon cow shoulder short ribs biltong.\nRAM to use Bacon ipsum dolor sit amet t-bone doner shank drumstick, pork belly porchetta chuck sausage brisket ham hock rump pig. Chuck kielbasa leberkas, pork bresaola ham hock filet mignon cow shoulder short ribs biltong.\nMore is better Bacon ipsum dolor sit amet t-bone doner shank drumstick, pork belly porchetta chuck sausage brisket ham hock rump pig. Chuck kielbasa leberkas, pork bresaola ham hock filet mignon cow shoulder short ribs biltong.\nUsed RAM Bacon ipsum dolor sit amet t-bone doner shank drumstick, pork belly porchetta chuck sausage brisket ham hock rump pig. Chuck kielbasa leberkas, pork bresaola ham hock filet mignon cow shoulder short ribs biltong.\nThis is the final element on the page and there should be no margin below this. ","categories":"","description":"A short lead description about this content page. Text here can also be **bold** or _italic_ and can even be split over multiple paragraphs.\n","excerpt":"A short lead description about this content page. Text here can also …","ref":"/blog/2018/01/04/another-great-release/","tags":"","title":"Another Great Release"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/","tags":"","title":"Categories"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/docs/","tags":"","title":"docs"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/examples/","tags":"","title":"Examples"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/sample/","tags":"","title":"sample"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/","tags":"","title":"Tags"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/test/","tags":"","title":"test"},{"body":" About Principia Materia A bit about PM. PM is a group theory based code for performing calculations on crystals and moleculues.\nThis is another section ","categories":"","description":"","excerpt":" About Principia Materia A bit about PM. PM is a group theory based …","ref":"/about/","tags":"","title":"About Principia Materia"},{"body":"This is the blog section. It has two categories: News and Releases.\nFiles in these directories will be listed in reverse chronological order.\n","categories":"","description":"","excerpt":"This is the blog section. It has two categories: News and Releases. …","ref":"/blog/","tags":"","title":"Docsy Blog"},{"body":" ","categories":"","description":"","excerpt":" ","ref":"/community/","tags":"","title":"Community"},{"body":" Welcome to Principia Materia Learn More Download A group theory based software suite\nA feature list for PM\nthis That New chair metrics! The Goldydocs UI now shows chair size metrics by default.\nPlease follow this space for updates!\nContributions welcome! We do a Pull Request contributions workflow on GitHub. New users are always welcome!\nRead more …\nFollow us on Twitter! For announcement of latest features etc.\nRead more …\nThis is the second Section Download from AppStore Get the Goldydocs app!\nContributions welcome! We do a Pull Request contributions workflow on GitHub. New users are always welcome!\nRead more …\nFollow us on Twitter! For announcement of latest features etc.\nRead more …\nThis is another Section ","categories":"","description":"","excerpt":" Welcome to Principia Materia Learn More Download A group theory based …","ref":"/","tags":"","title":"Principia Materia"},{"body":"","categories":"","description":"","excerpt":"","ref":"/search/","tags":"","title":"Search Results"}]